"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMaximumWithdraw = exports.extractDAOData = exports.privateKeyToAddress = exports.privateKeyToPublicKey = exports.rawTransactionToHash = exports.scriptToHash = exports.blake160 = exports.bech32m = exports.bech32 = exports.blake2b = exports.PERSONAL = exports.JSBI = exports.serializeWitnessArgs = exports.serializeTransaction = exports.serializeRawTransaction = exports.serializeScript = exports.reconcilers = exports.systemScripts = exports.ECPair = void 0;
const tslib_1 = require("tslib");
const jsbi_1 = (0, tslib_1.__importDefault)(require("jsbi"));
exports.JSBI = jsbi_1.default;
const ecpair_js_1 = (0, tslib_1.__importDefault)(require("./ecpair.js"));
exports.ECPair = ecpair_js_1.default;
const index_js_1 = require("./convertors/index.js");
const index_js_2 = require("./address/index.js");
const index_js_3 = require("./exceptions/index.js");
const index_js_4 = (0, tslib_1.__importDefault)(require("./crypto/index.js"));
const index_js_5 = require("./serialization/index.js");
Object.defineProperty(exports, "serializeScript", { enumerable: true, get: function () { return index_js_5.serializeScript; } });
const occupiedCapacity_js_1 = require("./occupiedCapacity.js");
const transaction_js_1 = require("./serialization/transaction.js");
Object.defineProperty(exports, "serializeRawTransaction", { enumerable: true, get: function () { return transaction_js_1.serializeRawTransaction; } });
Object.defineProperty(exports, "serializeTransaction", { enumerable: true, get: function () { return transaction_js_1.serializeTransaction; } });
Object.defineProperty(exports, "serializeWitnessArgs", { enumerable: true, get: function () { return transaction_js_1.serializeWitnessArgs; } });
const const_js_1 = require("./const.js");
Object.defineProperty(exports, "PERSONAL", { enumerable: true, get: function () { return const_js_1.PERSONAL; } });
(0, tslib_1.__exportStar)(require("./address/index.js"), exports);
(0, tslib_1.__exportStar)(require("./serialization/index.js"), exports);
(0, tslib_1.__exportStar)(require("./convertors/index.js"), exports);
(0, tslib_1.__exportStar)(require("./exceptions/index.js"), exports);
(0, tslib_1.__exportStar)(require("./const.js"), exports);
(0, tslib_1.__exportStar)(require("./validators.js"), exports);
(0, tslib_1.__exportStar)(require("./epochs.js"), exports);
(0, tslib_1.__exportStar)(require("./sizes.js"), exports);
(0, tslib_1.__exportStar)(require("./occupiedCapacity.js"), exports);
(0, tslib_1.__exportStar)(require("./calculateTransactionFee.js"), exports);
exports.systemScripts = (0, tslib_1.__importStar)(require("./systemScripts.js"));
exports.reconcilers = (0, tslib_1.__importStar)(require("./reconcilers/index.js"));
exports.blake2b = index_js_4.default.blake2b, exports.bech32 = index_js_4.default.bech32, exports.bech32m = index_js_4.default.bech32m, exports.blake160 = index_js_4.default.blake160;
const scriptToHash = (script) => {
    if (!script)
        throw new index_js_3.ParameterRequiredException('Script');
    const serializedScript = (0, index_js_5.serializeScript)(script);
    const s = (0, exports.blake2b)(32, null, null, const_js_1.PERSONAL);
    s.update((0, index_js_1.hexToBytes)(serializedScript));
    const digest = s.digest('hex');
    return `0x${digest}`;
};
exports.scriptToHash = scriptToHash;
const rawTransactionToHash = (rawTransaction) => {
    if (!rawTransaction)
        throw new index_js_3.ParameterRequiredException('Raw transaction');
    const serializedRawTransaction = (0, transaction_js_1.serializeRawTransaction)(rawTransaction);
    const s = (0, exports.blake2b)(32, null, null, const_js_1.PERSONAL);
    s.update((0, index_js_1.hexToBytes)(serializedRawTransaction));
    const digest = s.digest('hex');
    return `0x${digest}`;
};
exports.rawTransactionToHash = rawTransactionToHash;
const privateKeyToPublicKey = (privateKey) => {
    const keyPair = new ecpair_js_1.default(privateKey);
    return keyPair.publicKey;
};
exports.privateKeyToPublicKey = privateKeyToPublicKey;
const privateKeyToAddress = (privateKey, options) => (0, index_js_2.pubkeyToAddress)((0, exports.privateKeyToPublicKey)(privateKey), options);
exports.privateKeyToAddress = privateKeyToAddress;
const extractDAOData = (dao) => {
    if (!dao.startsWith('0x')) {
        throw new index_js_3.HexStringWithout0xException(dao);
    }
    const value = dao.replace('0x', '');
    return {
        c: (0, index_js_1.toBigEndian)(`0x${value.slice(0, 16)}`),
        ar: (0, index_js_1.toBigEndian)(`0x${value.slice(16, 32)}`),
        s: (0, index_js_1.toBigEndian)(`0x${value.slice(32, 48)}`),
        u: (0, index_js_1.toBigEndian)(`0x${value.slice(48, 64)}`),
    };
};
exports.extractDAOData = extractDAOData;
const calculateMaximumWithdraw = (outputCell, outputDataCapacity, depositDAO, withdrawDAO) => {
    const depositCellSerialized = (0, occupiedCapacity_js_1.cellOccupied)(outputCell) + outputDataCapacity.slice(2).length / 2;
    const occupiedCapacity = jsbi_1.default.asUintN(128, jsbi_1.default.multiply(jsbi_1.default.BigInt(100000000), jsbi_1.default.BigInt(depositCellSerialized)));
    return `0x${jsbi_1.default.add(jsbi_1.default.divide(jsbi_1.default.multiply(jsbi_1.default.subtract(jsbi_1.default.asUintN(128, jsbi_1.default.BigInt(outputCell.capacity)), occupiedCapacity), jsbi_1.default.asUintN(128, jsbi_1.default.BigInt((0, exports.extractDAOData)(withdrawDAO).ar))), jsbi_1.default.asUintN(128, jsbi_1.default.BigInt((0, exports.extractDAOData)(depositDAO).ar))), occupiedCapacity).toString(16)}`;
};
exports.calculateMaximumWithdraw = calculateMaximumWithdraw;
//# sourceMappingURL=index.js.map