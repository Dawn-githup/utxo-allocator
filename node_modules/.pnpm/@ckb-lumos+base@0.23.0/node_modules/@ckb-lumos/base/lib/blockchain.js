"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WitnessArgs = exports.UncleBlockVec = exports.UncleBlock = exports.TransactionVec = exports.Transaction = exports.ScriptOpt = exports.Script = exports.RawTransaction = exports.RawHeader = exports.ProposalShortIdVec = exports.ProposalShortId = exports.OutPoint = exports.Header = exports.HashType = exports.DepType = exports.CellbaseWitness = exports.CellOutputVec = exports.CellOutput = exports.CellInputVec = exports.CellInput = exports.CellDepVec = exports.CellDep = exports.BytesVec = exports.BytesOptVec = exports.BytesOpt = exports.Bytes = exports.Byte32Vec = exports.Byte32 = exports.BlockV1 = exports.Block = exports.BaseHeader = void 0;
exports.WitnessArgsOf = WitnessArgsOf;
exports.createFixedHexBytesCodec = createFixedHexBytesCodec;
exports.deTransformHeaderCodecType = deTransformHeaderCodecType;
exports.deTransformTransactionCodecType = deTransformTransactionCodecType;
exports.transformHeaderCodecType = transformHeaderCodecType;
exports.transformTransactionCodecType = transformTransactionCodecType;
var _codec = require("@ckb-lumos/codec");
var _bi = require("@ckb-lumos/bi");
function asHexadecimal(codec) {
  return {
    ...codec,
    unpack: value => _bi.BI.from(codec.unpack(value)).toHexString()
  };
}
const Uint8 = asHexadecimal(_codec.number.Uint8);
const Uint32LE = asHexadecimal(_codec.number.Uint32LE);
const Uint64LE = asHexadecimal(_codec.number.Uint64LE);
const Uint128LE = asHexadecimal(_codec.number.Uint128LE);
const {
  byteVecOf,
  option,
  table,
  vector,
  struct
} = _codec.molecule;
const {
  bytify,
  hexify
} = _codec.bytes;
function createFixedHexBytesCodec(byteLength) {
  return (0, _codec.createFixedBytesCodec)({
    byteLength,
    pack: hex => bytify(hex),
    unpack: buf => hexify(buf)
  });
}

/**
 * placeholder codec, generally used as a placeholder
 * ```
 * // for example, when some BytesOpt is not used, it will be filled with this codec
 * // option BytesOpt (Bytes);
 * const UnusedBytesOpt = UnknownOpt
 * ```
 */
// export const UnusedOpt = option(Unknown);

// vector Bytes <byte>
const Bytes = exports.Bytes = byteVecOf({
  pack: bytify,
  unpack: hexify
});
const BytesOpt = exports.BytesOpt = option(Bytes);
const BytesVec = exports.BytesVec = vector(Bytes);
const BytesOptVec = exports.BytesOptVec = vector(BytesOpt);
const Byte32 = exports.Byte32 = createFixedHexBytesCodec(32);
const Byte32Vec = exports.Byte32Vec = vector(Byte32);
function WitnessArgsOf(payload) {
  return table({
    lock: option(byteVecOf(payload.lock)),
    inputType: option(byteVecOf(payload.inputType)),
    outputType: option(byteVecOf(payload.outputType))
  }, ["lock", "inputType", "outputType"]);
}
const HexifyCodec = (0, _codec.createBytesCodec)({
  pack: bytify,
  unpack: hexify
});

/**
 *
 * @example
 * ```ts
 * // secp256k1 lock witness
 * WitnessArgs.pack({ lock: '0x' + '00'.repeat(65) })
 * ```
 */
const WitnessArgs = exports.WitnessArgs = WitnessArgsOf({
  lock: HexifyCodec,
  inputType: HexifyCodec,
  outputType: HexifyCodec
});

/**
 * <pre>
 *  0b0000000 0
 *    ───┬─── │
 *       │    ▼
 *       │   type - use the default vm version
 *       │
 *       ▼
 * data* - use a particular vm version
 * </pre>
 *
 * Implementation of blockchain.mol
 * https://github.com/nervosnetwork/ckb/blob/5a7efe7a0b720de79ff3761dc6e8424b8d5b22ea/util/types/schemas/blockchain.mol
 */
const HashType = exports.HashType = (0, _codec.createFixedBytesCodec)({
  byteLength: 1,
  pack: type => {
    // prettier-ignore
    if (type === "type") return _codec.number.Uint8.pack(0b0000000_1);
    // prettier-ignore
    if (type === "data") return _codec.number.Uint8.pack(0b0000000_0);
    if (type === "data1") return _codec.number.Uint8.pack(0b0000001_0);
    if (type === "data2") return _codec.number.Uint8.pack(0b0000010_0);
    throw new Error(`Invalid hash type: ${type}`);
  },
  unpack: buf => {
    const hashTypeBuf = _codec.number.Uint8.unpack(buf);
    if (hashTypeBuf === 0b0000000_1) return "type";
    if (hashTypeBuf === 0b0000000_0) return "data";
    if (hashTypeBuf === 0b0000001_0) return "data1";
    if (hashTypeBuf === 0b0000010_0) return "data2";
    throw new Error(`Invalid hash type: ${hashTypeBuf}`);
  }
});
const DepType = exports.DepType = (0, _codec.createFixedBytesCodec)({
  byteLength: 1,
  pack: type => {
    if (type === "code") return Uint8.pack(0);
    if (type === "depGroup") return Uint8.pack(1);
    throw new Error(`Invalid dep type: ${type}`);
  },
  unpack: buf => {
    const depTypeBuf = _codec.number.Uint8.unpack(buf);
    if (depTypeBuf === 0) return "code";
    if (depTypeBuf === 1) return "depGroup";
    throw new Error(`Invalid dep type: ${depTypeBuf}`);
  }
});
const Script = exports.Script = table({
  codeHash: Byte32,
  hashType: HashType,
  args: Bytes
}, ["codeHash", "hashType", "args"]);
const ScriptOpt = exports.ScriptOpt = option(Script);
const OutPoint = exports.OutPoint = struct({
  txHash: Byte32,
  index: Uint32LE
}, ["txHash", "index"]);
const CellInput = exports.CellInput = struct({
  since: Uint64LE,
  previousOutput: OutPoint
}, ["since", "previousOutput"]);
const CellInputVec = exports.CellInputVec = vector(CellInput);
const CellOutput = exports.CellOutput = table({
  capacity: Uint64LE,
  lock: Script,
  type: ScriptOpt
}, ["capacity", "lock", "type"]);
const CellOutputVec = exports.CellOutputVec = vector(CellOutput);
const CellDep = exports.CellDep = struct({
  outPoint: OutPoint,
  depType: DepType
}, ["outPoint", "depType"]);
const CellDepVec = exports.CellDepVec = vector(CellDep);
const RawTransaction = exports.RawTransaction = table({
  version: Uint32LE,
  cellDeps: CellDepVec,
  headerDeps: Byte32Vec,
  inputs: CellInputVec,
  outputs: CellOutputVec,
  outputsData: BytesVec
}, ["version", "cellDeps", "headerDeps", "inputs", "outputs", "outputsData"]);
const BaseTransaction = table({
  raw: RawTransaction,
  witnesses: BytesVec
}, ["raw", "witnesses"]);
const Transaction = exports.Transaction = (0, _codec.createBytesCodec)({
  pack: tx => BaseTransaction.pack(transformTransactionCodecType(tx)),
  unpack: buf => deTransformTransactionCodecType(BaseTransaction.unpack(buf))
});
const TransactionVec = exports.TransactionVec = vector(Transaction);
const RawHeader = exports.RawHeader = struct({
  version: Uint32LE,
  compactTarget: Uint32LE,
  timestamp: Uint64LE,
  number: Uint64LE,
  epoch: Uint64LE,
  parentHash: Byte32,
  transactionsRoot: Byte32,
  proposalsHash: Byte32,
  extraHash: Byte32,
  dao: Byte32
}, ["version", "compactTarget", "timestamp", "number", "epoch", "parentHash", "transactionsRoot", "proposalsHash", "extraHash", "dao"]);
const BaseHeader = exports.BaseHeader = struct({
  raw: RawHeader,
  nonce: Uint128LE
}, ["raw", "nonce"]);
const Header = exports.Header = (0, _codec.createBytesCodec)({
  pack: header => BaseHeader.pack(transformHeaderCodecType(header)),
  unpack: buf => deTransformHeaderCodecType(BaseHeader.unpack(buf))
});
const ProposalShortId = exports.ProposalShortId = createFixedHexBytesCodec(10);
const ProposalShortIdVec = exports.ProposalShortIdVec = vector(ProposalShortId);
const UncleBlock = exports.UncleBlock = table({
  header: Header,
  proposals: ProposalShortIdVec
}, ["header", "proposals"]);
const UncleBlockVec = exports.UncleBlockVec = vector(UncleBlock);
const Block = exports.Block = table({
  header: Header,
  uncles: UncleBlockVec,
  transactions: TransactionVec,
  proposals: ProposalShortIdVec
}, ["header", "uncles", "transactions", "proposals"]);
const BlockV1 = exports.BlockV1 = table({
  header: Header,
  uncles: UncleBlockVec,
  transactions: TransactionVec,
  proposals: ProposalShortIdVec,
  extension: Bytes
}, ["header", "uncles", "transactions", "proposals", "extension"]);
const CellbaseWitness = exports.CellbaseWitness = table({
  lock: Script,
  message: Bytes
}, ["lock", "message"]);

// TODO make an enhancer for number codecs
/**
 * from Transantion defined in  @ckb-lumos/base/lib/api.d.ts
 * ```
 * export interface Transaction {
 *  cellDeps: CellDep[];
 *  hash?: Hash;
 *  headerDeps: Hash[];
 *  inputs: Input[];
 *  outputs: Output[];
 *  outputsData: HexString[];
 *  version: HexNumber;
 *  witnesses: HexString[];
 *}
 * to :
 * interface TransactionCodecType {
 *   raw: {
 *     version: Uint32LE;
 *     cellDeps: DeCellDepVec;
 *     headerDeps: Byte32Vec;
 *     inputs: CellInputVec;
 *     outputs: CellOutputVec;
 *     outputsData: BytesVec;
 *   };
 *   witnesses: BytesVec;
 * }
 * ```
 * @param data Transantion defined in @ckb-lumos/base/lib/api.d.ts
 * @returns TransactionCodecType
 */
function transformTransactionCodecType(data) {
  return {
    raw: {
      version: data.version,
      cellDeps: data.cellDeps,
      headerDeps: data.headerDeps,
      inputs: data.inputs,
      outputs: data.outputs,
      outputsData: data.outputsData
    },
    witnesses: data.witnesses
  };
}
function deTransformTransactionCodecType(data) {
  return {
    cellDeps: data.raw.cellDeps.map(cellDep => {
      return {
        outPoint: {
          txHash: cellDep.outPoint.txHash,
          index: cellDep.outPoint.index
        },
        depType: cellDep.depType
      };
    }),
    headerDeps: data.raw.headerDeps,
    inputs: data.raw.inputs.map(input => {
      return {
        previousOutput: {
          txHash: input.previousOutput.txHash,
          index: input.previousOutput.index
        },
        since: input.since
      };
    }),
    outputs: data.raw.outputs.map(output => {
      return {
        capacity: output.capacity,
        lock: output.lock,
        type: output.type
      };
    }),
    outputsData: data.raw.outputsData,
    version: data.raw.version,
    witnesses: data.witnesses
  };
}
function transformHeaderCodecType(data) {
  return {
    raw: {
      timestamp: data.timestamp,
      number: data.number,
      epoch: data.epoch,
      compactTarget: Number(data.compactTarget),
      dao: data.dao,
      parentHash: data.parentHash,
      proposalsHash: data.proposalsHash,
      transactionsRoot: data.transactionsRoot,
      extraHash: data.extraHash,
      version: data.version
    },
    nonce: data.nonce
  };
}
function deTransformHeaderCodecType(data) {
  return {
    timestamp: data.raw.timestamp,
    number: data.raw.number,
    epoch: data.raw.epoch,
    compactTarget: data.raw.compactTarget,
    dao: data.raw.dao,
    parentHash: data.raw.parentHash,
    proposalsHash: data.raw.proposalsHash,
    transactionsRoot: data.raw.transactionsRoot,
    extraHash: data.raw.extraHash,
    version: data.raw.version,
    nonce: data.nonce,
    hash: ""
  };
}
//# sourceMappingURL=blockchain.js.map