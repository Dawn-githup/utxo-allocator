"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CKBHasher = void 0;
exports.assertHexString = assertHexString;
exports.assertHexadecimal = assertHexadecimal;
exports.ckbHash = ckbHash;
exports.ckbHash160 = ckbHash160;
exports.computeScriptHash = computeScriptHash;
exports.deepCamel = deepCamel;
exports.deepCamelizeTransaction = deepCamelizeTransaction;
exports.generateTypeIdScript = generateTypeIdScript;
exports.hashCode = hashCode;
exports.isDeepEqual = isDeepEqual;
exports.readBigUInt128LE = readBigUInt128LE;
exports.readBigUInt128LECompatible = readBigUInt128LECompatible;
exports.readBigUInt64LE = readBigUInt64LE;
exports.readBigUInt64LECompatible = readBigUInt64LECompatible;
exports.toBigUInt128LE = toBigUInt128LE;
exports.toBigUInt128LECompatible = toBigUInt128LECompatible;
exports.toBigUInt64LE = toBigUInt64LE;
exports.toBigUInt64LECompatible = toBigUInt64LECompatible;
var _blake2b = _interopRequireDefault(require("blake2b"));
var _lodash = _interopRequireDefault(require("lodash.isequal"));
var _jsXxhash = require("js-xxhash");
var _codec = require("@ckb-lumos/codec");
var blockchain = _interopRequireWildcard(require("./blockchain"));
var _number = require("@ckb-lumos/codec/lib/number");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const {
  bytify,
  hexify,
  bytifyRawString
} = _codec.bytes;
class CKBHasher {
  constructor(options = {}) {
    const {
      outLength = 32
    } = options;
    this.outLength = outLength;
    this.hasher = (0, _blake2b.default)(outLength, undefined, undefined, bytifyRawString("ckb-default-hash"));
  }
  update(data) {
    this.hasher.update(bytify(data));
    return this;
  }
  digestHex() {
    const out = new Uint8Array(this.outLength);
    this.hasher.digest(out);
    return hexify(out.buffer);
  }
}

/**
 * create a 32-bytes Blake2b hash with the CKB personalization
 * @param data
 */
exports.CKBHasher = CKBHasher;
function ckbHash(data) {
  const hasher = new CKBHasher();
  hasher.update(_codec.bytes.bytify(data));
  return hasher.digestHex();
}

/**
 * create a 20-bytes Blake2b hash with the CKB personalization
 * @param data
 */
function ckbHash160(data) {
  // 2 for prefix 0x
  // 40 for 20-bytes hex string
  const hash160HexLength = 42;
  return ckbHash(data).slice(0, hash160HexLength);
}

/**
 * compute lock/type hash
 *
 * @param script
 */
function computeScriptHash(script) {
  return ckbHash(blockchain.Script.pack(script));
}
function hashCode(buffer) {
  return (0, _jsXxhash.xxHash32)(buffer, 0);
}

/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert bigint to BigUInt64 little-endian hex string
 * @param num
 */
function toBigUInt64LE(num) {
  return toBigUInt64LECompatible(num);
}
function toBigUInt64LECompatible(num) {
  return _codec.bytes.hexify(_number.Uint64LE.pack(num));
}

/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert BigUInt64 little-endian hex string to bigint
 *
 * @param hex BigUInt64 little-endian hex string
 */
function readBigUInt64LE(hex) {
  return readBigUInt64LECompatible(hex).toBigInt();
}

/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 */
function readBigUInt64LECompatible(hex) {
  return _number.Uint64LE.unpack(hex);
}

// const U128_MIN = BigInt(0);
// const U128_MAX = BigInt("340282366920938463463374607431768211455");
/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert bigint to BigUInt128 little-endian hex string
 *
 * @param u128
 */
function toBigUInt128LE(u128) {
  return toBigUInt128LECompatible(u128);
}
function toBigUInt128LECompatible(num) {
  return _codec.bytes.hexify(_number.Uint128LE.pack(num));
}

/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 * convert BigUInt64 little-endian hex string to bigint
 *
 * @param leHex BigUInt128 little-endian hex string
 */
function readBigUInt128LE(leHex) {
  return readBigUInt128LECompatible(leHex).toBigInt();
}

/**
 * @deprecated please follow the {@link https://lumos-website.vercel.app/migrations/migrate-to-v0.19 migration-guide}
 */
function readBigUInt128LECompatible(leHex) {
  return _number.Uint128LE.unpack(leHex);
}
function assertHexString(debugPath, str) {
  if (!/^0x([0-9a-fA-F][0-9a-fA-F])*$/.test(str)) {
    throw new Error(`${debugPath} must be a hex string!`);
  }
}
function assertHexadecimal(debugPath, str) {
  if (!/^0x(0|[0-9a-fA-F]+)$/.test(str)) {
    throw new Error(`${debugPath} must be a hexadecimal!`);
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function isDeepEqual(a, b) {
  return (0, _lodash.default)(a, b);
}
// Buffer.from('TYPE_ID')
const TYPE_ID_CODE_HASH = "0x00000000000000000000000000000000000000000000000000545950455f4944";
function generateTypeIdArgs(input, outputIndex) {
  const outPointBuf = blockchain.CellInput.pack(input);
  const outputIndexBuf = _codec.bytes.hexify(_codec.number.Uint64LE.pack(outputIndex));
  const ckbHasher = new CKBHasher();
  ckbHasher.update(outPointBuf);
  ckbHasher.update(outputIndexBuf);
  return ckbHasher.digestHex();
}

/**
 * Generate a type script for type id {@link https://xuejie.space/2020_02_03_introduction_to_ckb_script_programming_type_id/}
 * @param input
 * @param outputIndex
 */
function generateTypeIdScript(input, outputIndex = "0x0") {
  blockchain.CellInput.pack(input);
  assertHexadecimal("outputIndex", outputIndex);
  const args = generateTypeIdArgs(input, outputIndex);
  return {
    codeHash: TYPE_ID_CODE_HASH,
    hashType: "type",
    args
  };
}
function toCamel(s) {
  return s.replace(/([-_][a-z])/gi, $1 => {
    return $1.toUpperCase().replace("-", "").replace("_", "");
  });
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function deepCamel(data) {
  if (Object.prototype.toString.call(data) === "[object Array]") {
    if (data.length === 0) {
      return data;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return data.map(item => deepCamel(item));
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result = {};
  if (Object.prototype.toString.call(data) === "[object Object]") {
    for (const key in data) {
      const value = data[key];
      if (Object.prototype.toString.call(value) === "[object Object]" || Object.prototype.toString.call(value) === "[object Array]") {
        result[toCamel(key)] = deepCamel(value);
      } else {
        result[toCamel(key)] = value;
      }
    }
    return result;
  }
  return data;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function deepCamelizeDepGroup(data) {
  if (Object.prototype.toString.call(data) === "[object Array]") {
    if (data.length === 0) {
      return data;
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return data.map(item => deepCamelizeDepGroup(item));
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result = {};
  if (Object.prototype.toString.call(data) === "[object Object]") {
    for (const key in data) {
      const value = data[key];
      if (Object.prototype.toString.call(value) === "[object Object]" || Object.prototype.toString.call(value) === "[object Array]") {
        result[key] = deepCamelizeDepGroup(value);
      } else {
        result[key] = value === "dep_group" ? "depGroup" : value;
      }
    }
    return result;
  }
  return data;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function deepCamelizeTransaction(data) {
  return deepCamelizeDepGroup(deepCamel(data));
}
//# sourceMappingURL=utils.js.map