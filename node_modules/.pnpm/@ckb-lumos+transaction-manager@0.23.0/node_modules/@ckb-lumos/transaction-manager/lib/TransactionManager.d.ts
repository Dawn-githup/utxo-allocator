import { Transaction, CellCollector } from "@ckb-lumos/base";
import { Promisable, Store } from "./store";
import type { CKBIndexerQueryOptions } from "@ckb-lumos/ckb-indexer/lib/type";
interface TransactionManagerType {
    sendTransaction(tx: Transaction): Promisable<string>;
    collector(queryOptions: CKBIndexerQueryOptions, options?: {
        usePendingOutputs?: boolean;
    }): CellCollector;
    clearCache(): Promisable<void>;
}
interface TransactionSender {
    sendTransaction(tx: Transaction): Promisable<string>;
}
interface LumosCellIndexer {
    collector(options: CKBIndexerQueryOptions): CellCollector;
}
/**
 * `TransactionManager` offer a simple way to query and cache the pending transactions,
 * it means you can get the pending cells without waiting for the transaction to be confirmed.
 */
export declare class TransactionManager implements TransactionManagerType {
    private transactionSender;
    private cellCollectorProvider;
    private txStorage;
    constructor(payload: {
        transactionSender: TransactionSender;
        indexer: LumosCellIndexer;
        storage?: Store;
    });
    clearCache(): Promise<void>;
    sendTransaction(tx: Transaction): Promise<string>;
    /**
     * Similar to `ckbIndexer.collector`, but it will return the pending cells as well.
     * You can use `usePendingOutputs` to control whether to return the pending cells.
     * @param queryOptions
     * @param options
     */
    collector(queryOptions: CKBIndexerQueryOptions, options?: {
        /**
         * @default true
         */
        usePendingOutputs?: boolean;
    }): CellCollector;
}
export {};
//# sourceMappingURL=TransactionManager.d.ts.map