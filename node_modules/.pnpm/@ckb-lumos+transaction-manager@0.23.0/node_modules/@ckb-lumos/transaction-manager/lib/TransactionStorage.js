"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionStorage = void 0;
exports.createInMemoryPendingTransactionStorage = createInMemoryPendingTransactionStorage;
var _store = require("./store");
/**
 * @internal
 */
class TransactionStorage {
  constructor(storage) {
    this.storage = storage;
  }
  async getTransactions() {
    return (await this.storage.getItem("transactions")) || [];
  }
  async setTransactions(transactions) {
    await this.storage.setItem("transactions", transactions);
    await this.updatePendingCells();
  }
  async addTransaction(tx) {
    const transactions = await this.getTransactions();
    await this.storage.setItem("transactions", transactions.concat(tx));
    await this.updatePendingCells();
  }
  async deleteTransactionByHash(txHash) {
    const transactions = await this.getTransactions();
    const exists = transactions.some(tx => tx.hash === txHash);
    if (!exists) return false;
    await this.storage.setItem("transactions", transactions.filter(tx => tx.hash !== txHash));
    await this.updatePendingCells();
    return true;
  }
  async deleteTransactionByCell(cell) {
    if (!cell.outPoint) return false;
    const txHash = cell.outPoint.txHash;
    return await this.deleteTransactionByHash(txHash);
  }
  async getPendingCells() {
    return (await this.storage.getItem("pendingCells")) || [];
  }
  async getSpentCellOutpoints() {
    return (await this.storage.getItem("spentCellOutpoints")) || [];
  }
  async updatePendingCells() {
    const transactions = await this.getTransactions();
    const spentCellOutpoints = transactions.map(tx => tx.inputs.map(input => input.previousOutput)).flat();
    const pendingCells = transactions.map(tx => tx.outputs.map((output, index) => ({
      outPoint: {
        txHash: tx.hash,
        index: "0x" + index.toString(16)
      },
      cellOutput: output,
      data: tx.outputsData[index]
    }))).flat();
    await this.storage.setItem("spentCellOutpoints", spentCellOutpoints);
    await this.storage.setItem("pendingCells", pendingCells);
  }
}
exports.TransactionStorage = TransactionStorage;
function createInMemoryPendingTransactionStorage() {
  return new TransactionStorage((0, _store.createInMemoryStorage)());
}
//# sourceMappingURL=TransactionStorage.js.map