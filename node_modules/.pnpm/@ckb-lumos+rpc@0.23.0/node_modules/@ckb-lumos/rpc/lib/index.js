"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResultFormatter = exports.RPC = exports.ParamsFormatter = exports.DEFAULT_RPC_TIMEOUT = exports.CKBRPC = void 0;
var _Base = require("./Base");
var _method = require("./method");
var _paramsFormatter = require("./paramsFormatter");
var resultFormatter = _interopRequireWildcard(require("./resultFormatter"));
var _exceptions = require("./exceptions");
var _crossFetch = _interopRequireDefault(require("cross-fetch"));
var _abortController = _interopRequireDefault(require("abort-controller"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const ParamsFormatter = exports.ParamsFormatter = _paramsFormatter.formatter;
const ResultFormatter = exports.ResultFormatter = resultFormatter;
const DEFAULT_RPC_TIMEOUT = exports.DEFAULT_RPC_TIMEOUT = 30000;
class CKBRPC extends _Base.Base {
  #config;
  #node = {
    url: ""
  };
  get node() {
    return this.#node;
  }
  #paramsFormatter = _paramsFormatter.formatter;
  get paramsFormatter() {
    return this.#paramsFormatter;
  }
  #resultFormatter = resultFormatter;
  get resultFormatter() {
    return this.#resultFormatter;
  }
  constructor(url, config = {}) {
    super();
    this.setNode({
      url
    });
    const {
      timeout = DEFAULT_RPC_TIMEOUT,
      fetch = _crossFetch.default
    } = config;
    this.#config = {
      timeout,
      fetch
    };
    Object.defineProperties(this, {
      addMethod: {
        value: this.addMethod,
        enumerable: false,
        writable: false,
        configurable: false
      },
      setNode: {
        value: this.setNode,
        enumerable: false,
        writable: false,
        configurable: false
      }
      // createBatchRequest: { value: this.createBatchRequest, enumerable: false, writable: false, configurable: false },
    });
    Object.keys(this.rpcProperties).forEach(name => {
      this.addMethod({
        name,
        ...this.rpcProperties[name]
      }, this.#config);
    });
  }
  setNode(node) {
    Object.assign(this.node, node);
    return this.node;
  }
  addMethod = (options, config) => {
    const method = new _method.Method(this.node, options, config);
    Object.defineProperty(this, options.name, {
      value: method.call,
      enumerable: true
    });
  };
  /* eslint-disable */
  createBatchRequest = (params = []) => {
    const ctx = this;
    const proxied = new Proxy([], {
      set(...p) {
        const methods = Object.keys(ctx);
        if (p[1] !== "length") {
          var _p$;
          const name = p === null || p === void 0 || (_p$ = p[2]) === null || _p$ === void 0 ? void 0 : _p$[0];
          if (methods.indexOf(name) === -1) {
            throw new _exceptions.MethodInBatchNotFoundException(name);
          }
        }
        return Reflect.set(...p);
      }
    });
    Object.defineProperties(proxied, {
      add: {
        value(...args) {
          this.push(args);
          return this;
        }
      },
      remove: {
        value(i) {
          this.splice(i, 1);
          return this;
        }
      },
      exec: {
        async value() {
          const payload = proxied.map(([f, ...p], i) => {
            try {
              const method = new _method.Method(ctx.node, {
                ...ctx.rpcProperties[f],
                name: f
              });
              return method.getPayload(...p);
            } catch (err) {
              throw new _exceptions.PayloadInBatchException(i, err.message);
            }
          });
          const controller = new _abortController.default();
          const signal = controller.signal;
          const timeout = setTimeout(() => controller.abort(), ctx.#config.timeout);
          const batchRes = await ctx.#config.fetch(ctx.#node.url, {
            method: "POST",
            headers: {
              "content-type": "application/json"
            },
            body: JSON.stringify(payload),
            signal
          }).then(res => res.json());
          clearTimeout(timeout);
          return batchRes.map((res, i) => {
            var _ctx$rpcProperties$pr, _ctx$rpcProperties$pr2, _ctx$rpcProperties$pr3;
            if (res.id !== payload[i].id) {
              return new _exceptions.IdNotMatchedInBatchException(i, payload[i].id, res.id);
            }
            return (_ctx$rpcProperties$pr = (_ctx$rpcProperties$pr2 = (_ctx$rpcProperties$pr3 = ctx.rpcProperties[proxied[i][0]]).resultFormatters) === null || _ctx$rpcProperties$pr2 === void 0 ? void 0 : _ctx$rpcProperties$pr2.call(_ctx$rpcProperties$pr3, res.result)) !== null && _ctx$rpcProperties$pr !== void 0 ? _ctx$rpcProperties$pr : res.result;
          });
        }
      }
    });
    params.forEach(p => proxied.push(p));
    return proxied;
  };
}
exports.RPC = exports.CKBRPC = CKBRPC;
//# sourceMappingURL=index.js.map