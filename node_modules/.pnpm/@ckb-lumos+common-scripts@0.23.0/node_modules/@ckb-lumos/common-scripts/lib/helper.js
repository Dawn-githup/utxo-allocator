"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECP_SIGNATURE_PLACEHOLDER = void 0;
exports.addCellDep = addCellDep;
exports.default = void 0;
exports.ensureScript = ensureScript;
exports.generateDaoScript = generateDaoScript;
exports.hashWitness = hashWitness;
exports.isAcpAddress = isAcpAddress;
exports.isAcpScript = isAcpScript;
exports.isDaoScript = isDaoScript;
exports.isOmnilockAddress = isOmnilockAddress;
exports.isOmnilockScript = isOmnilockScript;
exports.isSecp256k1Blake160Address = isSecp256k1Blake160Address;
exports.isSecp256k1Blake160MultisigAddress = isSecp256k1Blake160MultisigAddress;
exports.isSecp256k1Blake160MultisigScript = isSecp256k1Blake160MultisigScript;
exports.isSecp256k1Blake160Script = isSecp256k1Blake160Script;
exports.isSudtScript = isSudtScript;
exports.prepareSigningEntries = prepareSigningEntries;
var _immutable = require("immutable");
var _helpers = require("@ckb-lumos/helpers");
var _codec = require("@ckb-lumos/codec");
var _base = require("@ckb-lumos/base");
var _number = require("@ckb-lumos/codec/lib/number");
/* eslint-disable @typescript-eslint/no-non-null-assertion, @typescript-eslint/explicit-module-boundary-types */

const {
  CKBHasher,
  ckbHash
} = _base.utils;
function addCellDep(txSkeleton, newCellDep) {
  const cellDep = txSkeleton.get("cellDeps").find(cellDep => {
    return cellDep.depType === newCellDep.depType && new _base.values.OutPointValue(cellDep.outPoint, {
      validate: false
    }).equals(new _base.values.OutPointValue(newCellDep.outPoint, {
      validate: false
    }));
  });
  if (!cellDep) {
    txSkeleton = txSkeleton.update("cellDeps", cellDeps => {
      return cellDeps.push({
        outPoint: newCellDep.outPoint,
        depType: newCellDep.depType
      });
    });
  }
  return txSkeleton;
}
function generateDaoScript(config) {
  const template = config.SCRIPTS.DAO;
  return {
    codeHash: template.CODE_HASH,
    hashType: template.HASH_TYPE,
    args: "0x"
  };
}
function isSecp256k1Blake160Script(script, config) {
  const template = config.SCRIPTS.SECP256K1_BLAKE160;
  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}
function isSecp256k1Blake160Address(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isSecp256k1Blake160Script(script, config);
}
function isOmnilockScript(script, config) {
  const template = config.SCRIPTS.OMNILOCK;
  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}
function isOmnilockAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isOmnilockScript(script, config);
}
function isSecp256k1Blake160MultisigScript(script, config) {
  const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
  return script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}
function isSecp256k1Blake160MultisigAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isSecp256k1Blake160MultisigScript(script, config);
}
function isDaoScript(script, config) {
  const template = config.SCRIPTS.DAO;
  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}
function isSudtScript(script, config) {
  const template = config.SCRIPTS.SUDT;
  if (!template) {
    throw new Error(`SUDT script not defined in config!`);
  }
  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}
function isAcpScript(script, config) {
  const template = config.SCRIPTS.ANYONE_CAN_PAY;
  if (!template) {
    throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
  }
  return !!script && script.codeHash === template.CODE_HASH && script.hashType === template.HASH_TYPE;
}
function isAcpAddress(address, config) {
  const script = (0, _helpers.parseAddress)(address, {
    config
  });
  return isAcpScript(script, config);
}

/**
 * Hash a witness in a hasher
 * @param hasher The hasher object which should have a `update` method.
 * @param witness witness data, the inputs to hasher will derived from it
 */
function hashWitness(hasher, witness) {
  // https://github.com/nervosnetwork/ckb-system-scripts/blob/a7b7c75662ed950c9bd024e15f83ce702a54996e/c/secp256k1_blake160_sighash_all.c#L81
  const len = _codec.bytes.hexify(_number.Uint64.pack(_codec.bytes.bytify(witness).length));
  // https://github.com/nervosnetwork/ckb-system-scripts/blob/a7b7c75662ed950c9bd024e15f83ce702a54996e/c/secp256k1_blake160_sighash_all.c#L214-L215
  hasher.update(len);
  hasher.update(witness);
}
/* eslint-enable camelcase, @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */

function prepareSigningEntries(txSkeleton, config, scriptType) {
  const template = config.SCRIPTS[scriptType];
  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }
  let processedArgs = (0, _immutable.Set)();
  const tx = (0, _helpers.createTransactionFromSkeleton)(txSkeleton);
  const txHash = ckbHash(_base.blockchain.RawTransaction.pack(tx));
  const inputs = txSkeleton.get("inputs");
  const witnesses = txSkeleton.get("witnesses");
  let signingEntries = txSkeleton.get("signingEntries");
  for (let i = 0; i < inputs.size; i++) {
    const input = inputs.get(i);
    if (template.CODE_HASH === input.cellOutput.lock.codeHash && template.HASH_TYPE === input.cellOutput.lock.hashType && !processedArgs.has(input.cellOutput.lock.args)) {
      processedArgs = processedArgs.add(input.cellOutput.lock.args);
      const lockValue = new _base.values.ScriptValue(input.cellOutput.lock, {
        validate: false
      });
      const hasher = new CKBHasher();
      hasher.update(txHash);
      if (i >= witnesses.size) {
        throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);
      }
      hashWitness(hasher, witnesses.get(i));
      for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
        const otherInput = inputs.get(j);
        if (lockValue.equals(new _base.values.ScriptValue(otherInput.cellOutput.lock, {
          validate: false
        }))) {
          hashWitness(hasher, witnesses.get(j));
        }
      }
      for (let j = inputs.size; j < witnesses.size; j++) {
        hashWitness(hasher, witnesses.get(j));
      }
      const signingEntry = {
        type: "witness_args_lock",
        index: i,
        message: hasher.digestHex()
      };
      signingEntries = signingEntries.push(signingEntry);
    }
  }
  txSkeleton = txSkeleton.set("signingEntries", signingEntries);
  return txSkeleton;
}
function ensureScript(script, config, scriptType) {
  const template = config.SCRIPTS[scriptType];
  if (!template) {
    throw new Error(`Provided config does not have ${scriptType} script setup!`);
  }
  if (template.CODE_HASH !== script.codeHash || template.HASH_TYPE !== script.hashType) {
    throw new Error(`Provided script is not ${scriptType} script!`);
  }
}

/* 65-byte zeros in hex */
const SECP_SIGNATURE_PLACEHOLDER = exports.SECP_SIGNATURE_PLACEHOLDER = "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
var _default = exports.default = {
  addCellDep,
  generateDaoScript,
  isSecp256k1Blake160Script,
  isSecp256k1Blake160MultisigScript,
  isDaoScript,
  isSudtScript,
  prepareSigningEntries,
  isSecp256k1Blake160Address,
  isSecp256k1Blake160MultisigAddress,
  ensureScript,
  isAcpScript,
  isAcpAddress
};
//# sourceMappingURL=helper.js.map