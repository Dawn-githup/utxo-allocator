"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bitcoin = exports.OmnilockWitnessLock = exports.CellCollector = void 0;
exports.createOmnilockScript = createOmnilockScript;
exports.default = void 0;
exports.prepareSigningEntries = prepareSigningEntries;
exports.setupInputCell = setupInputCell;
exports.solana = void 0;
var _codec = require("@ckb-lumos/codec");
var _base = require("@ckb-lumos/base");
var _configManager = require("@ckb-lumos/config-manager");
var _helper = require("./helper");
var _from_info = require("./from_info");
var _molecule = require("@ckb-lumos/codec/lib/molecule");
var _blockchain = require("@ckb-lumos/codec/lib/blockchain");
var _bytes = require("@ckb-lumos/codec/lib/bytes");
var bitcoin = _interopRequireWildcard(require("./omnilock-bitcoin"));
exports.bitcoin = bitcoin;
var solana = _interopRequireWildcard(require("./omnilock-solana"));
exports.solana = solana;
var _bs = require("bs58");
var _utils = require("@ckb-lumos/base/lib/utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const {
  ScriptValue
} = _base.values;
// https://github.com/XuJiandong/omnilock/blob/4e9fdb6ca78637651c8145bb7c5b82b4591332fb/c/ckb_identity.h#L62-L76
var IdentityFlagsType = /*#__PURE__*/function (IdentityFlagsType) {
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsCkb"] = 0] = "IdentityFlagsCkb";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsEthereum"] = 1] = "IdentityFlagsEthereum";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsEos"] = 2] = "IdentityFlagsEos";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsTron"] = 3] = "IdentityFlagsTron";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsBitcoin"] = 4] = "IdentityFlagsBitcoin";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsDogecoin"] = 5] = "IdentityFlagsDogecoin";
  IdentityFlagsType[IdentityFlagsType["IdentityCkbMultisig"] = 6] = "IdentityCkbMultisig";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsEthereumDisplaying"] = 18] = "IdentityFlagsEthereumDisplaying";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsSolana"] = 19] = "IdentityFlagsSolana";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsOwnerLock"] = 252] = "IdentityFlagsOwnerLock";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsExec"] = 253] = "IdentityFlagsExec";
  IdentityFlagsType[IdentityFlagsType["IdentityFlagsDl"] = 254] = "IdentityFlagsDl";
  return IdentityFlagsType;
}(IdentityFlagsType || {}); // https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#authentication
const OMNILOCK_AUTH_CONTENT_LENGTH = 20;
const SECP256K1_SIGNATURE_PLACEHOLDER_LENGTH = 65;

//  https://datatracker.ietf.org/doc/html/rfc8032#section-7.1
// 64 bytes for ED25519 signature
// 32 bytes for Ed25519 pubkey public key
const ED25519_SIGNATURE_PLACEHOLDER_LENGTH = 96;

/**
 * only support ETHEREUM and SECP256K1_BLAKE160 mode currently
 * refer to: @link https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md omnilock
 * @param omnilockInfo
 * @param options
 * @returns
 * @example
 * // create an omnilock to work with MetaMask wallet
 * createOmnilockScript({
 *   auth: {
 *     flag: "ETHEREUM",
 *     content: "an ethereum address here",
 *   }, { config })
 * // or we can create an omnilock to work with UniSat wallet
 * createOmnilockScript({
 *   auth: {
 *     flag: "BITCOIN",
 *     content: "a bitcoin address here",
 *   }
 * }, {config})
 */
function createOmnilockScript(omnilockInfo, options) {
  const config = (options === null || options === void 0 ? void 0 : options.config) || (0, _configManager.getConfig)();
  const omnilockConfig = config.SCRIPTS.OMNILOCK;
  if (!omnilockConfig) {
    throw new Error("OMNILOCK script config not found.");
  }

  // TODO The advanced feature will be supported in the future.
  // https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md
  /**
   * |Name                 |Flags     |Affected Args              |Affected Args Size (byte)|Affected Witness|
   * |---------------------|----------|---------------------------|-------------------------|----------------|
   * |administrator mode   |0b00000001|AdminList cell Type ID     |32                       |omni_identity/signature in OmniLockWitnessLock|
   * |anyone-can-pay mode  |0b00000010|minimum ckb/udt in ACP     |2                        |N/A             |
   * |time-lock mode       |0b00000100|since for timelock         |8                        |N/A             |
   * |supply mode          |0b00001000|type script hash for supply|32                       |N/A             |
   */
  const defaultOmnilockArgs = 0b00000000;
  const omnilockArgs = [defaultOmnilockArgs];
  const args = (() => {
    const flag = omnilockInfo.auth.flag;
    switch (flag) {
      case "ETHEREUM":
        return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsEthereum], omnilockInfo.auth.content, omnilockArgs));
      case "SECP256K1_BLAKE160":
        return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsCkb], omnilockInfo.auth.content, omnilockArgs));
      case "BITCOIN":
        return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsBitcoin], bitcoin.decodeAddress(omnilockInfo.auth.content), omnilockArgs));
      case "SOLANA":
        {
          const authContent = _codec.bytes.bytify((0, _utils.ckbHash)((0, _bs.decode)(omnilockInfo.auth.content))).slice(0, OMNILOCK_AUTH_CONTENT_LENGTH);
          return _codec.bytes.hexify(_codec.bytes.concat([IdentityFlagsType.IdentityFlagsSolana], authContent, omnilockArgs));
        }
      default:
        throw new Error(`Not supported flag: ${flag}.`);
    }
  })();
  return {
    codeHash: omnilockConfig.CODE_HASH,
    hashType: omnilockConfig.HASH_TYPE,
    args
  };
}
const Hexify = {
  pack: _bytes.bytify,
  unpack: _bytes.hexify
};

// https://github.com/cryptape/omnilock/blob/cd764d7133ec4e6b192fac4b93fc0596ef5b71f6/c/omni_lock.mol#L3
// array Auth[byte; 21];
const IDENTITY_LENGTH = 21;
const Auth = (0, _blockchain.createFixedHexBytesCodec)(IDENTITY_LENGTH);
const SmtProof = (0, _molecule.byteVecOf)(Hexify);
const SmtProofEntry = (0, _molecule.table)({
  mask: (0, _molecule.byteOf)(Hexify),
  proof: SmtProof
}, ["mask", "proof"]);
const SmtProofEntryVec = (0, _molecule.vector)(SmtProofEntry);
const OmniIdentity = (0, _molecule.table)({
  identity: Auth,
  proofs: SmtProofEntryVec
}, ["identity", "proofs"]);
const OmniIdentityOpt = (0, _molecule.option)(OmniIdentity);
const OmnilockWitnessLock = exports.OmnilockWitnessLock = (0, _molecule.table)({
  signature: _blockchain.BytesOpt,
  omni_identity: OmniIdentityOpt,
  preimage: _blockchain.BytesOpt
}, ["signature", "omni_identity", "preimage"]);
const CellCollector = exports.CellCollector = class CellCollector {
  constructor(fromInfo, cellProvider, {
    config = undefined,
    queryOptions = {}
  } = {}) {
    if (!cellProvider) {
      throw new Error(`Cell provider is missing!`);
    }
    config = config || (0, _configManager.getConfig)();
    this.fromScript = (0, _from_info.parseFromInfo)(fromInfo, {
      config
    }).fromScript;
    this.config = config;
    queryOptions = {
      ...queryOptions,
      lock: this.fromScript,
      type: queryOptions.type || "empty"
    };
    this.cellCollector = cellProvider.collector(queryOptions);
  }
  async *collect() {
    if (!(0, _helper.isOmnilockScript)(this.fromScript, this.config)) {
      return;
    }
    for await (const inputCell of this.cellCollector.collect()) {
      yield inputCell;
    }
  }
};

/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param _fromInfo
 * @param options
 */
async function setupInputCell(txSkeleton, inputCell, _fromInfo, {
  config = undefined,
  defaultWitness = "0x",
  since = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  const fromScript = inputCell.cellOutput.lock;
  if (!(0, _helper.isOmnilockScript)(fromScript, config)) {
    throw new Error(`Not OMNILOCK input!`);
  }

  // add inputCell to txSkeleton
  txSkeleton = txSkeleton.update("inputs", inputs => {
    return inputs.push(inputCell);
  });
  const output = {
    cellOutput: {
      capacity: inputCell.cellOutput.capacity,
      lock: inputCell.cellOutput.lock,
      type: inputCell.cellOutput.type
    },
    data: inputCell.data
  };
  txSkeleton = txSkeleton.update("outputs", outputs => {
    return outputs.push(output);
  });
  if (since) {
    txSkeleton = txSkeleton.update("inputSinces", inputSinces => {
      return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
    });
  }
  txSkeleton = txSkeleton.update("witnesses", witnesses => {
    return witnesses.push(defaultWitness);
  });
  const template = config.SCRIPTS.OMNILOCK;
  const secp256k1Template = config.SCRIPTS.SECP256K1_BLAKE160;
  if (!template) {
    throw new Error(`OMNILOCK script not defined in config!`);
  }
  if (!secp256k1Template) {
    throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);
  }
  const omnilockOutPoint = {
    txHash: template.TX_HASH,
    index: template.INDEX
  };
  const secp256k1OutPoint = {
    txHash: secp256k1Template.TX_HASH,
    index: secp256k1Template.INDEX
  };

  // add cell dep
  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    outPoint: omnilockOutPoint,
    depType: template.DEP_TYPE
  });
  txSkeleton = (0, _helper.addCellDep)(txSkeleton, {
    outPoint: secp256k1OutPoint,
    depType: secp256k1Template.DEP_TYPE
  });

  // add witness
  /*
   * Modify the skeleton, so the first witness of the fromAddress script group
   * has a WitnessArgs construct with 85-byte zero filled values. While this
   * is not required, it helps in transaction fee estimation.
   */
  const firstIndex = txSkeleton.get("inputs").findIndex(input => new ScriptValue(input.cellOutput.lock, {
    validate: false
  }).equals(new ScriptValue(fromScript, {
    validate: false
  })));
  if (firstIndex !== -1) {
    while (firstIndex >= txSkeleton.get("witnesses").size) {
      txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.push("0x"));
    }
    let witness = txSkeleton.get("witnesses").get(firstIndex);
    const placeholderLength = (() => {
      const identityFlag = _codec.bytes.bytify(inputCell.cellOutput.lock.args)[0];
      switch (identityFlag) {
        case IdentityFlagsType.IdentityFlagsSolana:
          {
            return ED25519_SIGNATURE_PLACEHOLDER_LENGTH;
          }
        case IdentityFlagsType.IdentityFlagsCkb:
        case IdentityFlagsType.IdentityFlagsEthereum:
        case IdentityFlagsType.IdentityFlagsBitcoin:
          {
            return SECP256K1_SIGNATURE_PLACEHOLDER_LENGTH;
          }
        default:
          {
            throw new Error(`Unsupported flag: ${identityFlag}, please check if the script.args is expected`);
          }
      }
    })();
    const newWitnessArgs = {
      lock: createWitnessLockPlaceholder(placeholderLength)
    };
    witness = _codec.bytes.hexify(_base.blockchain.WitnessArgs.pack(newWitnessArgs));
    txSkeleton = txSkeleton.update("witnesses", witnesses => witnesses.set(firstIndex, witness));
  }
  return txSkeleton;
}
function createWitnessLockPlaceholder(signatureLength) {
  const serializedLength = OmnilockWitnessLock.pack({
    signature: new Uint8Array(signatureLength)
  }).byteLength;
  return _codec.bytes.hexify(new Uint8Array(serializedLength));
}

/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */
function prepareSigningEntries(txSkeleton, {
  config = undefined
} = {}) {
  config = config || (0, _configManager.getConfig)();
  return (0, _helper.prepareSigningEntries)(txSkeleton, config, "OMNILOCK");
}
var _default = exports.default = {
  prepareSigningEntries,
  setupInputCell,
  CellCollector,
  OmnilockWitnessLock,
  createOmnilockScript
};
//# sourceMappingURL=omnilock.js.map