{"version":3,"file":"refresh.js","names":["createRpcResolver","rpc","fetchTxs","txHashes","txs","createBatchRequest","map","txHash","exec","zipWith","tx","transaction","Error","fetchIndexerCells","scripts","res","script","scriptType","scriptSearchMode","withData","item","objects","createLatestTypeIdResolver","fetchOutputs","fetchTypeScriptCell","oldOutPoints","outPoint","typeScripts","nonNullable","index","outputs","Number","type","cells","filter","Boolean","oldOutPoint","typeScript","cell","splice","refreshScriptConfigs","scriptConfigs","resolve","skip","configs","Object","entries","name","scriptConfig","includes","HASH_TYPE","_","TX_HASH","INDEX","newOutPoints","newScriptConfigs","fromEntries","target","newOutPoint","original","assign","left","right","cb","i","value","message"],"sources":["../src/refresh.ts"],"sourcesContent":["import type { Hash, OutPoint, Output, Script } from \"@ckb-lumos/base\";\nimport type { ScriptConfig, ScriptConfigs } from \"./types\";\nimport type { CKBComponents } from \"@ckb-lumos/rpc/lib/types/api\";\n\ntype MaybePromise<T> = T | PromiseLike<T>;\n\n// prettier-ignore\n/**\n * resolve the latest `OutPoint[]` that has consumed the old `OutPoint[]`\n */\nexport type ResolveLatestOutPointsOfTypeIds = (outPoints: OutPoint[]) => MaybePromise<OutPoint[]>;\n// prettier-ignore\nexport type FetchOutputsByTxHashes = (txHashes: string[]) => MaybePromise<{ outputs: Output[] }[]>;\n// prettier-ignore\n/**\n * fetch cells with corresponding type script\n */\nexport type FetchOutPointsByTypeIds = (scripts: Script[]) => MaybePromise<{ outPoint: OutPoint }[]>;\n\n// prettier-ignore\n/**\n * the minimal batch RPC client\n */\nexport type BatchRequest = {\n  createBatchRequest<Params, Result>(params: Params[]): { exec(): Promise<Result[]> };\n};\n\nexport function createRpcResolver(\n  rpc: BatchRequest\n): ResolveLatestOutPointsOfTypeIds {\n  const fetchTxs: FetchOutputsByTxHashes = async (txHashes) => {\n    const txs = await rpc\n      .createBatchRequest<\n        [\"getTransaction\", Hash],\n        CKBComponents.TransactionWithStatus\n      >(txHashes.map((txHash) => [\"getTransaction\", txHash]))\n      .exec();\n\n    return zipWith(txHashes, txs, (txHash, tx) => {\n      if (!tx?.transaction) {\n        throw new Error(`Cannot find transaction ${txHash}`);\n      }\n      return tx.transaction;\n    });\n  };\n\n  const fetchIndexerCells: FetchOutPointsByTypeIds = async (scripts) => {\n    const res = await rpc\n      .createBatchRequest<unknown[], CKBComponents.GetLiveCellsResult<false>>(\n        scripts.map((script) => [\n          \"getCells\",\n          {\n            script,\n            scriptType: \"type\",\n            scriptSearchMode: \"exact\",\n            withData: false,\n          } satisfies CKBComponents.GetCellsSearchKey<false>,\n          \"asc\" satisfies CKBComponents.Order,\n          \"0x1\" satisfies CKBComponents.UInt64,\n        ])\n      )\n      .exec();\n\n    return res.map((item) => item.objects[0]);\n  };\n\n  return createLatestTypeIdResolver(fetchTxs, fetchIndexerCells);\n}\n\nexport function createLatestTypeIdResolver(\n  fetchOutputs: FetchOutputsByTxHashes,\n  fetchTypeScriptCell: FetchOutPointsByTypeIds\n): ResolveLatestOutPointsOfTypeIds {\n  return async (oldOutPoints) => {\n    const txs = await fetchOutputs(\n      oldOutPoints.map((outPoint) => outPoint.txHash)\n    );\n\n    const typeScripts = zipWith(oldOutPoints, txs, (outPoint, tx) => {\n      nonNullable(outPoint);\n      nonNullable(\n        tx,\n        `Cannot find the OutPoint ${outPoint.txHash}#${outPoint.index}`\n      );\n\n      return tx.outputs[Number(outPoint.index)].type;\n    });\n\n    // contracts may be dependent on `depGroup`, and the `depGroup` cell may not have a type script,\n    // so we need to filter out the cells without type script\n    const cells = await fetchTypeScriptCell(\n      typeScripts.filter(Boolean) as Script[]\n    );\n\n    return zipWith(oldOutPoints, typeScripts, (oldOutPoint, typeScript) => {\n      nonNullable(oldOutPoint);\n      if (!typeScript) {\n        return oldOutPoint;\n      }\n\n      const [cell] = cells.splice(0, 1);\n      return cell.outPoint;\n    });\n  };\n}\n\ntype RefreshConfig<S> = {\n  resolve: ResolveLatestOutPointsOfTypeIds;\n  skip?: (keyof S)[];\n};\n\n/**\n * Refreshing the config items in {@link ScriptConfigs} which are deployed with type id\n * @example\n * const updatedScriptConfigs = await refreshScriptConfigs(predefined.AGGRON4.SCRIPTS, { resolve: createRpcResolver(rpc) })\n * initializeConfig({ SCRIPTS: updatedScriptConfigs })\n */\nexport async function refreshScriptConfigs<S extends ScriptConfigs>(\n  scriptConfigs: S,\n  {\n    resolve,\n    skip = [\"SECP256K1_BLAKE160\", \"SECP256K1_BLAKE160_MULTISIG\", \"DAO\"],\n  }: RefreshConfig<S>\n): Promise<S> {\n  // prettier-ignore\n  type Filter = (value: [string, ScriptConfig | undefined]) => value is [string, ScriptConfig];\n\n  const configs = Object.entries(scriptConfigs).filter(\n    (([name, scriptConfig]) =>\n      !skip.includes(name) && scriptConfig?.HASH_TYPE === \"type\") as Filter\n  );\n\n  const oldOutPoints: OutPoint[] = configs.map(([_, scriptConfig]) => ({\n    txHash: scriptConfig.TX_HASH,\n    index: scriptConfig.INDEX,\n  }));\n\n  const newOutPoints: OutPoint[] = await resolve(oldOutPoints);\n\n  const newScriptConfigs = Object.fromEntries(\n    zipWith(configs, newOutPoints, (target, newOutPoint) => {\n      nonNullable(target);\n      const [name, original] = target;\n\n      nonNullable(\n        newOutPoint,\n        `Refreshing failed, cannot load config of ${name}, please check whether the scriptConfig is correct`\n      );\n\n      return [\n        name,\n        { ...original, TX_HASH: newOutPoint.txHash, INDEX: newOutPoint.index },\n      ];\n    })\n  );\n\n  return Object.assign({}, scriptConfigs, newScriptConfigs);\n}\n\nfunction zipWith<L, R, O>(\n  left: L[],\n  right: R[],\n  cb: (a: L | undefined, b: R | undefined) => O\n) {\n  return left.map((_, i) => cb(left[i], right[i]));\n}\n\nfunction nonNullable<T>(\n  value: T,\n  message = \"Not nullable\"\n): asserts value is NonNullable<T> {\n  if (value == null) {\n    throw new Error(message);\n  }\n}\n"],"mappings":"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"}