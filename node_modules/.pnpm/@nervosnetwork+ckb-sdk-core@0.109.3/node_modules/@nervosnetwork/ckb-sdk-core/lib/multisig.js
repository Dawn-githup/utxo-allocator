"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMultisigStatus = exports.hashMultisig = exports.serializeMultisigConfig = exports.SignStatus = exports.isMultisigConfig = void 0;
const ckb_sdk_utils_1 = require("@nervosnetwork/ckb-sdk-utils");
function isMultisigConfig(config) {
    return config
        && !Number.isNaN(+config.r)
        && !Number.isNaN(+config.m)
        && !Number.isNaN(+config.n)
        && Array.isArray(config.blake160s);
}
exports.isMultisigConfig = isMultisigConfig;
var SignStatus;
(function (SignStatus) {
    SignStatus["Signed"] = "Signed";
    SignStatus["Unsigned"] = "Unsigned";
    SignStatus["PartiallySigned"] = "PartiallySigned";
})(SignStatus = exports.SignStatus || (exports.SignStatus = {}));
const validateMultisigCount = (v) => {
    if (v < 0 || v > 255) {
        throw new Error('For multisig sign, signer should between 0 and 255');
    }
};
const toHex = (v) => {
    return v.toString(16).padStart(2, '0');
};
const validateMultisigConfig = (config) => {
    validateMultisigCount(config.r);
    validateMultisigCount(config.m);
    validateMultisigCount(config.n);
    if (config.m > config.n)
        throw new Error(`For m of n multisig sign, m shouldn't be greater than n`);
    if (config.r > config.m)
        throw new Error(`For m of n multisig sign, r shouldn't be greater than m`);
    if (config.n !== config.blake160s.length)
        throw new Error(`For m of n multisig sign, signer's length should equal with n`);
};
const serializeMultisigConfig = (config) => {
    validateMultisigConfig(config);
    return `0x00${toHex(config.r)}${toHex(config.m)}${toHex(config.n)}${config.blake160s.reduce((pre, cur) => pre + cur.slice(2), '')}`;
};
exports.serializeMultisigConfig = serializeMultisigConfig;
const hashMultisig = (config) => {
    const blake2bHash = (0, ckb_sdk_utils_1.blake2b)(32, null, null, ckb_sdk_utils_1.PERSONAL);
    blake2bHash.update((0, ckb_sdk_utils_1.hexToBytes)((0, exports.serializeMultisigConfig)(config)));
    return `0x${blake2bHash.digest('hex')}`.slice(0, 42);
};
exports.hashMultisig = hashMultisig;
const getMultisigStatus = (config, signatures = []) => {
    let signedForM = 0;
    let signedForR = 0;
    for (let i = 0; i < config.n; i++) {
        if (signatures.includes(config.blake160s[i])) {
            if (i < config.r) {
                signedForR += 1;
            }
            else {
                signedForM += 1;
            }
        }
    }
    if (signedForM + signedForR === 0) {
        return SignStatus.Unsigned;
    }
    if (signedForM > config.m - config.r) {
        throw new Error('More signature for multisig');
    }
    if (signedForM + signedForR < config.m) {
        return SignStatus.PartiallySigned;
    }
    return SignStatus.Signed;
};
exports.getMultisigStatus = getMultisigStatus;
//# sourceMappingURL=multisig.js.map