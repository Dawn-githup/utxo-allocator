"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeAddress = decodeAddress;
exports.signMessage = signMessage;
var _codec = require("@ckb-lumos/codec");
var _bech = require("bech32");
var _bs = _interopRequireDefault(require("bs58"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// https://github.com/cryptape/omnilock/blob/9419b7795641da0ade25a04127e25d8a0b709077/c/ckb_identity.h#L28
const BTC_PREFIX = "CKB (Bitcoin Layer) transaction: 0x";

/**
 * Decode bitcoin address to public key hash in bytes
 * @see https://en.bitcoin.it/wiki/List_of_address_prefixes
 * @param address
 */
function decodeAddress(address) {
  try {
    // Bech32
    if (address.startsWith("bc1q")) {
      return _bech.bech32.fromWords(_bech.bech32.decode(address).words.slice(1));
    }

    // P2PKH
    if (address.startsWith("1")) {
      return _bs.default.decode(address).slice(1, 21);
    }

    // P2SH
    if (address.startsWith("3")) {
      return _bs.default.decode(address).slice(1, 21);
    }
  } catch {
    // https://bitcoin.design/guide/glossary/address/#taproot-address---p2tr
    if (address.startsWith("bc1p")) {
      throw new Error("Taproot address is not supported yet.");
    }
  }
  throw new Error(`Unsupported bitcoin address ${address}, only 1...(P2PKH) 3...(P2SH), and bc1...(Bech32) are supported.`);
}
async function signMessage(digest, type, provider) {
  const internal = (() => {
    if (provider) return provider;

    /* c8 ignore next 15*/
    if (typeof window !== "undefined") {
      if ("unisat" in window) {
        return window.unisat;
      }
      if ("okxwallet" in window && "bitcoin" in window.okxwallet) {
        return window.okxwallet.bitcoin;
      }
    }
    throw new Error("No provider found, make sure you have installed UniSat Wallet");
  })();
  const accounts = await internal.requestAccounts();
  const digestWithout0x = _codec.bytes.hexify(digest).slice(2);
  const signatureBase64 = await internal.signMessage(`${BTC_PREFIX}${digestWithout0x}`, type);
  const signature = _codec.bytes.bytify(base64ToHex(signatureBase64));
  const address = accounts[0];
  // a secp256k1 private key can be used to sign various types of messages
  // the first byte of signature used as a recovery id to identify the type of message
  // https://github.com/XuJiandong/omnilock/blob/4e9fdb6ca78637651c8145bb7c5b82b4591332fb/c/ckb_identity.h#L249-L266
  if (address.startsWith("bc1q")) {
    signature[0] = 39 + (signature[0] - 27) % 4;
  } else if (address.startsWith("3")) {
    signature[0] = 35 + (signature[0] - 27) % 4;
  } else if (address.startsWith("1")) {
    signature[0] = 31 + (signature[0] - 27) % 4;
  } else {
    throw new Error(`Unsupported bitcoin address ${address}, only 1...(P2PKH) 3...(P2SH), and bc1...(Bech32) are supported.`);
  }
  return _codec.bytes.hexify(signature);
}
function base64ToHex(str) {
  const raw = atob(str);
  let result = "";
  for (let i = 0; i < raw.length; i++) {
    const hex = raw.charCodeAt(i).toString(16);
    result += hex.length === 2 ? hex : "0" + hex;
  }
  return "0x" + result;
}
//# sourceMappingURL=omnilock-bitcoin.js.map