"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionManager = void 0;
var _base = require("@ckb-lumos/base");
var _codec = require("@ckb-lumos/codec");
var _ckbIndexerFilter = require("@ckb-lumos/ckb-indexer/lib/ckbIndexerFilter");
var _TransactionStorage = require("./TransactionStorage");
var _store = require("./store");
/**
 * `TransactionManager` offer a simple way to query and cache the pending transactions,
 * it means you can get the pending cells without waiting for the transaction to be confirmed.
 */
class TransactionManager {
  constructor(payload) {
    this.transactionSender = payload.transactionSender;
    this.cellCollectorProvider = payload.indexer;
    this.txStorage = new _TransactionStorage.TransactionStorage(payload.storage || (0, _store.createInMemoryStorage)());
  }
  async clearCache() {
    await this.txStorage.setTransactions([]);
  }
  async sendTransaction(tx) {
    const txHash = await this.transactionSender.sendTransaction(tx);
    await this.txStorage.addTransaction({
      ...tx,
      hash: txHash
    });
    return txHash;
  }

  /**
   * Similar to `ckbIndexer.collector`, but it will return the pending cells as well.
   * You can use `usePendingOutputs` to control whether to return the pending cells.
   * @param queryOptions
   * @param options
   */
  collector(queryOptions, options) {
    var _options$usePendingOu;
    const optionsWithoutSkip = {
      ...queryOptions,
      skip: 0
    };
    const liveCellCollector = this.cellCollectorProvider.collector(optionsWithoutSkip);
    return new PendingCellCollector({
      txStorage: this.txStorage,
      queryOptions: optionsWithoutSkip,
      usePendingCells: (_options$usePendingOu = options === null || options === void 0 ? void 0 : options.usePendingOutputs) !== null && _options$usePendingOu !== void 0 ? _options$usePendingOu : true,
      liveCellCollector
    });
  }
}
exports.TransactionManager = TransactionManager;
class PendingCellCollector {
  /**
   * @param order - default to asc, return on-chain cells first, then pending cells, and vice versa
   */

  constructor(payload) {
    const {
      queryOptions,
      liveCellCollector,
      txStorage,
      usePendingCells
    } = payload;
    this.order = queryOptions.order === "desc" ? "desc" : "asc";
    this.liveCellCollector = liveCellCollector;
    this.usePendingCells = usePendingCells;
    this.txStorage = txStorage;
    this.queryOptions = queryOptions;
  }
  async removePendingCell(cell) {
    return await this.txStorage.deleteTransactionByCell(cell);
  }
  cellIsSpent(cell, spentCells) {
    return spentCells.some(spent => _codec.bytes.equal(_base.blockchain.OutPoint.pack(spent), _base.blockchain.OutPoint.pack(cell.outPoint)));
  }
  async *collect() {
    const spentCells = await this.txStorage.getSpentCellOutpoints();

    // order is desc, return pending cells first, then on-chain cells
    if (this.order === "desc") {
      if (this.usePendingCells) {
        const pendingCells = await this.txStorage.getPendingCells();
        const filteredPendingCells = (0, _ckbIndexerFilter.filterByLumosQueryOptions)(pendingCells, this.queryOptions);
        for (const cell of filteredPendingCells) {
          if (!this.cellIsSpent(cell, spentCells)) {
            yield cell;
          }
        }
      }
      for await (const cell of this.liveCellCollector.collect()) {
        const isPendingCell = await this.removePendingCell(cell);
        if (!this.cellIsSpent(cell, spentCells) && !isPendingCell) {
          yield cell;
        }
      }
      // orser is asc, return on-chain cells first, then pending cells
    } else {
      for await (const cell of this.liveCellCollector.collect()) {
        await this.removePendingCell(cell);
        if (!this.cellIsSpent(cell, spentCells)) {
          yield cell;
        }
      }
      const pendingCells = await this.txStorage.getPendingCells();
      const filteredPendingCells = (0, _ckbIndexerFilter.filterByLumosQueryOptions)(pendingCells, this.queryOptions);
      if (this.usePendingCells) {
        for (const cell of filteredPendingCells) {
          if (!this.cellIsSpent(cell, spentCells)) {
            yield cell;
          }
        }
      }
    }
  }
}
//# sourceMappingURL=TransactionManager.js.map