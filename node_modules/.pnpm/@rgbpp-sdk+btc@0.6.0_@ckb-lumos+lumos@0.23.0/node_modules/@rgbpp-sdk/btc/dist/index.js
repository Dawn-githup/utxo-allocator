"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AddressType: () => AddressType,
  DataSource: () => DataSource,
  ECPair: () => ECPair,
  ErrorCodes: () => ErrorCodes,
  ErrorMessages: () => ErrorMessages,
  FeeEstimator: () => FeeEstimator,
  NetworkType: () => NetworkType,
  TxBuildError: () => TxBuildError,
  TxBuilder: () => TxBuilder,
  addAddressToPubkeyMap: () => addAddressToPubkeyMap,
  addressToScriptPublicKey: () => addressToScriptPublicKey,
  addressToScriptPublicKeyHex: () => addressToScriptPublicKeyHex,
  bitcoin: () => bitcoin,
  createSendBtcBuilder: () => createSendBtcBuilder,
  createSendRbfBuilder: () => createSendRbfBuilder,
  createSendRgbppUtxosBuilder: () => createSendRgbppUtxosBuilder,
  createSendUtxosBuilder: () => createSendUtxosBuilder,
  dataToOpReturnScriptPubkey: () => dataToOpReturnScriptPubkey,
  decodeAddress: () => decodeAddress,
  decodeUtxoId: () => decodeUtxoId,
  ecc: () => import_secp256k1.default,
  encodeUtxoId: () => encodeUtxoId,
  fillUtxoPubkey: () => fillUtxoPubkey,
  getAddressType: () => getAddressType,
  isOpReturnScriptPubkey: () => isOpReturnScriptPubkey,
  isP2PKH: () => import_psbtutils.isP2PKH,
  isP2TR: () => import_psbtutils.isP2TR,
  isP2WPKH: () => import_psbtutils.isP2WPKH,
  isP2trScript: () => isP2trScript,
  isP2wpkhScript: () => isP2wpkhScript,
  isSupportedFromAddress: () => isSupportedFromAddress,
  isTaprootInput: () => import_bip371.isTaprootInput,
  isValidAddress: () => isValidAddress,
  limitPromiseBatchSize: () => limitPromiseBatchSize,
  networkToConfig: () => networkToConfig,
  networkToNetworkType: () => networkToNetworkType,
  networkTypeToConfig: () => networkTypeToConfig,
  networkTypeToNetwork: () => networkTypeToNetwork,
  opReturnScriptPubKeyToData: () => opReturnScriptPubKeyToData,
  prepareUtxoInputs: () => prepareUtxoInputs,
  publicKeyToAddress: () => publicKeyToAddress,
  publicKeyToPayment: () => publicKeyToPayment,
  remove0x: () => remove0x,
  sendBtc: () => sendBtc,
  sendRbf: () => sendRbf,
  sendRgbppUtxos: () => sendRgbppUtxos,
  sendRgbppUtxosBuilder: () => sendRgbppUtxosBuilder,
  sendUtxos: () => sendUtxos,
  toXOnly: () => toXOnly,
  transactionToHex: () => transactionToHex,
  tweakSigner: () => tweakSigner,
  utf8ToBuffer: () => utf8ToBuffer,
  utxoToInput: () => utxoToInput
});
module.exports = __toCommonJS(src_exports);

// src/preset/types.ts
var NetworkType = /* @__PURE__ */ ((NetworkType2) => {
  NetworkType2[NetworkType2["MAINNET"] = 0] = "MAINNET";
  NetworkType2[NetworkType2["TESTNET"] = 1] = "TESTNET";
  NetworkType2[NetworkType2["REGTEST"] = 2] = "REGTEST";
  return NetworkType2;
})(NetworkType || {});

// src/preset/config.ts
var import_cloneDeep = __toESM(require("lodash/cloneDeep.js"));

// src/bitcoin.ts
var import_secp256k1 = __toESM(require("@bitcoinerlab/secp256k1"));
var bitcoin = __toESM(require("bitcoinjs-lib"));
var import_ecpair = require("ecpair");
var import_bip371 = require("bitcoinjs-lib/src/psbt/bip371.js");
var import_psbtutils = require("bitcoinjs-lib/src/psbt/psbtutils.js");
bitcoin.initEccLib(import_secp256k1.default);
var ECPair = (0, import_ecpair.ECPairFactory)(import_secp256k1.default);

// src/error.ts
var ErrorCodes = /* @__PURE__ */ ((ErrorCodes2) => {
  ErrorCodes2[ErrorCodes2["UNKNOWN"] = 0] = "UNKNOWN";
  ErrorCodes2[ErrorCodes2["MISSING_PUBKEY"] = 20] = "MISSING_PUBKEY";
  ErrorCodes2[ErrorCodes2["CANNOT_FIND_UTXO"] = 21] = "CANNOT_FIND_UTXO";
  ErrorCodes2[ErrorCodes2["UNCONFIRMED_UTXO"] = 22] = "UNCONFIRMED_UTXO";
  ErrorCodes2[ErrorCodes2["INSUFFICIENT_UTXO"] = 23] = "INSUFFICIENT_UTXO";
  ErrorCodes2[ErrorCodes2["REFERENCED_UNPROVABLE_UTXO"] = 24] = "REFERENCED_UNPROVABLE_UTXO";
  ErrorCodes2[ErrorCodes2["UNSPENDABLE_OUTPUT"] = 25] = "UNSPENDABLE_OUTPUT";
  ErrorCodes2[ErrorCodes2["DUPLICATED_UTXO"] = 26] = "DUPLICATED_UTXO";
  ErrorCodes2[ErrorCodes2["DUST_OUTPUT"] = 27] = "DUST_OUTPUT";
  ErrorCodes2[ErrorCodes2["UNSUPPORTED_OUTPUT"] = 28] = "UNSUPPORTED_OUTPUT";
  ErrorCodes2[ErrorCodes2["INVALID_CHANGE_OUTPUT"] = 29] = "INVALID_CHANGE_OUTPUT";
  ErrorCodes2[ErrorCodes2["UNSUPPORTED_NETWORK_TYPE"] = 30] = "UNSUPPORTED_NETWORK_TYPE";
  ErrorCodes2[ErrorCodes2["UNSUPPORTED_ADDRESS_TYPE"] = 31] = "UNSUPPORTED_ADDRESS_TYPE";
  ErrorCodes2[ErrorCodes2["UNSUPPORTED_OP_RETURN_SCRIPT"] = 32] = "UNSUPPORTED_OP_RETURN_SCRIPT";
  ErrorCodes2[ErrorCodes2["INVALID_FEE_RATE"] = 33] = "INVALID_FEE_RATE";
  ErrorCodes2[ErrorCodes2["PAYMASTER_MISMATCH"] = 34] = "PAYMASTER_MISMATCH";
  ErrorCodes2[ErrorCodes2["INVALID_UTXO_ID"] = 35] = "INVALID_UTXO_ID";
  ErrorCodes2[ErrorCodes2["CKB_CANNOT_FIND_OUTPOINT"] = 40] = "CKB_CANNOT_FIND_OUTPOINT";
  ErrorCodes2[ErrorCodes2["CKB_INVALID_CELL_LOCK"] = 41] = "CKB_INVALID_CELL_LOCK";
  ErrorCodes2[ErrorCodes2["CKB_INVALID_INPUTS"] = 42] = "CKB_INVALID_INPUTS";
  ErrorCodes2[ErrorCodes2["CKB_INVALID_OUTPUTS"] = 43] = "CKB_INVALID_OUTPUTS";
  ErrorCodes2[ErrorCodes2["CKB_UNMATCHED_COMMITMENT"] = 44] = "CKB_UNMATCHED_COMMITMENT";
  ErrorCodes2[ErrorCodes2["MEMPOOL_API_RESPONSE_ERROR"] = 60] = "MEMPOOL_API_RESPONSE_ERROR";
  return ErrorCodes2;
})(ErrorCodes || {});
var ErrorMessages = {
  [0 /* UNKNOWN */]: "Unknown error",
  [20 /* MISSING_PUBKEY */]: "Missing a pubkey that pairs with the address, it is required for the P2TR UTXO included in the transaction",
  [21 /* CANNOT_FIND_UTXO */]: "Cannot find the UTXO, it may not exist or is not live",
  [22 /* UNCONFIRMED_UTXO */]: "Unconfirmed UTXO",
  [23 /* INSUFFICIENT_UTXO */]: "Insufficient UTXO to construct the transaction",
  [24 /* REFERENCED_UNPROVABLE_UTXO */]: 'Cannot reference a UTXO that does not belongs to "from"',
  [26 /* DUPLICATED_UTXO */]: "Cannot reference the same UTXO twice",
  [25 /* UNSPENDABLE_OUTPUT */]: "Target output is not an UTXO",
  [27 /* DUST_OUTPUT */]: "Output defined value is below the dust limit",
  [28 /* UNSUPPORTED_OUTPUT */]: "Unsupported output format",
  [29 /* INVALID_CHANGE_OUTPUT */]: "Invalid change output",
  [30 /* UNSUPPORTED_NETWORK_TYPE */]: "Unsupported network type",
  [31 /* UNSUPPORTED_ADDRESS_TYPE */]: "Unsupported address type",
  [32 /* UNSUPPORTED_OP_RETURN_SCRIPT */]: "Unsupported OP_RETURN script format",
  [33 /* INVALID_FEE_RATE */]: "Invalid fee rate provided or recommended",
  [34 /* PAYMASTER_MISMATCH */]: "Paymaster mismatched",
  [35 /* INVALID_UTXO_ID */]: "Invalid UtxoId",
  [40 /* CKB_CANNOT_FIND_OUTPOINT */]: "Cannot find CKB cell by OutPoint, it may not exist or is not live",
  [41 /* CKB_INVALID_CELL_LOCK */]: "Invalid CKB cell lock, it should be RgbppLock, RgbppTimeLock or null",
  [42 /* CKB_INVALID_INPUTS */]: "Invalid input(s) found in the CKB VirtualTx",
  [43 /* CKB_INVALID_OUTPUTS */]: "Invalid output(s) found in the CKB VirtualTx",
  [44 /* CKB_UNMATCHED_COMMITMENT */]: "Invalid commitment found in the CKB VirtualTx",
  [60 /* MEMPOOL_API_RESPONSE_ERROR */]: "Mempool.space API returned an error"
};
var TxBuildError = class _TxBuildError extends Error {
  code = 0 /* UNKNOWN */;
  context;
  constructor(code, message = ErrorMessages[code] || "Unknown error", context) {
    super(message);
    this.code = code;
    this.context = context;
    Object.setPrototypeOf(this, _TxBuildError.prototype);
  }
  static withComment(code, comment, context) {
    const message = ErrorMessages[code];
    return new _TxBuildError(code, comment ? `${message}: ${comment}` : message, context);
  }
  setContext(context) {
    this.context = context;
  }
};

// src/preset/config.ts
var defaultConfigs = {
  testnet: {
    feeRate: 1,
    btcUtxoDustLimit: 1e3,
    rgbppUtxoDustLimit: 546,
    network: bitcoin.networks.testnet,
    networkType: 1 /* TESTNET */
  },
  mainnet: {
    feeRate: 20,
    btcUtxoDustLimit: 1e4,
    rgbppUtxoDustLimit: 546,
    network: bitcoin.networks.bitcoin,
    networkType: 0 /* MAINNET */
  }
};
function networkTypeToConfig(networkType) {
  if (networkType === 1 /* TESTNET */) {
    return (0, import_cloneDeep.default)(defaultConfigs.testnet);
  }
  if (networkType === 0 /* MAINNET */) {
    return (0, import_cloneDeep.default)(defaultConfigs.mainnet);
  }
  throw new TxBuildError(30 /* UNSUPPORTED_NETWORK_TYPE */);
}
function networkToConfig(network) {
  if (network.bech32 == bitcoin.networks.bitcoin.bech32) {
    return (0, import_cloneDeep.default)(defaultConfigs.mainnet);
  }
  if (network.bech32 == bitcoin.networks.testnet.bech32) {
    return (0, import_cloneDeep.default)(defaultConfigs.testnet);
  }
  throw new TxBuildError(30 /* UNSUPPORTED_NETWORK_TYPE */);
}

// src/preset/network.ts
function networkTypeToNetwork(networkType) {
  const config = networkTypeToConfig(networkType);
  return config.network;
}
function networkToNetworkType(network) {
  const config = networkToConfig(network);
  return config.networkType;
}

// src/utils.ts
var import_p_limit = __toESM(require("p-limit"));
var import_codec = require("@ckb-lumos/codec");
var textEncoder = new TextEncoder();
function toXOnly(pubKey) {
  return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);
}
function tapTweakHash(publicKey, hash) {
  return bitcoin.crypto.taggedHash("TapTweak", Buffer.concat(hash ? [publicKey, hash] : [publicKey]));
}
function tweakSigner(signer, options) {
  if (!signer.privateKey) {
    throw new Error("Private key is required for tweaking signer!");
  }
  let privateKey = signer.privateKey;
  if (signer.publicKey[0] === 3) {
    privateKey = import_secp256k1.default.privateNegate(privateKey);
  }
  const tweakedPrivateKey = import_secp256k1.default.privateAdd(privateKey, tapTweakHash(toXOnly(signer.publicKey), options?.tweakHash));
  if (!tweakedPrivateKey) {
    throw new Error("Invalid tweaked private key!");
  }
  return ECPair.fromPrivateKey(Buffer.from(tweakedPrivateKey), {
    network: options?.network
  });
}
function remove0x(hex) {
  return hex.startsWith("0x") ? hex.slice(2) : hex;
}
function utf8ToBuffer(text) {
  const result = text.trim();
  if (result.startsWith("0x")) {
    return import_codec.bytes.bytify(result);
  }
  return textEncoder.encode(result);
}
function transactionToHex(tx, withWitness) {
  const buffer = tx["__toBuffer"](void 0, void 0, withWitness ?? false);
  return buffer.toString("hex");
}
function encodeUtxoId(txid, vout) {
  if (!txid || remove0x(txid).length !== 64) {
    throw TxBuildError.withComment(35 /* INVALID_UTXO_ID */, `txid=${txid}`);
  }
  if (vout < 0 || vout > 4294967295) {
    throw TxBuildError.withComment(35 /* INVALID_UTXO_ID */, `vout=${vout}`);
  }
  return `${remove0x(txid)}:${vout}`;
}
function decodeUtxoId(utxoId) {
  const parts = utxoId.split(":");
  const txid = parts[0];
  const vout = parts[1] ? parseInt(parts[1]) : void 0;
  if (!txid || txid.startsWith("0x") || txid.length !== 64 || typeof vout !== "number" || isNaN(vout) || vout < 0 || vout > 4294967295) {
    throw TxBuildError.withComment(35 /* INVALID_UTXO_ID */, utxoId);
  }
  return {
    txid,
    vout
  };
}
var limitPromiseBatchSize = (0, import_p_limit.default)(10);

// src/address.ts
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2[AddressType2["P2PKH"] = 0] = "P2PKH";
  AddressType2[AddressType2["P2WPKH"] = 1] = "P2WPKH";
  AddressType2[AddressType2["P2TR"] = 2] = "P2TR";
  AddressType2[AddressType2["P2SH_P2WPKH"] = 3] = "P2SH_P2WPKH";
  AddressType2[AddressType2["P2WSH"] = 4] = "P2WSH";
  AddressType2[AddressType2["P2SH"] = 5] = "P2SH";
  AddressType2[AddressType2["UNKNOWN"] = 6] = "UNKNOWN";
  return AddressType2;
})(AddressType || {});
function isSupportedFromAddress(address) {
  const { addressType } = decodeAddress(address);
  return addressType === 1 /* P2WPKH */ || addressType === 2 /* P2TR */;
}
function publicKeyToPayment(publicKey, addressType, networkType) {
  if (!publicKey) {
    return void 0;
  }
  const network = networkTypeToNetwork(networkType);
  const pubkey = Buffer.from(remove0x(publicKey), "hex");
  if (addressType === 0 /* P2PKH */) {
    return bitcoin.payments.p2pkh({
      pubkey,
      network
    });
  }
  if (addressType === 1 /* P2WPKH */) {
    return bitcoin.payments.p2wpkh({
      pubkey,
      network
    });
  }
  if (addressType === 2 /* P2TR */) {
    return bitcoin.payments.p2tr({
      internalPubkey: toXOnly(pubkey),
      network
    });
  }
  if (addressType === 3 /* P2SH_P2WPKH */) {
    const data = bitcoin.payments.p2wpkh({
      pubkey,
      network
    });
    return bitcoin.payments.p2sh({
      pubkey,
      network,
      redeem: data
    });
  }
  return void 0;
}
function publicKeyToAddress(publicKey, addressType, networkType) {
  const payment = publicKeyToPayment(publicKey, addressType, networkType);
  if (payment && payment.address) {
    return payment.address;
  } else {
    throw new TxBuildError(31 /* UNSUPPORTED_ADDRESS_TYPE */);
  }
}
function addressToScriptPublicKey(address, networkType) {
  const network = networkTypeToNetwork(networkType);
  return bitcoin.address.toOutputScript(address, network);
}
function addressToScriptPublicKeyHex(address, networkType) {
  const scriptPk = addressToScriptPublicKey(address, networkType);
  return scriptPk.toString("hex");
}
function isValidAddress(address, networkType) {
  try {
    bitcoin.address.toOutputScript(address, networkTypeToNetwork(networkType));
    return true;
  } catch {
    return false;
  }
}
function getAddressType(address) {
  return decodeAddress(address).addressType;
}
function decodeAddress(address) {
  const mainnet = bitcoin.networks.bitcoin;
  const testnet = bitcoin.networks.testnet;
  const regtest = bitcoin.networks.regtest;
  let decodeBase58;
  let decodeBech32;
  let networkType;
  let addressType;
  if (address.startsWith("bc1") || address.startsWith("tb1") || address.startsWith("bcrt1")) {
    try {
      decodeBech32 = bitcoin.address.fromBech32(address);
      if (decodeBech32.prefix === mainnet.bech32) {
        networkType = 0 /* MAINNET */;
      } else if (decodeBech32.prefix === testnet.bech32) {
        networkType = 1 /* TESTNET */;
      } else if (decodeBech32.prefix === regtest.bech32) {
        networkType = 2 /* REGTEST */;
      }
      if (decodeBech32.version === 0) {
        if (decodeBech32.data.length === 20) {
          addressType = 1 /* P2WPKH */;
        } else if (decodeBech32.data.length === 32) {
          addressType = 4 /* P2WSH */;
        }
      } else if (decodeBech32.version === 1) {
        if (decodeBech32.data.length === 32) {
          addressType = 2 /* P2TR */;
        }
      }
      if (networkType !== void 0 && addressType !== void 0) {
        return {
          networkType,
          addressType,
          dust: getAddressTypeDust(addressType)
        };
      }
    } catch (e) {
    }
  } else {
    try {
      decodeBase58 = bitcoin.address.fromBase58Check(address);
      if (decodeBase58.version === mainnet.pubKeyHash) {
        networkType = 0 /* MAINNET */;
        addressType = 0 /* P2PKH */;
      } else if (decodeBase58.version === testnet.pubKeyHash) {
        networkType = 1 /* TESTNET */;
        addressType = 0 /* P2PKH */;
      } else if (decodeBase58.version === regtest.pubKeyHash) {
        networkType = 2 /* REGTEST */;
        addressType = 0 /* P2PKH */;
      } else if (decodeBase58.version === mainnet.scriptHash) {
        networkType = 0 /* MAINNET */;
        addressType = 3 /* P2SH_P2WPKH */;
      } else if (decodeBase58.version === testnet.scriptHash) {
        networkType = 1 /* TESTNET */;
        addressType = 3 /* P2SH_P2WPKH */;
      } else if (decodeBase58.version === regtest.scriptHash) {
        networkType = 2 /* REGTEST */;
        addressType = 3 /* P2SH_P2WPKH */;
      }
      if (networkType !== void 0 && addressType !== void 0) {
        return {
          networkType,
          addressType,
          dust: getAddressTypeDust(addressType)
        };
      }
    } catch (e) {
    }
  }
  return {
    addressType: 6 /* UNKNOWN */,
    networkType: 0 /* MAINNET */,
    dust: 546
  };
}
function getAddressTypeDust(addressType) {
  if (addressType === 1 /* P2WPKH */) {
    return 294;
  } else if (addressType === 2 /* P2TR */) {
    return 330;
  } else {
    return 546;
  }
}
function addAddressToPubkeyMap(pubkeyMap, address, pubkey) {
  const newMap = { ...pubkeyMap };
  if (pubkey) {
    newMap[address] = pubkey;
  }
  return newMap;
}

// src/script.ts
function isP2wpkhScript(script) {
  const buffer = typeof script === "string" ? Buffer.from(script, "hex") : script;
  return (0, import_psbtutils.isP2WPKH)(buffer);
}
function isP2trScript(script) {
  const buffer = typeof script === "string" ? Buffer.from(script, "hex") : script;
  return (0, import_psbtutils.isP2TR)(buffer);
}

// src/query/source.ts
var import_service = require("@rgbpp-sdk/service");

// src/transaction/embed.ts
function dataToOpReturnScriptPubkey(data) {
  if (typeof data === "string") {
    data = Buffer.from(remove0x(data), "hex");
  }
  const payment = bitcoin.payments.embed({ data: [data] });
  return payment.output;
}
function opReturnScriptPubKeyToData(script) {
  if (!isOpReturnScriptPubkey(script)) {
    throw TxBuildError.withComment(32 /* UNSUPPORTED_OP_RETURN_SCRIPT */, script.toString("hex"));
  }
  const res = bitcoin.script.decompile(script);
  return res[1];
}
function isOpReturnScriptPubkey(script) {
  const scripts = bitcoin.script.decompile(script);
  if (!scripts || scripts.length !== 2) {
    return false;
  }
  const [op, data] = scripts;
  if (op !== bitcoin.opcodes.OP_RETURN) {
    return false;
  }
  if (!(data instanceof Buffer) || data.byteLength < 1 || data.byteLength > 80) {
    return false;
  }
  return true;
}

// src/query/cache.ts
var DataCache = class {
  utxos;
  // Map<Key, Utxo[]>
  constructor() {
    this.utxos = /* @__PURE__ */ new Map();
  }
  setUtxos(key, utxos) {
    this.utxos.set(key, utxos);
  }
  getUtxos(key) {
    return this.utxos.get(key);
  }
  cleanUtxos(key) {
    if (this.utxos.has(key)) {
      this.utxos.delete(key);
    }
  }
  async optionalCacheUtxos(props) {
    if (props.key && this.utxos.has(props.key)) {
      return this.getUtxos(props.key);
    }
    const utxos = await props.getter();
    if (props.key) {
      this.setUtxos(props.key, utxos);
    }
    return utxos;
  }
};

// src/query/source.ts
var DataSource = class {
  cache;
  service;
  networkType;
  constructor(service, networkType) {
    this.service = service;
    this.networkType = networkType;
    this.cache = new DataCache();
  }
  // Query a UTXO from the service.
  // Will throw error if the target output is unspendable.
  // When set "confirmed = true", will throw error if the output is unconfirmed.
  async getUtxo(hash, index, requireConfirmed) {
    const output = await this.getOutput(hash, index, requireConfirmed);
    if (output && !("address" in output)) {
      throw TxBuildError.withComment(25 /* UNSPENDABLE_OUTPUT */, `hash: ${hash}, index: ${index}`);
    }
    return output;
  }
  // Query an output from the service.
  // Both unspent or unspendable output can be queried from the API.
  // When set "confirmed = true", will throw error if the output is unconfirmed.
  async getOutput(hash, index, requireConfirmed) {
    const txId = remove0x(hash);
    const tx = await this.service.getBtcTransaction(txId);
    if (!tx) {
      return void 0;
    }
    if (requireConfirmed && !tx.status.confirmed) {
      throw TxBuildError.withComment(22 /* UNCONFIRMED_UTXO */, `hash: ${hash}, index: ${index}`);
    }
    const vout = tx.vout[index];
    if (!vout) {
      return void 0;
    }
    const scriptBuffer = Buffer.from(vout.scriptpubkey, "hex");
    if (isOpReturnScriptPubkey(scriptBuffer)) {
      return {
        txid: txId,
        vout: index,
        value: vout.value,
        scriptPk: vout.scriptpubkey
      };
    }
    return {
      txid: txId,
      vout: index,
      value: vout.value,
      scriptPk: vout.scriptpubkey,
      address: vout.scriptpubkey_address,
      addressType: getAddressType(vout.scriptpubkey_address)
    };
  }
  async isTransactionConfirmed(hash) {
    const tx = await this.service.getBtcTransaction(remove0x(hash));
    return tx.status.confirmed;
  }
  async getUtxos(address, params) {
    const utxos = await this.service.getBtcUtxos(address, params);
    const scriptPk = addressToScriptPublicKeyHex(address, this.networkType);
    return utxos.sort((a, b) => {
      const aBlockHeight = a.status.block_height;
      const bBlockHeight = b.status.block_height;
      if (aBlockHeight !== bBlockHeight) {
        return aBlockHeight - bBlockHeight;
      }
      return a.vout - b.vout;
    }).map((row) => {
      return {
        address,
        scriptPk,
        txid: row.txid,
        vout: row.vout,
        value: row.value,
        addressType: getAddressType(address)
      };
    });
  }
  async collectSatoshi(props) {
    const allowInsufficient = props.allowInsufficient ?? false;
    const excludeUtxos = props.excludeUtxos ?? [];
    const utxos = await this.cache.optionalCacheUtxos({
      key: props.internalCacheKey,
      getter: () => this.getUtxos(props.address, {
        only_non_rgbpp_utxos: props.onlyNonRgbppUtxos,
        only_confirmed: props.onlyConfirmedUtxos,
        min_satoshi: props.minUtxoSatoshi,
        no_cache: props.noAssetsApiCache
      })
    });
    const collected = [];
    let collectedAmount = 0;
    for (const utxo of utxos) {
      if (collectedAmount >= props.targetAmount) {
        break;
      }
      if (excludeUtxos.length > 0) {
        const excluded = excludeUtxos.find((exclude) => {
          return exclude.txid === utxo.txid && exclude.vout === utxo.vout;
        });
        if (excluded) {
          continue;
        }
      }
      collected.push(utxo);
      collectedAmount += utxo.value;
    }
    if (!allowInsufficient && collectedAmount < props.targetAmount) {
      throw TxBuildError.withComment(
        23 /* INSUFFICIENT_UTXO */,
        `expected: ${props.targetAmount}, actual: ${collectedAmount}`
      );
    }
    return {
      utxos: collected,
      satoshi: collectedAmount,
      exceedSatoshi: collectedAmount - props.targetAmount
    };
  }
  async getPaymasterOutput() {
    try {
      const paymasterInfo = await this.service.getRgbppPaymasterInfo();
      return {
        address: paymasterInfo.btc_address,
        value: paymasterInfo.fee
      };
    } catch (err) {
      if (err instanceof import_service.BtcAssetsApiError && err.code === import_service.ErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND) {
        return void 0;
      }
      throw err;
    }
  }
};

// src/transaction/build.ts
var import_cloneDeep3 = __toESM(require("lodash/cloneDeep.js"));

// src/transaction/utxo.ts
var import_cloneDeep2 = __toESM(require("lodash/cloneDeep.js"));
function utxoToInput(utxo) {
  if (utxo.addressType === 1 /* P2WPKH */) {
    const data = {
      hash: utxo.txid,
      index: utxo.vout,
      witnessUtxo: {
        value: utxo.value,
        script: Buffer.from(remove0x(utxo.scriptPk), "hex")
      }
    };
    return {
      data,
      utxo
    };
  }
  if (utxo.addressType === 2 /* P2TR */) {
    if (!utxo.pubkey) {
      throw TxBuildError.withComment(20 /* MISSING_PUBKEY */, utxo.address);
    }
    const data = {
      hash: utxo.txid,
      index: utxo.vout,
      witnessUtxo: {
        value: utxo.value,
        script: Buffer.from(remove0x(utxo.scriptPk), "hex")
      },
      tapInternalKey: toXOnly(Buffer.from(remove0x(utxo.pubkey), "hex"))
    };
    return {
      data,
      utxo
    };
  }
  throw new TxBuildError(31 /* UNSUPPORTED_ADDRESS_TYPE */);
}
function fillUtxoPubkey(utxo, pubkeyMap, options) {
  const newUtxo = (0, import_cloneDeep2.default)(utxo);
  if (isP2trScript(newUtxo.scriptPk) && !newUtxo.pubkey) {
    const pubkey = pubkeyMap[newUtxo.address];
    if (options?.requirePubkey && !pubkey) {
      throw TxBuildError.withComment(20 /* MISSING_PUBKEY */, newUtxo.address);
    }
    if (pubkey) {
      newUtxo.pubkey = pubkey;
    }
  }
  return newUtxo;
}
async function prepareUtxoInputs(props) {
  const pubkeyMap = props.pubkeyMap ?? {};
  const utxos = props.utxos.map((utxo) => {
    return fillUtxoPubkey(utxo, pubkeyMap, {
      requirePubkey: props.requirePubkey
    });
  });
  if (props.requireConfirmed) {
    await Promise.all(
      utxos.map(async (utxo) => {
        return limitPromiseBatchSize(async () => {
          const transactionConfirmed = await props.source.isTransactionConfirmed(utxo.txid);
          if (!transactionConfirmed) {
            throw TxBuildError.withComment(22 /* UNCONFIRMED_UTXO */, `hash: ${utxo.txid}, index: ${utxo.vout}`);
          }
        });
      })
    );
  }
  return utxos;
}

// src/transaction/fee.ts
var FeeEstimator = class _FeeEstimator {
  networkType;
  network;
  keyPair;
  pubkey;
  accounts;
  constructor(wif, networkType) {
    const network = networkTypeToNetwork(networkType);
    this.networkType = networkType;
    this.network = network;
    const keyPair = ECPair.fromWIF(wif, network);
    this.pubkey = keyPair.publicKey.toString("hex");
    this.keyPair = keyPair;
    const p2wpkh = bitcoin.payments.p2wpkh({
      pubkey: keyPair.publicKey,
      network
    });
    const p2tr = bitcoin.payments.p2tr({
      internalPubkey: toXOnly(keyPair.publicKey),
      network
    });
    this.accounts = {
      p2wpkh: {
        payment: p2wpkh,
        address: p2wpkh.address,
        addressType: 1 /* P2WPKH */,
        scriptPubkey: p2wpkh.output.toString("hex")
      },
      p2tr: {
        payment: p2tr,
        address: p2tr.address,
        addressType: 2 /* P2TR */,
        tapInternalKey: toXOnly(keyPair.publicKey),
        scriptPubkey: p2tr.output.toString("hex")
      }
    };
  }
  static fromRandom(networkType) {
    const network = networkTypeToNetwork(networkType);
    const keyPair = ECPair.makeRandom({ network });
    return new _FeeEstimator(keyPair.toWIF(), networkType);
  }
  replaceUtxo(utxo) {
    if (utxo.addressType === 1 /* P2WPKH */ || isP2wpkhScript(utxo.scriptPk)) {
      utxo.scriptPk = this.accounts.p2wpkh.scriptPubkey;
      utxo.pubkey = this.pubkey;
    }
    if (utxo.addressType === 2 /* P2TR */ || isP2trScript(utxo.scriptPk)) {
      utxo.scriptPk = this.accounts.p2tr.scriptPubkey;
      utxo.pubkey = this.pubkey;
    }
    return utxo;
  }
  async signPsbt(psbt) {
    const tweakedSigner = tweakSigner(this.keyPair, {
      network: this.network
    });
    psbt.data.inputs.forEach((input, index) => {
      if (input.witnessUtxo) {
        const isNotSigned = !(input.finalScriptSig || input.finalScriptWitness);
        const isP2trInput = isP2trScript(input.witnessUtxo.script);
        const lostInternalPubkey = !input.tapInternalKey;
        if (isNotSigned && isP2trInput && lostInternalPubkey) {
          if (input.witnessUtxo.script.toString("hex") === this.accounts.p2tr.scriptPubkey) {
            input.tapInternalKey = this.accounts.p2tr.tapInternalKey;
          }
        }
      }
      if ((0, import_bip371.isTaprootInput)(input)) {
        psbt.signInput(index, tweakedSigner);
      } else {
        psbt.signInput(index, this.keyPair);
      }
    });
    psbt.finalizeAllInputs();
    return psbt;
  }
};

// src/transaction/build.ts
var TxBuilder = class _TxBuilder {
  inputs = [];
  outputs = [];
  source;
  config;
  networkType;
  onlyNonRgbppUtxos;
  onlyConfirmedUtxos;
  minUtxoSatoshi;
  feeRate;
  constructor(props) {
    this.source = props.source;
    this.networkType = this.source.networkType;
    this.config = networkTypeToConfig(this.networkType);
    this.onlyNonRgbppUtxos = props.onlyNonRgbppUtxos ?? true;
    this.onlyConfirmedUtxos = props.onlyConfirmedUtxos ?? false;
    this.minUtxoSatoshi = props.minUtxoSatoshi ?? this.config.btcUtxoDustLimit;
    this.feeRate = props.feeRate;
  }
  hasInput(hash, index) {
    return this.inputs.some((input) => input.data.hash === hash && input.data.index === index);
  }
  addInput(utxo) {
    if (this.hasInput(utxo.txid, utxo.vout)) {
      throw TxBuildError.withComment(26 /* DUPLICATED_UTXO */, `hash: ${utxo.txid}, index: ${utxo.vout}`);
    }
    utxo = (0, import_cloneDeep3.default)(utxo);
    this.inputs.push(utxoToInput(utxo));
  }
  addInputs(utxos) {
    utxos.forEach((utxo) => {
      this.addInput(utxo);
    });
  }
  async validateInputs() {
    await Promise.all(
      this.inputs.map(async (input) => {
        return limitPromiseBatchSize(async () => {
          const transactionConfirmed = await this.source.isTransactionConfirmed(input.data.hash);
          if (!transactionConfirmed) {
            throw TxBuildError.withComment(
              22 /* UNCONFIRMED_UTXO */,
              `hash: ${input.data.hash}, index: ${input.data.index}`
            );
          }
        });
      })
    );
  }
  addOutput(output) {
    let result;
    if ("data" in output) {
      result = {
        script: dataToOpReturnScriptPubkey(output.data),
        value: output.value,
        fixed: output.fixed,
        protected: output.protected,
        minUtxoSatoshi: output.minUtxoSatoshi
      };
    }
    if ("address" in output || "script" in output) {
      result = (0, import_cloneDeep3.default)(output);
    }
    if (!result) {
      throw new TxBuildError(28 /* UNSUPPORTED_OUTPUT */);
    }
    const minUtxoSatoshi = result.minUtxoSatoshi ?? this.minUtxoSatoshi;
    const isOpReturnOutput = "script" in result && isOpReturnScriptPubkey(result.script);
    if (!isOpReturnOutput && result.value < minUtxoSatoshi) {
      throw TxBuildError.withComment(27 /* DUST_OUTPUT */, `expected ${minUtxoSatoshi}, but defined ${result.value}`);
    }
    this.outputs.push(result);
  }
  addOutputs(outputs) {
    outputs.forEach((output) => {
      this.addOutput(output);
    });
  }
  async payFee(props) {
    const { address, publicKey, feeRate, changeAddress, deductFromOutputs, excludeUtxos } = props;
    const originalInputs = (0, import_cloneDeep3.default)(this.inputs);
    const originalOutputs = (0, import_cloneDeep3.default)(this.outputs);
    const internalCacheKey = `${Date.now()}`;
    let defaultFeeRate;
    if (!feeRate && !this.feeRate) {
      const feeRates = await this.source.service.getBtcRecommendedFeeRates();
      defaultFeeRate = feeRates.fastestFee;
    }
    const currentFeeRate = feeRate ?? this.feeRate ?? defaultFeeRate;
    let currentFee = 0;
    let previousFee = 0;
    let isLoopedOnce = false;
    let isFeeExpected = false;
    let currentChangeIndex = -1;
    while (!isFeeExpected) {
      if (isLoopedOnce) {
        previousFee = currentFee;
        this.inputs = (0, import_cloneDeep3.default)(originalInputs);
        this.outputs = (0, import_cloneDeep3.default)(originalOutputs);
      }
      const { needCollect, needReturn, inputsTotal } = this.summary();
      const safeToProcess = inputsTotal > 0 || previousFee > 0;
      const returnAmount = needReturn - previousFee;
      if (safeToProcess && returnAmount > 0) {
        const { changeIndex } = await this.injectChange({
          address: changeAddress ?? address,
          amount: returnAmount,
          fromAddress: address,
          fromPublicKey: publicKey,
          internalCacheKey,
          excludeUtxos
        });
        currentChangeIndex = changeIndex;
      } else {
        const protectionAmount = safeToProcess ? 0 : 1;
        const targetAmount = needCollect - needReturn + previousFee + protectionAmount;
        const { changeIndex } = await this.injectSatoshi({
          address,
          publicKey,
          targetAmount,
          changeAddress,
          deductFromOutputs,
          internalCacheKey,
          excludeUtxos
        });
        currentChangeIndex = changeIndex;
      }
      currentFee = await this.calculateFee(currentFeeRate);
      isFeeExpected = [-1, 0, 1].includes(currentFee - previousFee);
      if (!isLoopedOnce) {
        isLoopedOnce = true;
      }
    }
    this.source.cache.cleanUtxos(internalCacheKey);
    return {
      fee: currentFee,
      feeRate: currentFeeRate,
      changeIndex: currentChangeIndex
    };
  }
  async injectSatoshi(props) {
    if (!isSupportedFromAddress(props.address)) {
      throw TxBuildError.withComment(31 /* UNSUPPORTED_ADDRESS_TYPE */, props.address);
    }
    const targetAmount = props.targetAmount;
    const excludeUtxos = props.excludeUtxos ?? [];
    const injectCollected = props.injectCollected ?? false;
    const deductFromOutputs = props.deductFromOutputs ?? true;
    let collected = 0;
    let changeAmount = 0;
    const _collect = async (_targetAmount) => {
      const { utxos, satoshi } = await this.source.collectSatoshi({
        address: props.address,
        targetAmount: _targetAmount,
        allowInsufficient: true,
        noAssetsApiCache: true,
        internalCacheKey: props.internalCacheKey,
        minUtxoSatoshi: this.minUtxoSatoshi,
        onlyNonRgbppUtxos: this.onlyNonRgbppUtxos,
        onlyConfirmedUtxos: this.onlyConfirmedUtxos,
        excludeUtxos: [...this.inputs.map((v) => v.utxo), ...excludeUtxos]
      });
      utxos.forEach((utxo) => {
        this.addInput({
          ...utxo,
          pubkey: props.publicKey
        });
      });
      collected += satoshi;
      _updateChangeAmount();
    };
    const _updateChangeAmount = () => {
      if (injectCollected) {
        changeAmount = collected + targetAmount;
      } else {
        changeAmount = collected - targetAmount;
      }
    };
    if (deductFromOutputs) {
      for (let i = 0; i < this.outputs.length; i++) {
        const output = this.outputs[i];
        if (output.fixed) {
          continue;
        }
        if (collected >= targetAmount) {
          break;
        }
        const minUtxoSatoshi = output.minUtxoSatoshi ?? this.minUtxoSatoshi;
        const freeAmount = output.value - minUtxoSatoshi;
        const remain = targetAmount - collected;
        if (output.protected) {
          const collectAmount = Math.min(freeAmount, remain);
          output.value -= collectAmount;
          collected += collectAmount;
        } else {
          const collectAmount = output.value > remain ? Math.min(freeAmount, remain) : output.value;
          output.value -= collectAmount;
          collected += collectAmount;
          if (output.value === 0) {
            this.outputs.splice(i, 1);
            i--;
          }
        }
      }
    }
    if (collected < targetAmount) {
      await _collect(targetAmount - collected);
    }
    const changeAddress = props.changeAddress ?? props.address;
    const changeToOutputs = !this.canInjectChangeToOutputs(changeAddress);
    const needChangeOutput = !changeToOutputs && changeAmount > 0 && changeAmount < this.minUtxoSatoshi;
    const changeOutputNeedAmount = needChangeOutput ? this.minUtxoSatoshi - changeAmount : 0;
    if (changeOutputNeedAmount > 0) {
      await _collect(changeOutputNeedAmount);
    }
    const insufficientBalance = collected < targetAmount;
    if (insufficientBalance) {
      const recommendedDeposit = targetAmount - collected + this.minUtxoSatoshi;
      throw TxBuildError.withComment(
        23 /* INSUFFICIENT_UTXO */,
        `expected: ${targetAmount}, actual: ${collected}. You may wanna deposit more satoshi to prevent the error, for example: ${recommendedDeposit}`
      );
    }
    const insufficientForChange = !changeToOutputs && changeAmount > 0 && changeAmount < this.minUtxoSatoshi;
    if (insufficientForChange) {
      const shiftedExpectAmount = collected + changeOutputNeedAmount;
      throw TxBuildError.withComment(
        23 /* INSUFFICIENT_UTXO */,
        `expected: ${shiftedExpectAmount}, actual: ${collected}`
      );
    }
    let changeIndex = -1;
    if (changeAmount > 0) {
      const injectedChanged = await this.injectChange({
        amount: changeAmount,
        address: changeAddress,
        fromAddress: props.address,
        fromPublicKey: props.publicKey
      });
      changeIndex = injectedChanged.changeIndex;
    }
    return {
      collected,
      changeIndex,
      changeAmount
    };
  }
  async injectChange(props) {
    const { address, fromAddress, fromPublicKey, amount, excludeUtxos, internalCacheKey } = props;
    for (let i = 0; i < this.outputs.length; i++) {
      const output = this.outputs[i];
      if (output.fixed) {
        continue;
      }
      if (!("address" in output) || output.address !== address) {
        continue;
      }
      output.value += amount;
      return {
        changeIndex: i
      };
    }
    let changeIndex = -1;
    if (amount < this.minUtxoSatoshi) {
      const injected = await this.injectSatoshi({
        address: fromAddress,
        publicKey: fromPublicKey,
        targetAmount: amount,
        changeAddress: address,
        injectCollected: true,
        deductFromOutputs: false,
        internalCacheKey,
        excludeUtxos
      });
      if (injected.collected < amount) {
        throw TxBuildError.withComment(
          23 /* INSUFFICIENT_UTXO */,
          `expected: ${amount}, actual: ${injected.collected}`
        );
      }
      changeIndex = injected.changeIndex;
    } else {
      this.addOutput({
        address,
        value: amount
      });
      changeIndex = this.outputs.length - 1;
    }
    return {
      changeIndex
    };
  }
  canInjectChangeToOutputs(changeAddress) {
    return this.outputs.some((output) => {
      return !output.fixed && (!("address" in output) || output.address === changeAddress);
    });
  }
  async calculateFee(feeRate) {
    if (!feeRate && !this.feeRate) {
      throw TxBuildError.withComment(33 /* INVALID_FEE_RATE */, `${feeRate ?? this.feeRate}`);
    }
    const currentFeeRate = feeRate ?? this.feeRate;
    const psbt = await this.createEstimatedPsbt();
    const tx = psbt.extractTransaction(true);
    const inputs = tx.ins.length;
    const weightWithWitness = tx.byteLength(true);
    const weightWithoutWitness = tx.byteLength(false);
    const weight = weightWithoutWitness * 3 + weightWithWitness + inputs;
    const virtualSize = Math.ceil(weight / 4);
    return Math.ceil(virtualSize * currentFeeRate);
  }
  async createEstimatedPsbt() {
    const estimator = FeeEstimator.fromRandom(this.networkType);
    const tx = this.clone();
    tx.inputs = tx.inputs.map((input) => {
      const replacedUtxo = estimator.replaceUtxo(input.utxo);
      return utxoToInput(replacedUtxo);
    });
    const psbt = tx.toPsbt();
    await estimator.signPsbt(psbt);
    return psbt;
  }
  summary() {
    const inputsTotal = this.inputs.reduce((acc, input) => acc + input.utxo.value, 0);
    const outputsTotal = this.outputs.reduce((acc, output) => acc + output.value, 0);
    const inputsRemaining = inputsTotal - outputsTotal;
    const outputsRemaining = outputsTotal - inputsTotal;
    return {
      inputsTotal,
      outputsTotal,
      inputsRemaining,
      outputsRemaining,
      needReturn: inputsRemaining > 0 ? inputsRemaining : 0,
      needCollect: outputsRemaining > 0 ? outputsRemaining : 0
    };
  }
  clone() {
    const tx = new _TxBuilder({
      source: this.source,
      feeRate: this.feeRate,
      minUtxoSatoshi: this.minUtxoSatoshi
    });
    tx.inputs = (0, import_cloneDeep3.default)(this.inputs);
    tx.outputs = (0, import_cloneDeep3.default)(this.outputs);
    return tx;
  }
  toPsbt() {
    const network = this.config.network;
    const psbt = new bitcoin.Psbt({ network });
    this.inputs.forEach((input) => {
      psbt.data.addInput(input.data);
    });
    this.outputs.forEach((output) => {
      psbt.addOutput(output);
    });
    return psbt;
  }
};

// src/api/sendUtxos.ts
async function createSendUtxosBuilder(props) {
  const tx = new TxBuilder({
    source: props.source,
    feeRate: props.feeRate,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos
  });
  try {
    const pubkeyMap = addAddressToPubkeyMap(props.pubkeyMap ?? {}, props.from, props.fromPubkey);
    const inputs = await prepareUtxoInputs({
      utxos: props.inputs,
      source: props.source,
      requireConfirmed: props.onlyConfirmedUtxos && !props.skipInputsValidation,
      requirePubkey: true,
      pubkeyMap
    });
    tx.addInputs(inputs);
    tx.addOutputs(props.outputs);
    const paid = await tx.payFee({
      address: props.from,
      publicKey: pubkeyMap[props.from],
      changeAddress: props.changeAddress,
      excludeUtxos: props.excludeUtxos
    });
    return {
      builder: tx,
      fee: paid.fee,
      feeRate: paid.feeRate,
      changeIndex: paid.changeIndex
    };
  } catch (e) {
    if (e instanceof TxBuildError) {
      e.setContext({ tx });
    }
    throw e;
  }
}
async function sendUtxos(props) {
  const { builder } = await createSendUtxosBuilder(props);
  return builder.toPsbt();
}

// src/api/sendBtc.ts
async function createSendBtcBuilder(props) {
  const outputs = props.tos.map((to) => ({
    fixed: true,
    ...to
  }));
  return await createSendUtxosBuilder({
    inputs: [],
    outputs,
    from: props.from,
    source: props.source,
    feeRate: props.feeRate,
    fromPubkey: props.fromPubkey,
    changeAddress: props.changeAddress,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos
  });
}
async function sendBtc(props) {
  const { builder } = await createSendBtcBuilder(props);
  return builder.toPsbt();
}

// src/api/sendRbf.ts
async function createSendRbfBuilder(props) {
  const previousTx = bitcoin.Transaction.fromHex(props.txHex);
  const network = networkTypeToNetwork(props.source.networkType);
  const inputs = [];
  for (const input of previousTx.ins) {
    const hash = Buffer.from(input.hash).reverse().toString("hex");
    const utxo = await props.source.getUtxo(hash, input.index);
    if (!utxo) {
      throw TxBuildError.withComment(21 /* CANNOT_FIND_UTXO */, `hash: ${hash}, index: ${input.index}`);
    }
    inputs.push(utxo);
  }
  const requireValidOutputsValue = props.requireValidOutputsValue ?? false;
  const outputs = previousTx.outs.map((output) => {
    if (isOpReturnScriptPubkey(output.script)) {
      return {
        script: output.script,
        value: output.value,
        fixed: true
      };
    } else {
      return {
        minUtxoSatoshi: requireValidOutputsValue ? void 0 : output.value,
        address: bitcoin.address.fromOutputScript(output.script, network),
        value: output.value,
        fixed: true
      };
    }
  });
  let changeAddress = props.changeAddress;
  if (props.changeIndex !== void 0) {
    const changeOutput = outputs[props.changeIndex];
    if (!changeOutput) {
      throw TxBuildError.withComment(29 /* INVALID_CHANGE_OUTPUT */, `outputs[${props.changeIndex}] is not found`);
    }
    const isReturnableOutput = changeOutput && "address" in changeOutput;
    if (!isReturnableOutput) {
      throw TxBuildError.withComment(
        29 /* INVALID_CHANGE_OUTPUT */,
        `outputs[${props.changeIndex}] is not a returnable output for change`
      );
    }
    const changeOutputAddress = changeOutput.address;
    if (changeOutputAddress && changeAddress && changeAddress !== changeOutputAddress) {
      throw TxBuildError.withComment(
        29 /* INVALID_CHANGE_OUTPUT */,
        `The address of outputs[${props.changeIndex}] does not match the specified changeAddress, expected: ${changeAddress}, actual: ${changeOutputAddress}`
      );
    }
    if (changeOutputAddress && !changeAddress) {
      changeAddress = changeOutputAddress;
    }
    const isLastOutput = outputs.length === props.changeIndex + 1;
    if (isLastOutput) {
      outputs.pop();
    } else {
      const config = networkTypeToConfig(props.source.networkType);
      const minUtxoSatoshi = props.minUtxoSatoshi ?? config.btcUtxoDustLimit;
      changeOutput.minUtxoSatoshi = minUtxoSatoshi;
      changeOutput.value = minUtxoSatoshi;
      changeOutput.protected = true;
      changeOutput.fixed = false;
    }
  }
  const requireGreaterFeeAndRate = props.requireGreaterFeeAndRate ?? true;
  let feeRate = props.feeRate;
  if (requireGreaterFeeAndRate && !feeRate) {
    const feeRates = await props.source.service.getBtcRecommendedFeeRates();
    feeRate = feeRates.fastestFee;
  }
  const previousInsValue = inputs.reduce((sum, input) => sum + input.value, 0);
  const previousOutsValue = previousTx.outs.reduce((sum, output) => sum + output.value, 0);
  const previousFee = previousInsValue - previousOutsValue;
  const previousFeeRate = Math.floor(previousFee / previousTx.virtualSize());
  if (requireGreaterFeeAndRate && feeRate !== void 0 && feeRate <= previousFeeRate) {
    throw TxBuildError.withComment(
      33 /* INVALID_FEE_RATE */,
      `RBF should offer a higher fee rate, previous: ${previousFeeRate}, current: ${feeRate}`
    );
  }
  const previousTxId = previousTx.getId();
  const excludeUtxos = previousTx.outs.map((_, index) => ({
    txid: previousTxId,
    vout: index
  }));
  const res = await createSendUtxosBuilder({
    inputs,
    outputs,
    excludeUtxos,
    changeAddress,
    from: props.from,
    source: props.source,
    feeRate: props.feeRate,
    pubkeyMap: props.pubkeyMap,
    fromPubkey: props.fromPubkey,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos ?? true,
    skipInputsValidation: true
  });
  if (requireGreaterFeeAndRate && res.fee <= previousFee) {
    throw TxBuildError.withComment(
      33 /* INVALID_FEE_RATE */,
      `RBF should offer a higher fee amount, previous: ${previousFee}, current: ${res.fee}`
    );
  }
  return res;
}
async function sendRbf(props) {
  const { builder } = await createSendRbfBuilder(props);
  return builder.toPsbt();
}

// src/api/sendRgbppUtxos.ts
var import_ckb = require("@rgbpp-sdk/ckb");
var sendRgbppUtxosBuilder = createSendRgbppUtxosBuilder;
async function createSendRgbppUtxosBuilder(props) {
  const btcInputs = [];
  const btcOutputs = [];
  let lastCkbTypeOutputIndex = -1;
  const ckbVirtualTx = props.ckbVirtualTx;
  const config = networkTypeToConfig(props.source.networkType);
  const isCkbMainnet = props.source.networkType === 0 /* MAINNET */;
  const rgbppLockArgsList = (await props.ckbCollector.getLiveCells(ckbVirtualTx.inputs.map((input) => input.previousOutput))).map(
    (cell) => (0, import_ckb.isRgbppLockCell)(cell.output, isCkbMainnet) ? (0, import_ckb.unpackRgbppLockArgs)(cell.output.lock.args) : void 0
  );
  const btcUtxos = await Promise.all(
    rgbppLockArgsList.map((rgbppLockArgs) => {
      if (rgbppLockArgs) {
        return limitPromiseBatchSize(
          () => props.source.getUtxo(rgbppLockArgs.btcTxId, rgbppLockArgs.outIndex, props.onlyConfirmedUtxos)
        );
      }
      return void 0;
    })
  );
  for (let i = 0; i < ckbVirtualTx.inputs.length; i++) {
    const rgbppLockArgs = rgbppLockArgsList[i];
    if (rgbppLockArgs) {
      const utxo = btcUtxos[i];
      if (!utxo) {
        throw TxBuildError.withComment(
          21 /* CANNOT_FIND_UTXO */,
          `hash: ${rgbppLockArgs.btcTxId}, index: ${rgbppLockArgs.outIndex}`
        );
      }
      const foundInInputs = btcInputs.some((v) => v.txid === utxo.txid && v.vout === utxo.vout);
      if (!foundInInputs) {
        btcInputs.push(utxo);
      }
    }
  }
  if (btcInputs.length < 1) {
    throw new TxBuildError(42 /* CKB_INVALID_INPUTS */);
  }
  for (let i = 0; i < ckbVirtualTx.outputs.length; i++) {
    const ckbOutput = ckbVirtualTx.outputs[i];
    const isRgbppLock = (0, import_ckb.isRgbppLockCell)(ckbOutput, isCkbMainnet);
    const isBtcTimeLock = (0, import_ckb.isBtcTimeLockCell)(ckbOutput, isCkbMainnet);
    if (ckbOutput.type) {
      if (!isRgbppLock && !isBtcTimeLock) {
        throw new TxBuildError(41 /* CKB_INVALID_CELL_LOCK */);
      }
      lastCkbTypeOutputIndex = i;
    }
    if (isRgbppLock) {
      const toBtcAddress = props.tos?.[i];
      const minUtxoSatoshi = props.rgbppMinUtxoSatoshi ?? config.rgbppUtxoDustLimit;
      btcOutputs.push({
        fixed: true,
        address: toBtcAddress ?? props.from,
        value: minUtxoSatoshi,
        minUtxoSatoshi
      });
    }
  }
  if (lastCkbTypeOutputIndex < 0) {
    throw new TxBuildError(43 /* CKB_INVALID_OUTPUTS */);
  }
  const calculatedCommitment = (0, import_ckb.calculateCommitment)({
    inputs: ckbVirtualTx.inputs,
    outputs: ckbVirtualTx.outputs.slice(0, lastCkbTypeOutputIndex + 1),
    outputsData: ckbVirtualTx.outputsData.slice(0, lastCkbTypeOutputIndex + 1)
  });
  if (props.commitment !== calculatedCommitment) {
    throw new TxBuildError(44 /* CKB_UNMATCHED_COMMITMENT */);
  }
  const mergedBtcOutputs = await getMergedBtcOutputs(btcOutputs, props);
  return await createSendUtxosBuilder({
    inputs: btcInputs,
    outputs: mergedBtcOutputs,
    from: props.from,
    source: props.source,
    feeRate: props.feeRate,
    fromPubkey: props.fromPubkey,
    changeAddress: props.changeAddress,
    minUtxoSatoshi: props.minUtxoSatoshi,
    onlyConfirmedUtxos: props.onlyConfirmedUtxos,
    excludeUtxos: props.excludeUtxos,
    pubkeyMap: props.pubkeyMap
  });
}
async function getMergedBtcOutputs(btcOutputs, props) {
  const merged = [];
  merged.push({
    data: props.commitment,
    fixed: true,
    value: 0
  });
  merged.push(...btcOutputs);
  const defaultPaymaster = await props.source.getPaymasterOutput();
  const isPaymasterUnmatched = defaultPaymaster?.address !== props.paymaster?.address || defaultPaymaster?.value !== props.paymaster?.value;
  if (defaultPaymaster && props.paymaster && isPaymasterUnmatched) {
    throw TxBuildError.withComment(
      34 /* PAYMASTER_MISMATCH */,
      `expected: ${defaultPaymaster}, actual: ${props.paymaster}`
    );
  }
  const paymaster = defaultPaymaster ?? props.paymaster;
  const isNeedPaymasterOutput = await (async () => {
    if (props.needPaymaster !== void 0) {
      return props.needPaymaster;
    }
    const isInputsSufficient = await (0, import_ckb.checkCkbTxInputsCapacitySufficient)(props.ckbVirtualTx, props.ckbCollector);
    return !isInputsSufficient;
  })();
  if (paymaster && isNeedPaymasterOutput) {
    merged.push({
      ...paymaster,
      fixed: true
    });
  }
  return merged;
}
async function sendRgbppUtxos(props) {
  const { builder } = await createSendRgbppUtxosBuilder(props);
  return builder.toPsbt();
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AddressType,
  DataSource,
  ECPair,
  ErrorCodes,
  ErrorMessages,
  FeeEstimator,
  NetworkType,
  TxBuildError,
  TxBuilder,
  addAddressToPubkeyMap,
  addressToScriptPublicKey,
  addressToScriptPublicKeyHex,
  bitcoin,
  createSendBtcBuilder,
  createSendRbfBuilder,
  createSendRgbppUtxosBuilder,
  createSendUtxosBuilder,
  dataToOpReturnScriptPubkey,
  decodeAddress,
  decodeUtxoId,
  ecc,
  encodeUtxoId,
  fillUtxoPubkey,
  getAddressType,
  isOpReturnScriptPubkey,
  isP2PKH,
  isP2TR,
  isP2WPKH,
  isP2trScript,
  isP2wpkhScript,
  isSupportedFromAddress,
  isTaprootInput,
  isValidAddress,
  limitPromiseBatchSize,
  networkToConfig,
  networkToNetworkType,
  networkTypeToConfig,
  networkTypeToNetwork,
  opReturnScriptPubKeyToData,
  prepareUtxoInputs,
  publicKeyToAddress,
  publicKeyToPayment,
  remove0x,
  sendBtc,
  sendRbf,
  sendRgbppUtxos,
  sendRgbppUtxosBuilder,
  sendUtxos,
  toXOnly,
  transactionToHex,
  tweakSigner,
  utf8ToBuffer,
  utxoToInput
});
//# sourceMappingURL=index.js.map