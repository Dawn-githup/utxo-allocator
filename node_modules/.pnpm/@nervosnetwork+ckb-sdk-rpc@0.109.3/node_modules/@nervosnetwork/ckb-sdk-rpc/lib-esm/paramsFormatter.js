import { __rest } from "tslib";
import { JSBI } from '@nervosnetwork/ckb-sdk-utils';
import { PageSizeTooLargeException, PageSizeTooSmallException, OutputsValidatorTypeException, BigintOrHexStringTypeException, StringHashTypeException, HexStringWithout0xException, } from './exceptions/index.js';
const formatter = {
    toOptional: (format) => (arg) => {
        if (!format || arg === undefined || arg === null) {
            return arg;
        }
        return format(arg);
    },
    toArray: (format) => (arg) => {
        if (typeof format !== 'function' || !Array.isArray(arg)) {
            return arg;
        }
        return arg.map(format);
    },
    toHash: (hash) => {
        if (typeof hash !== 'string') {
            throw new StringHashTypeException(hash);
        }
        return hash.startsWith('0x') ? hash : `0x${hash}`;
    },
    toNumber: (number) => {
        if (typeof number === 'bigint') {
            return `0x${number.toString(16)}`;
        }
        if (typeof number !== 'string') {
            throw new BigintOrHexStringTypeException(number);
        }
        if (!number.startsWith('0x')) {
            throw new HexStringWithout0xException(number);
        }
        return number;
    },
    toScript: (script) => {
        const { codeHash, hashType: hash_type } = script, rest = __rest(script, ["codeHash", "hashType"]);
        return Object.assign({ code_hash: formatter.toHash(codeHash), hash_type }, rest);
    },
    toOutPoint: (outPoint) => {
        if (!outPoint)
            return outPoint;
        const { txHash, index } = outPoint, rest = __rest(outPoint, ["txHash", "index"]);
        return Object.assign({ tx_hash: formatter.toHash(txHash), index: formatter.toNumber(index) }, rest);
    },
    toInput: (input) => {
        if (!input)
            return input;
        const { previousOutput, since } = input, rest = __rest(input, ["previousOutput", "since"]);
        return Object.assign({ previous_output: formatter.toOutPoint(previousOutput), since: formatter.toNumber(since) }, rest);
    },
    toOutput: (output) => {
        if (!output)
            return output;
        const { capacity, lock, type = null } = output, rest = __rest(output, ["capacity", "lock", "type"]);
        return Object.assign({ capacity: formatter.toNumber(capacity), lock: formatter.toScript(lock), type: type ? formatter.toScript(type) : type }, rest);
    },
    toDepType: (type) => {
        if (type === 'depGroup') {
            return 'dep_group';
        }
        return type;
    },
    toCellDep: (cellDep) => {
        if (!cellDep)
            return cellDep;
        const { outPoint = null, depType = 'code' } = cellDep, rest = __rest(cellDep, ["outPoint", "depType"]);
        return Object.assign({ out_point: formatter.toOutPoint(outPoint), dep_type: formatter.toDepType(depType) }, rest);
    },
    toRawTransaction: (transaction) => {
        if (!transaction)
            return transaction;
        const { version, cellDeps = [], inputs = [], outputs = [], outputsData: outputs_data = [], headerDeps: header_deps = [] } = transaction, rest = __rest(transaction, ["version", "cellDeps", "inputs", "outputs", "outputsData", "headerDeps"]);
        const formattedInputs = inputs.map(input => formatter.toInput(input));
        const formattedOutputs = outputs.map(output => formatter.toOutput(output));
        const formattedCellDeps = cellDeps.map(cellDep => formatter.toCellDep(cellDep));
        const tx = Object.assign({ version: formatter.toNumber(version), cell_deps: formattedCellDeps, inputs: formattedInputs, outputs: formattedOutputs, outputs_data,
            header_deps }, rest);
        return tx;
    },
    toPageNumber: (pageNo = '0x1') => formatter.toNumber(pageNo),
    toPageSize: (pageSize = '0x32') => {
        const size = JSBI.BigInt(`${pageSize}`);
        const MAX_SIZE = 50;
        const MIN_SIZE = 0;
        if (JSBI.greaterThan(size, JSBI.BigInt(MAX_SIZE)))
            throw new PageSizeTooLargeException(pageSize, MAX_SIZE);
        if (JSBI.lessThan(size, JSBI.BigInt(MIN_SIZE)))
            throw new PageSizeTooSmallException(pageSize, MIN_SIZE);
        return formatter.toNumber(`0x${size.toString(16)}`);
    },
    toReverseOrder: (reverse = false) => !!reverse,
    toOutputsValidator: (outputsValidator) => {
        if (!outputsValidator)
            return undefined;
        const VALIDATORS = ['default', 'passthrough'];
        if (VALIDATORS.indexOf(outputsValidator) > -1) {
            return outputsValidator;
        }
        throw new OutputsValidatorTypeException();
    },
    toBoolean: (value) => {
        return !!value;
    },
    toTransactionProof: (proof) => {
        if (!proof)
            return proof;
        const { blockHash: block_hash, witnessesRoot: witnesses_root } = proof, rest = __rest(proof, ["blockHash", "witnessesRoot"]);
        return Object.assign({ block_hash,
            witnesses_root }, rest);
    },
};
export default formatter;
//# sourceMappingURL=paramsFormatter.js.map