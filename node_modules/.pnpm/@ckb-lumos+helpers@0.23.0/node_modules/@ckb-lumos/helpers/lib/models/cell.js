"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cellHelper = void 0;
var _base = require("./base");
var _base2 = require("@ckb-lumos/base");
var _script = require("./script");
var _bi = require("@ckb-lumos/bi");
var _codec = require("@ckb-lumos/codec");
var _molecule = require("@ckb-lumos/codec/lib/molecule");
var _blockchain = require("./blockchain");
var _index = require("../index");
function isCreateCellOptions(val) {
  if (!val || typeof val !== "object") return false;
  return "lock" in val;
}
const CellCodec = (0, _molecule.table)({
  cellOutput: _base2.blockchain.CellOutput,
  data: _base2.blockchain.Bytes,
  outPoint: (0, _molecule.option)(_base2.blockchain.OutPoint)
}, ["cellOutput", "data", "outPoint"]);

/**
 * A set of helper functions for Cell
 * @example
 * const cell = CellHelper.create({ lock: 'ckb1secp256k1lock' })
 * cell.cellOutput.capacity // == 61 CKB
 */
const cellHelper = exports.cellHelper = (0, _base.createModelHelper)({
  pack: model => {
    const cell = (() => {
      if (isCreateCellOptions(model)) {
        return {
          cellOutput: {
            capacity: _bi.BI.from(model.capacity || "0x0").toHexString(),
            lock: _script.scriptHelper.create(model.lock),
            type: model.type && _script.scriptHelper.create(model.type)
          },
          outPoint: model.outPoint && _blockchain.outPointHelper.create(model.outPoint),
          data: _codec.bytes.hexify(model.data || "0x")
        };
      }
      return model;
    })();
    if (_bi.BI.from(cell.cellOutput.capacity).eq(0)) {
      cell.cellOutput.capacity = (0, _index.minimalCellCapacityCompatible)(cell).toHexString();
    }
    return CellCodec.pack(cell);
  },
  unpack: value => CellCodec.unpack(value)
});
//# sourceMappingURL=cell.js.map