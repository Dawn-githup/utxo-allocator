"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectCommonCobuildProof = exports.assembleCobuildWitnessLayout = exports.unpackWitness = exports.getWitnessType = void 0;
const base_1 = require("@ckb-lumos/base");
const codec_1 = require("@ckb-lumos/codec");
const witnessLayout_1 = require("../codec/witnessLayout");
function getWitnessType(witness) {
    const buf = codec_1.bytes.bytify(witness ?? []);
    if (buf.length > 4) {
        const typeIndex = codec_1.number.Uint32LE.unpack(buf.slice(0, 4));
        if (typeIndex >= witnessLayout_1.WitnessLayoutFieldTags.SighashAll) {
            for (const [name, index] of Object.entries(witnessLayout_1.WitnessLayoutFieldTags)) {
                if (index === typeIndex) {
                    return name;
                }
            }
        }
        else {
            return 'WitnessArgs';
        }
    }
    throw new Error('Unknown witness format');
}
exports.getWitnessType = getWitnessType;
function unpackWitness(witness) {
    const buf = codec_1.bytes.bytify(witness ?? []);
    if (buf.length > 4) {
        const typeIndex = codec_1.number.Uint32LE.unpack(buf.slice(0, 4));
        try {
            if (typeIndex >= witnessLayout_1.WitnessLayoutFieldTags.SighashAll) {
                return witnessLayout_1.WitnessLayout.unpack(buf);
            }
            else {
                return {
                    type: 'WitnessArgs',
                    value: base_1.blockchain.WitnessArgs.unpack(buf),
                };
            }
        }
        catch (_err) {
            // passthrough
        }
    }
    throw new Error('Unknown witness format');
}
exports.unpackWitness = unpackWitness;
function assembleCobuildWitnessLayout(actions) {
    const witness = codec_1.bytes.hexify(witnessLayout_1.WitnessLayout.pack({
        type: 'SighashAll',
        value: {
            seal: '0x',
            message: {
                actions,
            },
        },
    }));
    return witness;
}
exports.assembleCobuildWitnessLayout = assembleCobuildWitnessLayout;
function injectCommonCobuildProof(props) {
    let txSkeleton = props.txSkeleton;
    // TODO: add Cobuild witness-check: If it's in legacy mode, manually add WitnessLayout
    if (txSkeleton.get('inputs').size > 0) {
        // Generate WitnessLayout
        // Append the witness to the end of the witnesses
        let witnessIndex;
        txSkeleton = txSkeleton.update('witnesses', (witnesses) => {
            witnessIndex = witnesses.size;
            const witness = assembleCobuildWitnessLayout(props.actions);
            return witnesses.push(witness);
        });
        return {
            txSkeleton,
            witnessIndex: witnessIndex,
        };
    }
    throw new Error('Cannot inject CobuildProof into a Transaction without witnesses');
}
exports.injectCommonCobuildProof = injectCommonCobuildProof;
//# sourceMappingURL=witnessLayout.js.map