"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMultipleSpores = exports.createSpore = void 0;
const common_scripts_1 = require("@ckb-lumos/lumos/common-scripts");
const lumos_1 = require("@ckb-lumos/lumos");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
const __1 = require("../..");
const createSpore_1 = require("../../../cobuild/action/spore/createSpore");
const witnessLayout_1 = require("../../../cobuild/base/witnessLayout");
const helpers_2 = require("@ckb-lumos/lumos/helpers");
const lodash_1 = __importDefault(require("lodash"));
async function createSpore(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const capacityMargin = lumos_1.BI.from(props.capacityMargin ?? 1_0000_0000);
    const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;
    // TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Insert input cells in advance for particular purpose
    if (props.prefixInputs) {
        for (const cell of props.prefixInputs) {
            const address = (0, helpers_2.encodeToAddress)(cell.cellOutput.lock, { config: config.lumos });
            const customScript = {
                script: cell.cellOutput.lock,
            };
            const customScriptExists = props.fromInfos.some((fromInfo) => {
                const parsedInfo = (0, common_scripts_1.parseFromInfo)(fromInfo, { config: config.lumos });
                return lodash_1.default.isEqual(customScript, parsedInfo.fromScript);
            });
            if (!customScriptExists) {
                props.fromInfos.push(address);
            }
            const setupCellResult = await (0, helpers_1.setupCell)({
                txSkeleton,
                input: cell,
                updateWitness: props.updateWitness,
                defaultWitness: props.defaultWitness,
                config: config.lumos,
            });
            txSkeleton = setupCellResult.txSkeleton;
        }
    }
    // Insert output cells in advance for particular purpose
    if (props.prefixOutputs) {
        txSkeleton.update('outputs', (outputs) => {
            props.prefixOutputs.forEach((cell) => outputs.push(cell));
            return outputs;
        });
    }
    // If referencing a ClusterAgent, get it from the OutPoint
    let clusterAgentCell;
    if (props.clusterAgentOutPoint) {
        clusterAgentCell = await (0, __1.getClusterAgentByOutPoint)(props.clusterAgentOutPoint, config);
    }
    // Create and inject a new spore cell, also inject cluster if exists
    const injectNewSporeResult = await (0, __1.injectNewSporeOutput)({
        txSkeleton,
        data: props.data,
        toLock: props.toLock,
        fromInfos: props.fromInfos,
        extraOutputLocks: props.prefixOutputs?.map((cell) => cell.cellOutput.lock),
        changeAddress: props.changeAddress,
        updateOutput: props.updateOutput,
        clusterAgent: props.clusterAgent,
        cluster: props.cluster,
        mutant: props.mutant,
        skipCheckContentType: props.skipCheckContentType,
        clusterAgentCell,
        capacityMargin,
        config,
    });
    txSkeleton = injectNewSporeResult.txSkeleton;
    const snapshot = (0, helpers_1.createCapacitySnapshotFromTransactionSkeleton)(txSkeleton);
    if (snapshot.inputsCapacity.gt(snapshot.outputsCapacity)) {
        // Generate new Spore Id
        txSkeleton = (0, __1.injectNewSporeIds)({
            outputIndices: [injectNewSporeResult.outputIndex],
            txSkeleton,
            config,
        });
        // Inject CobuildProof
        const sporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
        const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', sporeCell.cellOutput.type);
        if (sporeScript.behaviors?.cobuild) {
            const actionResult = (0, createSpore_1.generateCreateSporeAction)({
                txSkeleton,
                reference: injectNewSporeResult.reference,
                outputIndex: injectNewSporeResult.outputIndex,
            });
            const injectCobuildProofResult = (0, witnessLayout_1.injectCommonCobuildProof)({
                txSkeleton,
                actions: actionResult.actions,
            });
            txSkeleton = injectCobuildProofResult.txSkeleton;
        }
        // Redeem extra capacity
        const sporeAddress = lumos_1.helpers.encodeToAddress(sporeCell.cellOutput.lock, { config: config.lumos });
        const returnExceededCapacityAndPayFeeResult = await (0, helpers_1.returnExceededCapacityAndPayFee)({
            txSkeleton,
            changeAddress: props.changeAddress ?? sporeAddress,
            feeRate: props.feeRate,
            fromInfos: props.fromInfos,
            config,
        });
        txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
    }
    else {
        // Inject needed capacity and pay fee
        const injectCapacityAndPayFeeResult = await (0, helpers_1.injectCapacityAndPayFee)({
            txSkeleton,
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            feeRate: props.feeRate,
            updateTxSkeletonAfterCollection(_txSkeleton) {
                // Generate and inject SporeID
                _txSkeleton = (0, __1.injectNewSporeIds)({
                    outputIndices: [injectNewSporeResult.outputIndex],
                    txSkeleton: _txSkeleton,
                    config,
                });
                // Inject CobuildProof
                const sporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
                const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', sporeCell.cellOutput.type);
                if (sporeScript.behaviors?.cobuild) {
                    const actionResult = (0, createSpore_1.generateCreateSporeAction)({
                        txSkeleton: _txSkeleton,
                        reference: injectNewSporeResult.reference,
                        outputIndex: injectNewSporeResult.outputIndex,
                    });
                    const injectCobuildProofResult = (0, witnessLayout_1.injectCommonCobuildProof)({
                        txSkeleton: _txSkeleton,
                        actions: actionResult.actions,
                    });
                    _txSkeleton = injectCobuildProofResult.txSkeleton;
                }
                return _txSkeleton;
            },
            config,
        });
        txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    }
    // Make sure the tx size is in range (if needed)
    if (typeof maxTransactionSize === 'number') {
        (0, helpers_1.assertTransactionSkeletonSize)(txSkeleton, void 0, maxTransactionSize);
    }
    return {
        txSkeleton,
        outputIndex: injectNewSporeResult.outputIndex,
        reference: injectNewSporeResult.reference,
        mutantReference: injectNewSporeResult.mutantReference,
    };
}
exports.createSpore = createSpore;
async function createMultipleSpores(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const capacityMargin = lumos_1.BI.from(props.capacityMargin ?? 1_0000_0000);
    // TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Insert input cells in advance for particular purpose
    if (props.fromCells) {
        txSkeleton.update('inputs', (inputs) => {
            for (const cell of props.fromCells) {
                const address = (0, helpers_2.encodeToAddress)(cell.cellOutput.lock, { config: config.lumos });
                const customScript = {
                    script: cell.cellOutput.lock,
                };
                const customScriptExists = props.fromInfos.some((fromInfo) => {
                    const parsedInfo = (0, common_scripts_1.parseFromInfo)(fromInfo, { config: config.lumos });
                    return lodash_1.default.isEqual(customScript, parsedInfo.fromScript);
                });
                if (!customScriptExists) {
                    props.fromInfos.push(address);
                }
                inputs = inputs.push(cell);
            }
            return inputs;
        });
    }
    // If referencing a ClusterAgent, get it from the OutPoint
    let clusterAgentCell;
    if (props.clusterAgentOutPoint) {
        clusterAgentCell = await (0, __1.getClusterAgentByOutPoint)(props.clusterAgentOutPoint, config);
    }
    // Create and inject Spores to Transaction.outputs
    const injectNewSporeResults = [];
    for (const sporeInfo of props.sporeInfos) {
        const result = await (0, __1.injectNewSporeOutput)({
            txSkeleton,
            data: sporeInfo.data,
            toLock: sporeInfo.toLock,
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            updateOutput: props.updateOutput,
            clusterAgent: props.clusterAgent,
            cluster: props.cluster,
            mutant: props.mutant,
            clusterAgentCell,
            capacityMargin,
            config,
        });
        txSkeleton = result.txSkeleton;
        injectNewSporeResults.push(result);
    }
    // Inject needed capacity and pay fee
    const sporeOutputIndices = injectNewSporeResults.map((r) => r.outputIndex);
    const injectCapacityAndPayFeeResult = await (0, helpers_1.injectCapacityAndPayFee)({
        txSkeleton,
        fromInfos: props.fromInfos,
        changeAddress: props.changeAddress,
        updateTxSkeletonAfterCollection(_txSkeleton) {
            // Generate and inject SporeID
            _txSkeleton = (0, __1.injectNewSporeIds)({
                txSkeleton: _txSkeleton,
                outputIndices: sporeOutputIndices,
                config,
            });
            // Inject CobuildProof
            const actions = [];
            for (const injectNewSporeResult of injectNewSporeResults) {
                const sporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
                const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', sporeCell.cellOutput.type);
                if (sporeScript.behaviors?.cobuild) {
                    const actionResult = (0, createSpore_1.generateCreateSporeAction)({
                        txSkeleton: _txSkeleton,
                        reference: injectNewSporeResult.reference,
                        outputIndex: injectNewSporeResult.outputIndex,
                    });
                    actions.push(...actionResult.actions);
                }
            }
            if (actions.length) {
                const injectCobuildProofResult = (0, witnessLayout_1.injectCommonCobuildProof)({
                    txSkeleton: _txSkeleton,
                    actions,
                });
                _txSkeleton = injectCobuildProofResult.txSkeleton;
            }
            return _txSkeleton;
        },
        config,
    });
    txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    return {
        txSkeleton,
        outputIndices: sporeOutputIndices,
    };
}
exports.createMultipleSpores = createMultipleSpores;
//# sourceMappingURL=createSpore.js.map