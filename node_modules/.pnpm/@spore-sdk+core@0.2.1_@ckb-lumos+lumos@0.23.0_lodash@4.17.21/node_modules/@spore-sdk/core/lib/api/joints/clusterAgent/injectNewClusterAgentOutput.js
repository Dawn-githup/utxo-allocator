"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewClusterAgentOutput = void 0;
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const codec_1 = require("../../../codec");
const helpers_1 = require("../../../helpers");
const config_1 = require("../../../config");
const injectLiveClusterProxyReference_1 = require("../clusterProxy/injectLiveClusterProxyReference");
async function injectNewClusterAgentOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get the referenced ClusterProxy
    const clusterProxyCell = props.clusterProxyCell;
    const clusterProxyType = clusterProxyCell.cellOutput.type;
    if (!clusterProxyType || !(0, config_1.isSporeScriptSupported)(config, clusterProxyType, 'ClusterProxy')) {
        throw new Error('Cannot reference ClusterProxy because target cell is not a supported version of ClusterProxy');
    }
    // Reference the ClusterProxy directly or through a payment cell
    const injectLiveClusterProxyReferenceResult = await (0, injectLiveClusterProxyReference_1.injectLiveClusterProxyReference)({
        txSkeleton,
        cell: clusterProxyCell,
        referenceType: props.referenceType,
        paymentAmount: props.paymentAmount,
        capacityMargin: props.clusterProxy?.capacityMargin,
        updateWitness: props.clusterProxy?.updateWitness,
        updateOutput: props.clusterProxy?.updateOutput,
        config,
    });
    txSkeleton = injectLiveClusterProxyReferenceResult.txSkeleton;
    // Create ClusterAgent cell (the latest version)
    const clusterAgentScript = (0, config_1.getSporeScript)(config, 'ClusterAgent');
    const referencedClusterId = clusterProxyCell.data;
    let clusterAgentCell = (0, helpers_1.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...clusterAgentScript.script,
                args: referencedClusterId,
            },
        },
        data: (0, codec_1.packRawClusterAgentDataToHash)(clusterProxyType),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            clusterAgentCell = (0, helpers_1.setAbsoluteCapacityMargin)(clusterAgentCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            clusterAgentCell = props.updateOutput(clusterAgentCell);
        }
        return outputs.push(clusterAgentCell);
    });
    // Fix the index of the ClusterAgent in outputs to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Add ClusterAgent required cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, clusterAgentScript.cellDep);
    return {
        txSkeleton,
        outputIndex,
        reference: {
            referenceType: injectLiveClusterProxyReferenceResult.referenceType,
            clusterProxy: injectLiveClusterProxyReferenceResult.clusterProxy,
            payment: injectLiveClusterProxyReferenceResult.payment,
        },
    };
}
exports.injectNewClusterAgentOutput = injectNewClusterAgentOutput;
//# sourceMappingURL=injectNewClusterAgentOutput.js.map