"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectLiveMutantReferences = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const codec_1 = require("../../../codec");
const helpers_1 = require("../../../helpers");
const config_1 = require("../../../config");
const getMutant_1 = require("./getMutant");
async function injectLiveMutantReferences(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    let txSkeleton = props.txSkeleton;
    // Mutant Ids/Cells
    const mutantIds = Array.isArray(props.mutantIds) ? props.mutantIds : [props.mutantIds];
    const mutantCells = await Promise.all(mutantIds.map((id) => (0, getMutant_1.getMutantById)(id, config)));
    // Payment cell output indices
    const outputIndices = [];
    /**
     * Minimal payment amounts to each Mutant's lock script
     *
     * Note that this version of "minimalPaymentsMap" logic could need some notes, take an example:
     * - Creating a Spore that references Mutant 1 and Mutant 2
     * - Mutant 1, lock = A, minPayment = 100 CKB
     * - Mutant 2, lock = A, minPayment = 1000 CKB
     * Normally you would expect to pay A 1100 CKB in this transaction:
     * - Minimal payment to A = 100 + 1000 = 1100 CKB
     */
    const minimalPaymentsMap = mutantCells.reduce((sum, mutantCell) => {
        const mutantLock = mutantCell.cellOutput.lock;
        const mutantLockHash = lumos_1.utils.computeScriptHash(mutantLock);
        if (sum[mutantLockHash] === void 0) {
            sum[mutantLockHash] = {
                cell: mutantCell,
                lock: mutantLock,
                minPayment: lumos_1.BI.from(0),
                minLockCapacity: (0, helpers_1.minimalCellCapacityByLock)(mutantLock),
            };
        }
        const args = (0, codec_1.unpackToRawMutantArgs)(mutantCell.cellOutput.type.args);
        const minPayment = args.minPayment !== void 0 ? args.minPayment : lumos_1.BI.from(0);
        // Current logic: max(minPayment1, minPayment2, ...)
        // sum[mutantLockHash].minPayment = sum[mutantLockHash].minPayment.gt(minPayment)
        //   ? sum[mutantLockHash].minPayment
        //   : minPayment;
        // Alternative logic: sum(minPayment1, minPayment2, ...)
        sum[mutantLockHash].minPayment = sum[mutantLockHash].minPayment.add(minPayment);
        return sum;
    }, {});
    // Create payment cells for referencing the Mutants
    for (const info of Object.values(minimalPaymentsMap)) {
        // If no payment required, skip the Mutant
        if (info.minPayment.eq(0)) {
            continue;
        }
        // Calculate how much to pay to the owner of the Mutant
        const requiredPayment = info.minPayment.gt(info.minLockCapacity) ? info.minPayment : info.minLockCapacity;
        const paymentAmount = lumos_1.BI.from(props.paymentAmount ? props.paymentAmount(requiredPayment, info.lock, info.cell) : requiredPayment);
        if (paymentAmount.lt(requiredPayment)) {
            throw new Error(`Cannot pay to reference Mutant because paymentAmount is too low, required: ${requiredPayment.toString()}, actual: ${paymentAmount.toString()}`);
        }
        // Generate payment cell to the owner of the Mutant
        const outputIndex = txSkeleton.get('outputs').size;
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            outputIndices.push(outputIndex);
            return outputs.push({
                cellOutput: {
                    capacity: paymentAmount.toHexString(),
                    lock: info.lock,
                },
                data: '0x',
            });
        });
        // Fix the payment cell's output index to prevent it from future reduction
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: outputIndex,
            });
        });
    }
    // Add Mutant's type as cellDep
    const mutantScript = (0, config_1.getSporeScript)(config, 'Mutant');
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, mutantScript.cellDep);
    const luaScript = (0, config_1.getSporeScript)(config, 'Lua');
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, luaScript.cellDep);
    // Add Mutant cells as cellDeps
    for (const mutantCell of mutantCells) {
        txSkeleton = (0, helper_1.addCellDep)(txSkeleton, {
            outPoint: mutantCell.outPoint,
            depType: 'code',
        });
    }
    return {
        txSkeleton,
        referenceType: outputIndices.length > 0 ? 'payment' : 'none',
        payment: outputIndices.length > 0 ? { outputIndices } : void 0,
    };
}
exports.injectLiveMutantReferences = injectLiveMutantReferences;
//# sourceMappingURL=injectLiveMutantReferences.js.map