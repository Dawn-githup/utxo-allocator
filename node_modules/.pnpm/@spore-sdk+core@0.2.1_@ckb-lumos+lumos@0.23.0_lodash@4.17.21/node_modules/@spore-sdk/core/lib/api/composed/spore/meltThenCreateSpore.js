"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.meltMultipleThenCreateSpore = exports.meltThenCreateSpore = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const helpers_1 = require("@ckb-lumos/lumos/helpers");
const utils_1 = require("@ckb-lumos/lumos/utils");
const __1 = require("../..");
const cobuild_1 = require("../../../cobuild");
const config_1 = require("../../../config");
const helpers_2 = require("../../../helpers");
function InjectCobuildForMeltThenCreateSpore(meltSporeInputIndexs, mintSporeCell, mintSporeReference, mintSporeOutputIndex, txSkeleton, config) {
    const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', mintSporeCell.cellOutput.type);
    if (sporeScript.behaviors?.cobuild) {
        const actions = [];
        for (const meltIndex of meltSporeInputIndexs) {
            const meltActionResults = (0, cobuild_1.generateMeltSporeAction)({ txSkeleton, inputIndex: meltIndex });
            actions.push(...meltActionResults.actions);
        }
        const mintActionResult = (0, cobuild_1.generateCreateSporeAction)({
            txSkeleton,
            reference: mintSporeReference,
            outputIndex: mintSporeOutputIndex,
        });
        actions.push(...mintActionResult.actions);
        const injectCobuildProofResult = (0, cobuild_1.injectCommonCobuildProof)({
            txSkeleton,
            actions,
        });
        txSkeleton = injectCobuildProofResult.txSkeleton;
    }
    return txSkeleton;
}
async function meltThenCreateSpore(props) {
    /**
     * Melt Spore with Spore Outputpoint
     */
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const capacityMargin = lumos_1.BI.from(props.capacityMargin ?? 1_0000_0000);
    const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;
    // MeltTransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Insert input cells in advance for particular purpose
    if (props.prefixInputs) {
        for (const cell of props.prefixInputs) {
            const address = (0, helpers_1.encodeToAddress)(cell.cellOutput.lock, { config: config.lumos });
            const customScript = {
                script: cell.cellOutput.lock,
                customData: cell.data,
            };
            if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
                props.fromInfos.push(address);
            }
            const setupCellResult = await (0, helpers_2.setupCell)({
                txSkeleton,
                input: cell,
                updateWitness: props.updateWitness,
                defaultWitness: props.defaultWitness,
                config: config.lumos,
            });
            txSkeleton = setupCellResult.txSkeleton;
        }
    }
    // Insert output cells in advance for particular purpose
    if (props.prefixOutputs) {
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            props.prefixOutputs.forEach((cell) => (outputs = outputs.push(cell)));
            return outputs;
        });
    }
    // Apply `fromInfos` in advance if `postInputs` is provided
    if (props.postInputs) {
        for (const cell of props.postInputs) {
            const address = (0, helpers_1.encodeToAddress)(cell.cellOutput.lock, { config: config.lumos });
            const customScript = {
                script: cell.cellOutput.lock,
                customData: cell.data,
            };
            if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
                props.fromInfos.push(address);
            }
        }
    }
    // Inject live spore to Transaction.inputs
    const meltSporeCell = await (0, __1.getSporeByOutPoint)(props.outPoint, config);
    const injectLiveSporeCellResult = await (0, __1.injectLiveSporeCell)({
        txSkeleton,
        cell: meltSporeCell,
        updateWitness: props.updateWitness,
        defaultWitness: props.defaultWitness,
        since: props.since,
        config,
    });
    txSkeleton = injectLiveSporeCellResult.txSkeleton;
    /**
     * Create Spore
     */
    // If referencing a ClusterAgent, get it from the OutPoint
    let clusterAgentCell;
    if (props.clusterAgentOutPoint) {
        clusterAgentCell = await (0, __1.getClusterAgentByOutPoint)(props.clusterAgentOutPoint, config);
    }
    const prefixOutputLocks = props.prefixOutputs ? props.prefixOutputs.map((cell) => cell.cellOutput.lock) : [];
    const postOutputLocks = props.postOutputs ? props.postOutputs.map((cell) => cell.cellOutput.lock) : [];
    const injectNewSporeResult = await (0, __1.injectNewSporeOutput)({
        txSkeleton,
        data: props.data,
        toLock: props.toLock,
        fromInfos: props.fromInfos,
        extraOutputLocks: prefixOutputLocks.concat(postOutputLocks),
        changeAddress: props.changeAddress,
        updateOutput: props.updateOutput,
        clusterAgent: props.clusterAgent,
        cluster: props.cluster,
        mutant: props.mutant,
        clusterAgentCell,
        capacityMargin,
        config,
    });
    txSkeleton = injectNewSporeResult.txSkeleton;
    // Insert input cells in the end for particular purpose
    if (props.postInputs) {
        for (const cell of props.postInputs) {
            const setupCellResult = await (0, helpers_2.setupCell)({
                txSkeleton,
                input: cell,
                updateWitness: props.updateWitness,
                defaultWitness: props.defaultWitness,
                config: config.lumos,
            });
            txSkeleton = setupCellResult.txSkeleton;
        }
    }
    // Insert output cells in the end for particular purpose
    if (props.postOutputs) {
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            props.postOutputs.forEach((cell) => (outputs = outputs.push(cell)));
            return outputs;
        });
    }
    /**
     * check wether Redeem or Inject Capacity and then Pay fee
     */
    const snapshot = (0, helpers_2.createCapacitySnapshotFromTransactionSkeleton)(txSkeleton);
    if (snapshot.inputsCapacity.gt(snapshot.outputsCapacity)) {
        /**
         * Complete Co-Build WitnessLayout
         */
        txSkeleton = (0, __1.injectNewSporeIds)({
            outputIndices: [injectNewSporeResult.outputIndex],
            txSkeleton,
            config,
        });
        const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
        txSkeleton = InjectCobuildForMeltThenCreateSpore([injectLiveSporeCellResult.inputIndex], mintSporeCell, injectNewSporeResult.reference, injectNewSporeResult.outputIndex, txSkeleton, config);
        // Redeem capacity from the exceeded capacity
        const sporeAddress = lumos_1.helpers.encodeToAddress(mintSporeCell.cellOutput.lock, { config: config.lumos });
        const returnExceededCapacityAndPayFeeResult = await (0, helpers_2.returnExceededCapacityAndPayFee)({
            txSkeleton,
            changeAddress: props.changeAddress ?? sporeAddress,
            feeRate: props.feeRate,
            fromInfos: props.fromInfos,
            config,
        });
        txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
    }
    else {
        /**
         * Inject Capacity and Pay fee
         */
        const injectCapacityAndPayFeeResult = await (0, helpers_2.injectCapacityAndPayFee)({
            txSkeleton,
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            config,
            feeRate: props.feeRate,
            updateTxSkeletonAfterCollection(_txSkeleton) {
                // Generate and inject SporeID
                _txSkeleton = (0, __1.injectNewSporeIds)({
                    outputIndices: [injectNewSporeResult.outputIndex],
                    txSkeleton: _txSkeleton,
                    config,
                });
                /**
                 * Complete Co-Build WitnessLayout
                 */
                const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
                _txSkeleton = InjectCobuildForMeltThenCreateSpore([injectLiveSporeCellResult.inputIndex], mintSporeCell, injectNewSporeResult.reference, injectNewSporeResult.outputIndex, _txSkeleton, config);
                return _txSkeleton;
            },
        });
        txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    }
    // Make sure the tx size is in range (if needed)
    if (typeof maxTransactionSize === 'number') {
        (0, helpers_2.assertTransactionSkeletonSize)(txSkeleton, void 0, maxTransactionSize);
    }
    return {
        txSkeleton,
        inputIndex: injectLiveSporeCellResult.inputIndex,
        outputIndex: injectNewSporeResult.outputIndex,
        reference: injectNewSporeResult.reference,
        mutantReference: injectNewSporeResult.mutantReference,
    };
}
exports.meltThenCreateSpore = meltThenCreateSpore;
async function meltMultipleThenCreateSpore(props) {
    /**
     * Melt Spore with Spore Outputpoint
     */
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const capacityMargin = lumos_1.BI.from(props.capacityMargin ?? 1_0000_0000);
    const maxTransactionSize = props.maxTransactionSize ?? config.maxTransactionSize ?? false;
    // MeltTransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Insert input cells in advance for particular purpose
    if (props.prefixInputs) {
        for (const cell of props.prefixInputs) {
            const address = (0, helpers_1.encodeToAddress)(cell.cellOutput.lock, { config: config.lumos });
            const customScript = {
                script: cell.cellOutput.lock,
                customData: cell.data,
            };
            if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
                props.fromInfos.push(address);
            }
            const setupCellResult = await (0, helpers_2.setupCell)({
                txSkeleton,
                input: cell,
                updateWitness: props.updateWitness,
                defaultWitness: props.defaultWitness,
                config: config.lumos,
            });
            txSkeleton = setupCellResult.txSkeleton;
        }
    }
    // Insert output cells in advance for particular purpose
    if (props.prefixOutputs) {
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            props.prefixOutputs.forEach((cell) => (outputs = outputs.push(cell)));
            return outputs;
        });
    }
    // Apply `fromInfos` in advance if `postInputs` is provided
    if (props.postInputs) {
        for (const cell of props.postInputs) {
            const address = (0, helpers_1.encodeToAddress)(cell.cellOutput.lock, { config: config.lumos });
            const customScript = {
                script: cell.cellOutput.lock,
                customData: cell.data,
            };
            if (props.fromInfos.indexOf(address) < 0 && props.fromInfos.indexOf(customScript) < 0) {
                props.fromInfos.push(address);
            }
        }
    }
    // Inject live spore to Transaction.inputs
    let injectLiveSporeCellResults = [];
    for (const outPoint of props.outPoints) {
        const meltSporeCell = await (0, __1.getSporeByOutPoint)(outPoint, config);
        const injectLiveSporeCellResult = await (0, __1.injectLiveSporeCell)({
            txSkeleton,
            cell: meltSporeCell,
            updateWitness: props.updateWitness,
            defaultWitness: props.defaultWitness,
            since: props.since,
            config,
        });
        injectLiveSporeCellResults.push(injectLiveSporeCellResult);
        txSkeleton = injectLiveSporeCellResult.txSkeleton;
    }
    /**
     * Create Spore
     */
    // If referencing a ClusterAgent, get it from the OutPoint
    let clusterAgentCell;
    if (props.clusterAgentOutPoint) {
        clusterAgentCell = await (0, __1.getClusterAgentByOutPoint)(props.clusterAgentOutPoint, config);
    }
    const prefixOutputLocks = props.prefixOutputs ? props.prefixOutputs.map((cell) => cell.cellOutput.lock) : [];
    const postOutputLocks = props.postOutputs ? props.postOutputs.map((cell) => cell.cellOutput.lock) : [];
    const injectNewSporeResult = await (0, __1.injectNewSporeOutput)({
        txSkeleton,
        data: props.data,
        toLock: props.toLock,
        fromInfos: props.fromInfos,
        extraOutputLocks: prefixOutputLocks.concat(postOutputLocks),
        changeAddress: props.changeAddress,
        updateOutput: props.updateOutput,
        clusterAgent: props.clusterAgent,
        cluster: props.cluster,
        mutant: props.mutant,
        clusterAgentCell,
        capacityMargin,
        config,
    });
    txSkeleton = injectNewSporeResult.txSkeleton;
    // Insert input cells in the end for particular purpose
    if (props.postInputs) {
        for (const cell of props.postInputs) {
            const setupCellResult = await (0, helpers_2.setupCell)({
                txSkeleton,
                input: cell,
                updateWitness: props.updateWitness,
                defaultWitness: props.defaultWitness,
                config: config.lumos,
            });
            txSkeleton = setupCellResult.txSkeleton;
        }
    }
    // Insert output cells in the end for particular purpose
    if (props.postOutputs) {
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            props.postOutputs.forEach((cell) => (outputs = outputs.push(cell)));
            return outputs;
        });
    }
    /**
     * check wether Redeem or Inject Capacity and then Pay fee
     */
    const snapshot = (0, helpers_2.createCapacitySnapshotFromTransactionSkeleton)(txSkeleton);
    const feeRate = props.feeRate ?? (await (0, helpers_2.getMinFeeRate)(config.ckbNodeUrl));
    if (snapshot.inputsCapacity.gt(snapshot.outputsCapacity) &&
        snapshot.inputsCapacity.sub(snapshot.outputsCapacity).gt((0, utils_1.parseUnit)(feeRate.toString(), 'ckb'))) {
        /**
         * Complete Co-Build WitnessLayout
         */
        txSkeleton = (0, __1.injectNewSporeIds)({
            outputIndices: [injectNewSporeResult.outputIndex],
            txSkeleton,
            config,
        });
        const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
        // Redeem capacity from the exceeded capacity
        const sporeAddress = lumos_1.helpers.encodeToAddress(mintSporeCell.cellOutput.lock, { config: config.lumos });
        const returnExceededCapacityAndPayFeeResult = await (0, helpers_2.returnExceededCapacityAndPayFee)({
            txSkeleton,
            changeAddress: props.changeAddress ?? sporeAddress,
            feeRate: props.feeRate,
            fromInfos: props.fromInfos,
            config,
        });
        txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
        txSkeleton = InjectCobuildForMeltThenCreateSpore(injectLiveSporeCellResults.map((result) => result.inputIndex), mintSporeCell, injectNewSporeResult.reference, injectNewSporeResult.outputIndex, returnExceededCapacityAndPayFeeResult.txSkeleton, config);
    }
    else {
        /**
         * Inject Capacity and Pay fee
         */
        const injectCapacityAndPayFeeResult = await (0, helpers_2.injectCapacityAndPayFee)({
            txSkeleton,
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            config,
            feeRate: props.feeRate,
            updateTxSkeletonAfterCollection(_txSkeleton) {
                // Generate and inject SporeID
                _txSkeleton = (0, __1.injectNewSporeIds)({
                    outputIndices: [injectNewSporeResult.outputIndex],
                    txSkeleton: _txSkeleton,
                    config,
                });
                /**
                 * Complete Co-Build WitnessLayout
                 */
                const mintSporeCell = txSkeleton.get('outputs').get(injectNewSporeResult.outputIndex);
                _txSkeleton = InjectCobuildForMeltThenCreateSpore(injectLiveSporeCellResults.map((result) => result.inputIndex), mintSporeCell, injectNewSporeResult.reference, injectNewSporeResult.outputIndex, _txSkeleton, config);
                return _txSkeleton;
            },
        });
        txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    }
    // Make sure the tx size is in range (if needed)
    if (typeof maxTransactionSize === 'number') {
        (0, helpers_2.assertTransactionSkeletonSize)(txSkeleton, void 0, maxTransactionSize);
    }
    return {
        txSkeleton,
        inputIndexs: injectLiveSporeCellResults.map((item) => item.inputIndex),
        outputIndex: injectNewSporeResult.outputIndex,
        reference: injectNewSporeResult.reference,
        mutantReference: injectNewSporeResult.mutantReference,
    };
}
exports.meltMultipleThenCreateSpore = meltMultipleThenCreateSpore;
//# sourceMappingURL=meltThenCreateSpore.js.map