"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewSporeOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const lumos_1 = require("@ckb-lumos/lumos");
const helpers_1 = require("@ckb-lumos/lumos/helpers");
const codec_2 = require("../../../codec");
const config_1 = require("../../../config");
const helpers_2 = require("../../../helpers");
const helpers_3 = require("../../../helpers");
const helpers_4 = require("../../../helpers");
const getCluster_1 = require("../cluster/getCluster");
const injectLiveClusterReference_1 = require("../cluster/injectLiveClusterReference");
const injectLiveClusterAgentReference_1 = require("../clusterAgent/injectLiveClusterAgentReference");
const injectLiveMutantReferences_1 = require("../mutant/injectLiveMutantReferences");
const injectNewSporeIds_1 = require("./injectNewSporeIds");
async function injectNewSporeOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const sporeData = props.data;
    // TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Check should reference Cluster/ClusterAgent to the transaction
    const referencingCluster = !!sporeData.clusterId && !props.clusterAgentCell;
    const referencingClusterAgent = !!sporeData.clusterId && !!props.clusterAgentCell;
    // If referencing a Cluster, inject the Cluster or its LockProxy as reference
    let injectLiveClusterReferenceResult;
    const clusterCell = sporeData.clusterId ? await (0, getCluster_1.getClusterById)(sporeData.clusterId, config) : void 0;
    if (referencingCluster) {
        injectLiveClusterReferenceResult = await (0, injectLiveClusterReference_1.injectLiveClusterReference)({
            txSkeleton,
            cell: clusterCell,
            inputLocks: (0, helpers_4.composeInputLocks)({
                fromInfos: props.fromInfos,
                config: config.lumos,
            }),
            outputLocks: (0, helpers_4.composeOutputLocks)({
                outputLocks: props.extraOutputLocks ? props.extraOutputLocks.concat([props.toLock]) : [props.toLock],
                fromInfos: props.fromInfos,
                changeAddress: props.changeAddress,
                config: config.lumos,
            }),
            capacityMargin: props.cluster?.capacityMargin,
            updateOutput: props.cluster?.updateOutput,
            updateWitness: props.cluster?.updateWitness,
            defaultWitness: props.cluster?.defaultWitness,
            since: props.cluster?.since,
            config,
        });
        txSkeleton = injectLiveClusterReferenceResult.txSkeleton;
    }
    // If ClusterAgent is provided, inject the ClusterAgent or its LockProxy as reference
    let injectLiveClusterAgentReferenceResult;
    if (referencingClusterAgent) {
        injectLiveClusterAgentReferenceResult = await (0, injectLiveClusterAgentReference_1.injectLiveClusterAgentReference)({
            txSkeleton,
            cell: props.clusterAgentCell,
            inputLocks: (0, helpers_4.composeInputLocks)({
                fromInfos: props.fromInfos,
                config: config.lumos,
            }),
            outputLocks: (0, helpers_4.composeOutputLocks)({
                outputLocks: [props.toLock],
                fromInfos: props.fromInfos,
                changeAddress: props.changeAddress,
                config: config.lumos,
            }),
            capacityMargin: props.clusterAgent?.capacityMargin,
            updateOutput: props.clusterAgent?.updateOutput,
            updateWitness: props.clusterAgent?.updateWitness,
            defaultWitness: props.clusterAgent?.defaultWitness,
            since: props.clusterAgent?.since,
            config,
        });
        txSkeleton = injectLiveClusterAgentReferenceResult.txSkeleton;
        // Even if not referencing Cluster, still make sure Cluster related cellDeps are added
        const clusterType = clusterCell.cellOutput.type;
        const clusterScript = (0, config_1.getSporeScript)(config, 'Cluster', clusterType);
        if (!clusterType || !clusterScript) {
            throw new Error('Cannot reference Cluster because target cell is not a supported version of Cluster');
        }
        txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, clusterScript.cellDep);
        txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, {
            outPoint: clusterCell.outPoint,
            depType: 'code',
        });
    }
    // Validate SporeData.contentType
    const contentType = (0, helpers_2.setContentTypeParameters)(sporeData.contentType, sporeData.contentTypeParameters ?? {});
    const skipCheckContentType = props.skipCheckContentType ?? false;
    if (!skipCheckContentType && !(0, helpers_4.isContentTypeValid)(contentType)) {
        throw new Error(`Spore has specified an invalid data.contentType: ${contentType}`);
    }
    // Create Spore cell (the latest version)
    const sporeScript = (0, config_1.getSporeScript)(config, 'Spore');
    let sporeCell = (0, helpers_3.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...sporeScript.script,
                args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            },
        },
        data: codec_1.bytes.hexify((0, codec_2.packRawSporeData)({
            contentType,
            content: sporeData.content,
            clusterId: sporeData.clusterId,
        })),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            sporeCell = (0, helpers_3.setAbsoluteCapacityMargin)(sporeCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            sporeCell = props.updateOutput(sporeCell);
        }
        return outputs.push(sporeCell);
    });
    // Fix the cell's output index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Generate ID for the new Spore if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput !== void 0) {
        txSkeleton = (0, injectNewSporeIds_1.injectNewSporeIds)({
            outputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Inject Mutants as cellDeps, and inject payments if needed
    let injectLiveMutantReferencesResult;
    if (!skipCheckContentType) {
        const decodedContentType = (0, helpers_4.decodeContentType)(contentType);
        if (decodedContentType.parameters.mutant !== void 0) {
            injectLiveMutantReferencesResult = await (0, injectLiveMutantReferences_1.injectLiveMutantReferences)({
                txSkeleton,
                mutantIds: decodedContentType.parameters.mutant,
                paymentAmount: props.mutant?.paymentAmount,
                config,
            });
            txSkeleton = injectLiveMutantReferencesResult.txSkeleton;
        }
    }
    // Add Spore relevant cellDeps
    let sporeCelldep = sporeScript.cellDep;
    if (sporeScript.behaviors?.dynamicCelldep) {
        const scriptCell = await (0, helpers_2.getCellByType)({
            type: sporeScript.behaviors?.dynamicCelldep,
            indexer: new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl),
        });
        if (scriptCell) {
            sporeCelldep = {
                outPoint: scriptCell.outPoint,
                depType: 'code',
            };
        }
    }
    txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, sporeCelldep);
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
        reference: {
            referenceTarget: referencingCluster ? 'cluster' : referencingClusterAgent ? 'clusterAgent' : 'none',
            referenceType: referencingCluster
                ? injectLiveClusterReferenceResult.referenceType
                : referencingClusterAgent
                    ? injectLiveClusterAgentReferenceResult.referenceType
                    : void 0,
            cluster: injectLiveClusterReferenceResult?.cluster,
            clusterAgent: injectLiveClusterAgentReferenceResult?.clusterAgent,
        },
        mutantReference: injectLiveMutantReferencesResult
            ? {
                referenceType: injectLiveMutantReferencesResult.referenceType,
                payment: injectLiveMutantReferencesResult.payment,
            }
            : void 0,
    };
}
exports.injectNewSporeOutput = injectNewSporeOutput;
//# sourceMappingURL=injectNewSporeOutput.js.map