"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewClusterProxyOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const codec_2 = require("../../../codec");
const helpers_1 = require("../../../helpers");
const helpers_2 = require("../../../helpers");
const config_1 = require("../../../config");
const injectLiveClusterReference_1 = require("../cluster/injectLiveClusterReference");
const injectNewClusterProxyIds_1 = require("./injectNewClusterProxyIds");
async function injectNewClusterProxyOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get Referenced cluster cell
    const referencedClusterCell = props.clusterCell;
    const referencedClusterType = referencedClusterCell.cellOutput.type;
    if (!referencedClusterType || !(0, config_1.isSporeScriptSupported)(config, referencedClusterType, 'Cluster')) {
        throw new Error('Cannot reference Cluster because target cell is not a supported version of Cluster');
    }
    // Inject referenced cluster or its LockProxy
    const injectLiveClusterReferenceResult = await (0, injectLiveClusterReference_1.injectLiveClusterReference)({
        txSkeleton,
        cell: referencedClusterCell,
        inputLocks: (0, helpers_1.composeInputLocks)({
            fromInfos: props.fromInfos,
            config: config.lumos,
        }),
        outputLocks: (0, helpers_1.composeOutputLocks)({
            outputLocks: [props.toLock],
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            config: config.lumos,
        }),
        updateOutput: props.cluster?.updateOutput,
        updateWitness: props.cluster?.updateWitness,
        capacityMargin: props.cluster?.capacityMargin,
        config,
    });
    txSkeleton = injectLiveClusterReferenceResult.txSkeleton;
    // Create ClusterProxy cell (the latest version)
    const clusterProxyScript = (0, config_1.getSporeScript)(config, 'ClusterProxy');
    let clusterProxyCell = (0, helpers_2.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...clusterProxyScript.script,
                args: codec_1.bytes.hexify((0, codec_2.packRawClusterProxyArgs)({
                    id: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
                    minPayment: props.minPayment,
                })),
            },
        },
        data: referencedClusterType.args,
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            clusterProxyCell = (0, helpers_2.setAbsoluteCapacityMargin)(clusterProxyCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            clusterProxyCell = props.updateOutput(clusterProxyCell);
        }
        return outputs.push(clusterProxyCell);
    });
    // Fix the index of the ClusterProxy in outputs to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Generate ID for the new ClusterProxy if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput) {
        txSkeleton = (0, injectNewClusterProxyIds_1.injectNewClusterProxyIds)({
            outputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add ClusterProxy required dependencies
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, clusterProxyScript.cellDep);
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
        reference: {
            referenceType: injectLiveClusterReferenceResult.referenceType,
            cluster: injectLiveClusterReferenceResult.cluster,
        },
    };
}
exports.injectNewClusterProxyOutput = injectNewClusterProxyOutput;
//# sourceMappingURL=injectNewClusterProxyOutput.js.map