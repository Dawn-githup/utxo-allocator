"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectLiveClusterProxyReference = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const helpers_1 = require("../../../helpers");
const config_1 = require("../../../config");
const injectLiveClusterProxyCell_1 = require("./injectLiveClusterProxyCell");
const codec_1 = require("../../../codec");
async function injectLiveClusterProxyReference(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const isPaying = props.referenceType === 'payment';
    // TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get ClusterProxy cell
    const clusterProxyCell = props.cell;
    if (!clusterProxyCell.outPoint) {
        throw new Error(`Cannot inject ClusterProxy as reference because target cell has no OutPoint`);
    }
    // Get ClusterProxy's type script
    const clusterProxyType = clusterProxyCell.cellOutput.type;
    const clusterProxyScript = (0, config_1.getSporeScript)(config, 'ClusterProxy', clusterProxyType);
    if (!clusterProxyType || !clusterProxyScript) {
        throw new Error('Cannot inject ClusterProxy because target cell is not a supported version of ClusterProxy');
    }
    // Method #1: Paying capacity to the owner of the referenced ClusterProxy
    let paymentCellOutputIndex;
    if (isPaying) {
        const clusterProxyArgs = (0, codec_1.unpackToRawClusterProxyArgs)(clusterProxyType.args);
        const minPayment = clusterProxyArgs.minPayment !== void 0 ? clusterProxyArgs.minPayment : lumos_1.BI.from(0);
        if (minPayment.lte(0)) {
            throw new Error('Cannot pay to reference ClusterProxy because minPayment is undefined');
        }
        const minCellCapacity = (0, helpers_1.minimalCellCapacityByLock)(clusterProxyCell.cellOutput.lock);
        const requiredPayment = minPayment.gt(minCellCapacity) ? minPayment : minCellCapacity;
        const paymentAmount = lumos_1.BI.from(props.paymentAmount
            ? props.paymentAmount instanceof Function
                ? props.paymentAmount(requiredPayment)
                : props.paymentAmount
            : requiredPayment);
        if (paymentAmount.lt(requiredPayment)) {
            throw new Error(`Cannot pay to reference ClusterProxy because paymentAmount is too low, required: ${requiredPayment.toString()}, actual: ${paymentAmount.toString()}`);
        }
        const paymentCell = {
            cellOutput: {
                capacity: paymentAmount.toHexString(),
                lock: clusterProxyCell.cellOutput.lock,
            },
            data: '0x',
        };
        // Make sure the declared capacity is enough
        (0, helpers_1.assetCellMinimalCapacity)(paymentCell);
        // Add the payment cell to outputs
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            paymentCellOutputIndex = outputs.size;
            return outputs.push(paymentCell);
        });
        // Fix the payment cell's output index to prevent it from future reduction
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: paymentCellOutputIndex,
            });
        });
    }
    // Method #2: Reference the ClusterProxy directly into inputs/outputs
    let injectLiveClusterResult;
    if (!isPaying) {
        injectLiveClusterResult = await (0, injectLiveClusterProxyCell_1.injectLiveClusterProxyCell)({
            txSkeleton: txSkeleton,
            cell: clusterProxyCell,
            updateOutput: props.updateOutput,
            updateWitness: props.updateWitness,
            capacityMargin: props.capacityMargin,
            addOutput: true,
            config,
        });
        txSkeleton = injectLiveClusterResult.txSkeleton;
        // Fix the referenced cell's output index to prevent it from future reduction
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: injectLiveClusterResult.outputIndex,
            });
        });
    }
    // Add ClusterProxy relevant cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, clusterProxyScript.cellDep);
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, {
        outPoint: clusterProxyCell.outPoint,
        depType: 'code',
    });
    return {
        txSkeleton,
        referenceType: isPaying ? 'payment' : 'cell',
        clusterProxy: !isPaying && injectLiveClusterResult
            ? {
                inputIndex: injectLiveClusterResult.inputIndex,
                outputIndex: injectLiveClusterResult.outputIndex,
            }
            : void 0,
        payment: isPaying
            ? {
                outputIndex: paymentCellOutputIndex,
            }
            : void 0,
    };
}
exports.injectLiveClusterProxyReference = injectLiveClusterProxyReference;
//# sourceMappingURL=injectLiveClusterProxyReference.js.map