"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpackToRawMutantArgs = exports.packRawMutantArgs = exports.MutantArgsExact = exports.MutantArgsPower = void 0;
const bi_1 = require("@ckb-lumos/bi");
const base_1 = require("@ckb-lumos/base");
const codec_1 = require("@ckb-lumos/codec");
const utils_1 = require("./utils");
exports.MutantArgsPower = (0, codec_1.createBytesCodec)({
    pack(packable) {
        const id = base_1.blockchain.Byte32.pack(packable.id);
        const minPayment = utils_1.Uint8Opt.pack(packable.minPayment);
        const composed = new Uint8Array(id.length + minPayment.length);
        composed.set(id, 0);
        composed.set(minPayment, id.length);
        return composed;
    },
    unpack(unpackable) {
        const id = base_1.blockchain.Byte32.unpack(unpackable.slice(0, 32));
        const minPayment = utils_1.Uint8Opt.unpack(unpackable.slice(32, 33));
        return {
            id,
            minPayment: typeof minPayment === 'number' ? bi_1.BI.from(minPayment) : void 0,
        };
    },
});
exports.MutantArgsExact = (0, codec_1.createBytesCodec)({
    pack(packable) {
        const id = base_1.blockchain.Byte32.pack(packable.id);
        const minPayment = utils_1.Uint64Opt.pack(packable.minPayment);
        const composed = new Uint8Array(id.length + minPayment.length);
        composed.set(id, 0);
        composed.set(minPayment, id.length);
        return composed;
    },
    unpack(unpackable) {
        const id = base_1.blockchain.Byte32.unpack(unpackable.slice(0, 32));
        const minPayment = utils_1.Uint64Opt.unpack(unpackable.slice(32, 40));
        return {
            id,
            minPayment: typeof bi_1.BI.isBI(minPayment) ? minPayment : void 0,
        };
    },
});
function packRawMutantArgs(packable, version) {
    switch (version) {
        case 'power':
            return exports.MutantArgsPower.pack(packable);
        case 'exact':
        case void 0:
            return exports.MutantArgsExact.pack(packable);
        default:
            throw new Error(`Unsupported Mutant version: ${version}`);
    }
}
exports.packRawMutantArgs = packRawMutantArgs;
function unpackToRawMutantArgs(unpackable, version) {
    switch (version) {
        case 'power':
            return exports.MutantArgsPower.unpack(unpackable);
        case 'exact':
        case void 0:
            return exports.MutantArgsExact.unpack(unpackable);
        default:
            throw new Error(`Unsupported Mutant version: ${version}`);
    }
}
exports.unpackToRawMutantArgs = unpackToRawMutantArgs;
//# sourceMappingURL=mutant.js.map