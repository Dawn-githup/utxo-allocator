"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpackToRawClusterProxyArgs = exports.packRawClusterProxyArgs = exports.ClusterProxyArgsExact = exports.ClusterProxyArgsPower = void 0;
const bi_1 = require("@ckb-lumos/bi");
const base_1 = require("@ckb-lumos/base");
const codec_1 = require("@ckb-lumos/codec");
const utils_1 = require("./utils");
exports.ClusterProxyArgsPower = (0, codec_1.createBytesCodec)({
    pack(packable) {
        const id = base_1.blockchain.Byte32.pack(packable.id);
        const minPayment = utils_1.Uint8Opt.pack(packable.minPayment);
        const composed = new Uint8Array(id.length + minPayment.length);
        composed.set(id, 0);
        composed.set(minPayment, id.length);
        return composed;
    },
    unpack(unpackable) {
        const id = base_1.blockchain.Byte32.unpack(unpackable.slice(0, 32));
        const minPayment = utils_1.Uint8Opt.unpack(unpackable.slice(32, 33));
        return {
            id,
            minPayment: typeof minPayment === 'number' ? bi_1.BI.from(minPayment) : void 0,
        };
    },
});
exports.ClusterProxyArgsExact = (0, codec_1.createBytesCodec)({
    pack(packable) {
        const id = base_1.blockchain.Byte32.pack(packable.id);
        const minPayment = utils_1.Uint64Opt.pack(packable.minPayment);
        const composed = new Uint8Array(id.length + minPayment.length);
        composed.set(id, 0);
        composed.set(minPayment, id.length);
        return composed;
    },
    unpack(unpackable) {
        const id = base_1.blockchain.Byte32.unpack(unpackable.slice(0, 32));
        const minPayment = utils_1.Uint64Opt.unpack(unpackable.slice(32, 40));
        return {
            id,
            minPayment: typeof bi_1.BI.isBI(minPayment) ? minPayment : void 0,
        };
    },
});
function packRawClusterProxyArgs(packable, version) {
    switch (version) {
        case 'power':
            return exports.ClusterProxyArgsPower.pack(packable);
        case 'exact':
        case void 0:
            return exports.ClusterProxyArgsExact.pack(packable);
        default:
            throw new Error(`Unsupported ClusterProxy version: ${version}`);
    }
}
exports.packRawClusterProxyArgs = packRawClusterProxyArgs;
function unpackToRawClusterProxyArgs(unpackable, version) {
    switch (version) {
        case 'power':
            return exports.ClusterProxyArgsPower.unpack(unpackable);
        case 'exact':
        case void 0:
            return exports.ClusterProxyArgsExact.unpack(unpackable);
        default:
            throw new Error(`Unsupported ClusterProxy version: ${version}`);
    }
}
exports.unpackToRawClusterProxyArgs = unpackToRawClusterProxyArgs;
//# sourceMappingURL=clusterProxy.js.map