"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForMilliseconds = exports.retryWork = void 0;
/**
 * A util function to run a getter code and retry if it fails.
 * This is useful when you're fetching changes from the internet.
 */
function retryWork(props) {
    const isDynamicInterval = props.interval instanceof Function;
    const staticInterval = isDynamicInterval ? 100 : props.interval ?? 100;
    const delay = props.delay ?? 0;
    const maxRetry = props.retry ?? 3;
    const onError = props.onError ?? (() => true);
    const onComplete = props.onComplete ?? (() => true);
    return new Promise(async (resolve) => {
        // Record
        const startTime = Date.now();
        const errors = [];
        // Status
        let retries = 0;
        let result;
        let isRejected = false;
        let isCompleted = false;
        function dynamicInterval() {
            return props.interval({
                retries,
            });
        }
        async function event() {
            try {
                result = await props.getter();
                if (onComplete(result)) {
                    isCompleted = true;
                }
                else {
                    retries++;
                }
            }
            catch (e) {
                errors.push(e);
                if (await onError(e)) {
                    retries++;
                }
                else {
                    isRejected = true;
                }
            }
            if (isCompleted) {
                return resolve({
                    success: true,
                    result,
                    errors,
                    retries,
                    duration: Date.now() - startTime,
                });
            }
            if (isRejected || retries >= maxRetry) {
                return resolve({
                    success: false,
                    result: void 0,
                    errors,
                    retries,
                    duration: Date.now() - startTime,
                });
            }
            const interval = isDynamicInterval ? dynamicInterval() : staticInterval;
            setTimeout(() => event(), interval);
        }
        if (delay > 0) {
            await waitForMilliseconds(delay);
        }
        await event();
    });
}
exports.retryWork = retryWork;
function waitForMilliseconds(ms) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), ms);
    });
}
exports.waitForMilliseconds = waitForMilliseconds;
//# sourceMappingURL=retryWork.js.map