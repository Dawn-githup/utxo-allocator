import { BytesLike } from '@ckb-lumos/codec';
import { TDecodedMultipartMessage } from '@exact-realty/multipart-parser/dist/encodeMultipartMessage';
import { TTypedArray } from '@exact-realty/multipart-parser/dist/types';
export type AsyncableIterable<T> = AsyncIterable<T> | Iterable<T>;
export type ResolvedMultipartContent = {
    headers: Headers;
    body?: Uint8Array | null;
    parts?: ResolvedMultipartContent[] | null;
};
export declare function decodeMultipartContent(message: string, boundary: string): Promise<ResolvedMultipartContent[]>;
export declare function decodeMultipartContentFromBytes(buf: BytesLike, boundary: string): Promise<ResolvedMultipartContent[]>;
export declare function decodeMultipartContentFromStream<T extends TTypedArray>(stream: ReadableStream<T>, boundary: string): Promise<ResolvedMultipartContent[]>;
export declare function encodeMultipartContent(boundary: string, message: AsyncableIterable<TDecodedMultipartMessage>): Promise<{
    stream: ReadableStream<ArrayBuffer>;
    buffer: ArrayBuffer;
    bufferChunks: ArrayBuffer[];
    rawStringChunks: string[];
    byteLength: number;
    codeUnitLength: number;
}>;
export declare function readArrayBufferStream(stream: ReadableStream<ArrayBuffer>): Promise<{
    buffer: ArrayBuffer;
    bufferChunks: ArrayBuffer[];
    rawStringChunks: string[];
    byteLength: number;
    codeUnitLength: number;
}>;
export declare function isMultipartContentValid(message: string, boundary: string): Promise<boolean>;
export declare function isMultipartContentAsBytesValid(buf: BytesLike, boundary: string): Promise<boolean>;
