import { Cell, Hash, Script } from '@ckb-lumos/base';

type Json = Record<string, any>;
interface BaseApis {
    request<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
    post<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
    generateToken(): Promise<BtcAssetsApiToken>;
    init(force?: boolean): Promise<void>;
}
interface BaseApiRequestOptions extends RequestInit {
    params?: Json;
    method?: 'GET' | 'POST';
    requireToken?: boolean;
    allow404?: boolean;
}
interface BtcAssetsApiToken {
    token: string;
}
interface BtcAssetsApiContext {
    request: {
        url: string;
        body?: Json;
        params?: Json;
    };
    response: {
        status: number;
        data?: Json | string;
    };
}

interface BtcApis {
    getBtcBlockchainInfo(): Promise<BtcApiBlockchainInfo>;
    getBtcBlockByHash(blockHash: string): Promise<BtcApiBlock>;
    getBtcBlockHeaderByHash(blockHash: string): Promise<BtcApiBlockHeader>;
    getBtcBlockHashByHeight(blockHeight: number): Promise<BtcApiBlockHash>;
    getBtcBlockTransactionIdsByHash(blockHash: number): Promise<BtcApiBlockTransactionIds>;
    getBtcRecommendedFeeRates(): Promise<BtcApiRecommendedFeeRates>;
    getBtcBalance(address: string, params?: BtcApiBalanceParams): Promise<BtcApiBalance>;
    getBtcUtxos(address: string, params?: BtcApiUtxoParams): Promise<BtcApiUtxo[]>;
    getBtcTransactions(address: string, params?: BtcApiTransactionParams): Promise<BtcApiTransaction[]>;
    getBtcTransaction(txId: string): Promise<BtcApiTransaction>;
    sendBtcTransaction(txHex: string): Promise<BtcApiSentTransaction>;
}
interface BtcApiBlockchainInfo {
    chain: string;
    blocks: number;
    bestblockhash: number;
    difficulty: number;
    mediantime: number;
}
interface BtcApiBlock {
    id: string;
    height: number;
    version: number;
    timestamp: number;
    tx_count: number;
    size: number;
    weight: number;
    merkle_root: string;
    previousblockhash: string;
    mediantime: number;
    nonce: number;
    bits: number;
    difficulty: number;
}
interface BtcApiBlockHash {
    hash: string;
}
interface BtcApiBlockHeader {
    header: string;
}
interface BtcApiBlockTransactionIds {
    txids: string[];
}
interface BtcApiRecommendedFeeRates {
    fastestFee: number;
    halfHourFee: number;
    hourFee: number;
    economyFee: number;
    minimumFee: number;
}
interface BtcApiBalanceParams {
    min_satoshi?: number;
    no_cache?: boolean;
}
interface BtcApiBalance {
    address: string;
    satoshi: number;
    total_satoshi: number;
    available_satoshi: number;
    pending_satoshi: number;
    rgbpp_satoshi: number;
    dust_satoshi: number;
    utxo_count: number;
}
interface BtcApiUtxoParams {
    only_non_rgbpp_utxos?: boolean;
    only_confirmed?: boolean;
    min_satoshi?: number;
    no_cache?: boolean;
}
interface BtcApiUtxo {
    txid: string;
    vout: number;
    value: number;
    status: {
        confirmed: boolean;
        block_height: number;
        block_hash: string;
        block_time: number;
    };
}
interface BtcApiSentTransaction {
    txid: string;
}
interface BtcApiTransactionParams {
    after_txid?: string;
}
interface BtcApiTransaction {
    txid: string;
    version: number;
    locktime: number;
    vin: {
        txid: string;
        vout: number;
        prevout: {
            scriptpubkey: string;
            scriptpubkey_asm: string;
            scriptpubkey_type: string;
            scriptpubkey_address: string;
            value: number;
        };
        scriptsig: string;
        scriptsig_asm: string;
        witness: string[];
        is_coinbase: boolean;
        sequence: number;
    }[];
    vout: {
        scriptpubkey: string;
        scriptpubkey_asm: string;
        scriptpubkey_type: string;
        scriptpubkey_address: string;
        value: number;
    }[];
    weight: number;
    size: number;
    fee: number;
    status: {
        confirmed: boolean;
        block_height: number;
        block_hash: string;
        block_time: number;
    };
}

interface RgbppApis {
    getRgbppPaymasterInfo(): Promise<RgbppApiPaymasterInfo>;
    getRgbppTransactionHash(btcTxId: string): Promise<RgbppApiCkbTransactionHash>;
    getRgbppTransactionState(btcTxId: string): Promise<RgbppApiTransactionState>;
    getRgbppAssetsByBtcTxId(btcTxId: string): Promise<RgbppCell[]>;
    getRgbppAssetsByBtcUtxo(btcTxId: string, vout: number): Promise<RgbppCell[]>;
    getRgbppAssetsByBtcAddress(btcAddress: string, params?: RgbppApiAssetsByAddressParams): Promise<RgbppCell[]>;
    getRgbppBalanceByBtcAddress(btcAddress: string, params?: RgbppApiBalanceByAddressParams): Promise<RgbppApiBalance>;
    getRgbppSpvProof(btcTxId: string, confirmations: number): Promise<RgbppApiSpvProof>;
    sendRgbppCkbTransaction(payload: RgbppApiSendCkbTransactionPayload): Promise<RgbppApiTransactionState>;
    retryRgbppCkbTransaction(payload: RgbppApiRetryCkbTransactionPayload): Promise<RgbppApiTransactionRetry>;
}
type RgbppTransactionState = 'completed' | 'failed' | 'delayed' | 'active' | 'waiting';
interface RgbppApiPaymasterInfo {
    btc_address: string;
    fee: number;
}
interface RgbppApiCkbTransactionHash {
    txhash: string;
}
interface RgbppApiTransactionStateParams {
    with_data?: boolean;
}
interface RgbppApiTransactionState {
    state: RgbppTransactionState;
    attempts: number;
    failedReason?: string;
    data?: {
        txid: string;
        ckbVirtualResult: {
            ckbRawTx: CKBComponents.RawTransaction;
            needPaymasterCell: boolean;
            sumInputsCapacity: string;
            commitment: string;
        };
    };
}
interface RgbppCell extends Cell {
    typeHash?: Hash;
}
interface RgbppApiAssetsByAddressParams {
    type_script?: string;
    no_cache?: boolean;
}
interface RgbppApiBalanceByAddressParams {
    type_script?: string;
    no_cache?: boolean;
}
interface RgbppApiBalance {
    address: string;
    xudt: RgbppApiXudtBalance[];
}
interface RgbppApiXudtBalance {
    name: string;
    decimal: number;
    symbol: string;
    total_amount: string;
    available_amount: string;
    pending_amount: string;
    type_hash: string;
    type_script: Script;
}
interface RgbppApiSpvProof {
    proof: string;
    spv_client: {
        tx_hash: string;
        index: string;
    };
}
interface RgbppApiSendCkbTransactionPayload {
    btc_txid: string;
    ckb_virtual_result: {
        ckbRawTx: CKBComponents.RawTransaction;
        needPaymasterCell: boolean;
        sumInputsCapacity: string;
        commitment: string;
    } | string;
}
interface RgbppApiRetryCkbTransactionPayload {
    btc_txid: string;
}
interface RgbppApiTransactionRetry {
    success: boolean;
    state: RgbppTransactionState;
}

declare enum ErrorCodes {
    UNKNOWN = 0,
    ASSETS_API_RESPONSE_ERROR = 1,
    ASSETS_API_UNAUTHORIZED = 2,
    ASSETS_API_INVALID_PARAM = 3,
    ASSETS_API_RESOURCE_NOT_FOUND = 4,
    ASSETS_API_RESPONSE_DECODE_ERROR = 5
}
declare const ErrorMessages: {
    0: string;
    2: string;
    3: string;
    1: string;
    4: string;
    5: string;
};
declare class BtcAssetsApiError extends Error {
    code: ErrorCodes;
    message: string;
    context?: BtcAssetsApiContext;
    constructor(payload: {
        code: ErrorCodes;
        message?: string;
        context?: BtcAssetsApiContext;
    });
    static withComment(code: ErrorCodes, comment?: string, context?: BtcAssetsApiContext): BtcAssetsApiError;
}

/**
 * Check if target string is a valid domain.
 * @exmaple
 * isDomain('google.com') // => true
 * isDomain('https://google.com') // => false
 * isDomain('localhost') // => false
 * isDomain('localhost', true) // => true
 */
declare function isDomain(domain: string, allowLocalhost?: boolean): boolean;

declare class BtcAssetsApiBase implements BaseApis {
    url: string;
    app?: string;
    domain?: string;
    origin?: string;
    private token?;
    constructor(props: {
        url: string;
        app?: string;
        domain?: string;
        origin?: string;
        token?: string;
    });
    request<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
    post<T>(route: string, options?: BaseApiRequestOptions): Promise<T>;
    generateToken(): Promise<BtcAssetsApiToken>;
    init(force?: boolean): Promise<void>;
}

declare class BtcAssetsApi extends BtcAssetsApiBase implements BtcApis, RgbppApis {
    /**
     * Base
     */
    static fromToken(url: string, token: string, origin?: string): BtcAssetsApi;
    /**
     * Bitcoin APIs, under the /bitcoin/v1 prefix.
     */
    getBtcBlockchainInfo(): Promise<BtcApiBlockchainInfo>;
    getBtcBlockByHash(blockHash: string): Promise<BtcApiBlock>;
    getBtcBlockHeaderByHash(blockHash: string): Promise<BtcApiBlockHeader>;
    getBtcBlockHashByHeight(height: number): Promise<BtcApiBlockHash>;
    getBtcBlockTransactionIdsByHash(blockHash: number): Promise<BtcApiBlockTransactionIds>;
    getBtcRecommendedFeeRates(): Promise<BtcApiRecommendedFeeRates>;
    getBtcBalance(address: string, params?: BtcApiBalanceParams): Promise<BtcApiBalance>;
    getBtcUtxos(address: string, params?: BtcApiUtxoParams): Promise<BtcApiUtxo[]>;
    getBtcTransactions(address: string, params?: BtcApiTransactionParams): Promise<BtcApiTransaction[]>;
    getBtcTransaction(txId: string): Promise<BtcApiTransaction>;
    sendBtcTransaction(txHex: string): Promise<BtcApiSentTransaction>;
    /**
     * RGBPP APIs, under the /rgbpp/v1 prefix.
     */
    getRgbppPaymasterInfo(): Promise<RgbppApiPaymasterInfo>;
    getRgbppTransactionHash(btcTxId: string): Promise<RgbppApiCkbTransactionHash>;
    getRgbppTransactionState(btcTxId: string, params?: RgbppApiTransactionStateParams): Promise<RgbppApiTransactionState>;
    getRgbppAssetsByBtcTxId(btcTxId: string): Promise<RgbppCell[]>;
    getRgbppAssetsByBtcUtxo(btcTxId: string, vout: number): Promise<RgbppCell[]>;
    getRgbppAssetsByBtcAddress(btcAddress: string, params?: RgbppApiAssetsByAddressParams): Promise<RgbppCell[]>;
    getRgbppBalanceByBtcAddress(btcAddress: string, params?: RgbppApiBalanceByAddressParams): Promise<RgbppApiBalance>;
    getRgbppSpvProof(btcTxId: string, confirmations: number): Promise<RgbppApiSpvProof>;
    sendRgbppCkbTransaction(payload: RgbppApiSendCkbTransactionPayload): Promise<RgbppApiTransactionState>;
    retryRgbppCkbTransaction(payload: RgbppApiRetryCkbTransactionPayload): Promise<RgbppApiTransactionRetry>;
}

export { type BaseApiRequestOptions, type BaseApis, type BtcApiBalance, type BtcApiBalanceParams, type BtcApiBlock, type BtcApiBlockHash, type BtcApiBlockHeader, type BtcApiBlockTransactionIds, type BtcApiBlockchainInfo, type BtcApiRecommendedFeeRates, type BtcApiSentTransaction, type BtcApiTransaction, type BtcApiTransactionParams, type BtcApiUtxo, type BtcApiUtxoParams, type BtcApis, BtcAssetsApi, BtcAssetsApiBase, type BtcAssetsApiContext, BtcAssetsApiError, type BtcAssetsApiToken, ErrorCodes, ErrorMessages, type Json, type RgbppApiAssetsByAddressParams, type RgbppApiBalance, type RgbppApiBalanceByAddressParams, type RgbppApiCkbTransactionHash, type RgbppApiPaymasterInfo, type RgbppApiRetryCkbTransactionPayload, type RgbppApiSendCkbTransactionPayload, type RgbppApiSpvProof, type RgbppApiTransactionRetry, type RgbppApiTransactionState, type RgbppApiTransactionStateParams, type RgbppApiXudtBalance, type RgbppApis, type RgbppCell, type RgbppTransactionState, isDomain };
