"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferMutant = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
const __1 = require("../..");
async function transferMutant(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;
    // Check capacity margin related props
    if (!useCapacityMarginAsFee && !props.fromInfos?.length) {
        throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
    }
    if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
        throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacityMargin of the cell');
    }
    // TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Find Mutant by OutPoint
    const mutantCell = await (0, __1.getMutantByOutPoint)(props.outPoint, config);
    // Add Mutant to inputs and outputs of the Transaction
    const injectLiveMutantCellResult = await (0, __1.injectLiveMutantCell)({
        txSkeleton,
        cell: mutantCell,
        addOutput: true,
        updateOutput(cell) {
            cell.cellOutput.lock = props.toLock;
            if (props.updateOutput instanceof Function) {
                cell = props.updateOutput(cell);
            }
            return cell;
        },
        minPayment: props.minPayment,
        capacityMargin: props.capacityMargin,
        defaultWitness: props.defaultWitness,
        updateWitness: props.updateWitness,
        since: props.since,
        config,
    });
    txSkeleton = injectLiveMutantCellResult.txSkeleton;
    if (!useCapacityMarginAsFee) {
        // Inject needed capacity and pay fee
        const injectCapacityAndPayFeeResult = await (0, helpers_1.injectCapacityAndPayFee)({
            txSkeleton,
            changeAddress: props.changeAddress,
            fromInfos: props.fromInfos,
            feeRate: props.feeRate,
            config,
        });
        txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    }
    else {
        // Pay fee by the target cell's capacity margin
        txSkeleton = await (0, helpers_1.payFeeByOutput)({
            outputIndex: injectLiveMutantCellResult.outputIndex,
            txSkeleton,
            config,
        });
    }
    return {
        txSkeleton,
        inputIndex: injectLiveMutantCellResult.inputIndex,
        outputIndex: injectLiveMutantCellResult.outputIndex,
    };
}
exports.transferMutant = transferMutant;
//# sourceMappingURL=transferMutant.js.map