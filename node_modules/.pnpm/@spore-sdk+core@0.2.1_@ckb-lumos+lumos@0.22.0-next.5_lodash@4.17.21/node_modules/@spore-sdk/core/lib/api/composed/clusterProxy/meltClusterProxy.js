"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.meltClusterProxy = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const helpers_1 = require("../../../helpers");
const config_1 = require("../../../config");
const cobuild_1 = require("../../../cobuild");
const __1 = require("../..");
async function meltClusterProxy(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    // TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Get ClusterProxy cell
    const clusterProxyCell = await (0, __1.getClusterProxyByOutPoint)(props.outPoint, config);
    const clusterProxyScript = (0, config_1.getSporeScript)(config, 'ClusterProxy', clusterProxyCell.cellOutput.type);
    // Inject live spore to Transaction.inputs
    const injectLiveClusterProxyCellResult = await (0, __1.injectLiveClusterProxyCell)({
        txSkeleton,
        cell: clusterProxyCell,
        updateWitness: props.updateWitness,
        config,
    });
    txSkeleton = injectLiveClusterProxyCellResult.txSkeleton;
    // Inject CobuildProof
    if (clusterProxyScript.behaviors?.cobuild) {
        const actionResult = (0, cobuild_1.generateMeltClusterProxyAction)({
            txSkeleton,
            inputIndex: injectLiveClusterProxyCellResult.inputIndex,
        });
        const injectCobuildProofResult = (0, cobuild_1.injectCommonCobuildProof)({
            txSkeleton,
            actions: actionResult.actions,
        });
        txSkeleton = injectCobuildProofResult.txSkeleton;
    }
    // Redeem occupied capacity from the melted cell
    const targetCellAddress = lumos_1.helpers.encodeToAddress(clusterProxyCell.cellOutput.lock, { config: config.lumos });
    const returnExceededCapacityAndPayFeeResult = await (0, helpers_1.returnExceededCapacityAndPayFee)({
        changeAddress: props.changeAddress ?? targetCellAddress,
        txSkeleton,
        config,
    });
    txSkeleton = returnExceededCapacityAndPayFeeResult.txSkeleton;
    return {
        txSkeleton,
        inputIndex: injectLiveClusterProxyCellResult.inputIndex,
    };
}
exports.meltClusterProxy = meltClusterProxy;
//# sourceMappingURL=meltClusterProxy.js.map