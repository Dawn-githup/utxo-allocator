"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferMultipleSpore = exports.transferSpore = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const __1 = require("../..");
const cobuild_1 = require("../../../cobuild");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
async function transferSpore(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;
    // Check capacity margin related props
    if (!useCapacityMarginAsFee && !props.fromInfos) {
        throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
    }
    if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
        throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacity margin of the spore');
    }
    // TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    // Inject live spore to Transaction.inputs and Transaction.outputs
    const sporeCell = await (0, __1.getSporeByOutPoint)(props.outPoint, config);
    const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', sporeCell.cellOutput.type);
    const injectLiveSporeCellResult = await (0, __1.injectLiveSporeCell)({
        txSkeleton,
        cell: sporeCell,
        addOutput: true,
        updateOutput(cell) {
            cell.cellOutput.lock = props.toLock;
            if (props.updateOutput instanceof Function) {
                cell = props.updateOutput(cell);
            }
            return cell;
        },
        capacityMargin: props.capacityMargin,
        defaultWitness: props.defaultWitness,
        updateWitness: props.updateWitness,
        since: props.since,
        config,
    });
    txSkeleton = injectLiveSporeCellResult.txSkeleton;
    // Generate TransferSpore actions
    const actionResult = (0, cobuild_1.generateTransferSporeAction)({
        txSkeleton,
        inputIndex: injectLiveSporeCellResult.inputIndex,
        outputIndex: injectLiveSporeCellResult.outputIndex,
    });
    if (!useCapacityMarginAsFee) {
        // Inject needed capacity from fromInfos and pay fee
        const injectCapacityAndPayFeeResult = await (0, helpers_1.injectCapacityAndPayFee)({
            txSkeleton,
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            feeRate: props.feeRate,
            updateTxSkeletonAfterCollection(_txSkeleton) {
                // Inject CobuildProof
                if (sporeScript.behaviors?.cobuild) {
                    const injectCobuildProofResult = (0, cobuild_1.injectCommonCobuildProof)({
                        txSkeleton: _txSkeleton,
                        actions: actionResult.actions,
                    });
                    _txSkeleton = injectCobuildProofResult.txSkeleton;
                }
                return _txSkeleton;
            },
            config,
        });
        txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    }
    else {
        // Inject CobuildProof
        if (sporeScript.behaviors?.cobuild) {
            const injectCobuildProofResult = (0, cobuild_1.injectCommonCobuildProof)({
                txSkeleton: txSkeleton,
                actions: actionResult.actions,
            });
            txSkeleton = injectCobuildProofResult.txSkeleton;
        }
        // Pay fee by the spore cell's capacity margin
        txSkeleton = await (0, helpers_1.payFeeByOutput)({
            outputIndex: injectLiveSporeCellResult.outputIndex,
            txSkeleton,
            config,
        });
    }
    return {
        txSkeleton,
        inputIndex: injectLiveSporeCellResult.inputIndex,
        outputIndex: injectLiveSporeCellResult.outputIndex,
    };
}
exports.transferSpore = transferSpore;
// Transfer multiple Spore at once
async function transferMultipleSpore(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    const useCapacityMarginAsFee = props.useCapacityMarginAsFee ?? true;
    // Check capacity margin related props
    if (!useCapacityMarginAsFee && !props.fromInfos) {
        throw new Error('When useCapacityMarginAsFee is enabled, fromInfos is also required');
    }
    if (useCapacityMarginAsFee && props.capacityMargin !== void 0) {
        throw new Error('When useCapacityMarginAsFee is enabled, cannot set capacity margin of the spore');
    }
    // TransactionSkeleton
    let txSkeleton = lumos_1.helpers.TransactionSkeleton({
        cellProvider: indexer,
    });
    const injectLiveSporeCellResults = [];
    // Inject live spore to Transaction.inputs and Transaction.outputs
    for (const outPoint of props.outPoints) {
        const sporeCell = await (0, __1.getSporeByOutPoint)(outPoint, config);
        const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', sporeCell.cellOutput.type);
        const injectLiveSporeCellResult = await (0, __1.injectLiveSporeCell)({
            txSkeleton,
            cell: sporeCell,
            addOutput: true,
            updateOutput(cell) {
                cell.cellOutput.lock = props.toLock;
                if (props.updateOutput instanceof Function) {
                    cell = props.updateOutput(cell);
                }
                return cell;
            },
            capacityMargin: props.capacityMargin,
            defaultWitness: props.defaultWitness,
            updateWitness: props.updateWitness,
            since: props.since,
            config,
        });
        txSkeleton = injectLiveSporeCellResult.txSkeleton;
        injectLiveSporeCellResults.push(injectLiveSporeCellResult);
    }
    // Generate TransferSpore actions
    const actions = [];
    for (const injectLiveSporeCellResult of injectLiveSporeCellResults) {
        const actionResult = (0, cobuild_1.generateTransferSporeAction)({
            txSkeleton,
            inputIndex: injectLiveSporeCellResult.inputIndex,
            outputIndex: injectLiveSporeCellResult.outputIndex,
        });
        actions.push(...actionResult.actions);
    }
    if (!useCapacityMarginAsFee) {
        // Inject needed capacity from fromInfos and pay fee
        const injectCapacityAndPayFeeResult = await (0, helpers_1.injectCapacityAndPayFee)({
            txSkeleton,
            fromInfos: props.fromInfos,
            changeAddress: props.changeAddress,
            feeRate: props.feeRate,
            updateTxSkeletonAfterCollection(_txSkeleton) {
                // Inject CobuildProof
                const injectCobuildProofResult = (0, cobuild_1.injectCommonCobuildProof)({
                    txSkeleton: _txSkeleton,
                    actions: actions,
                });
                _txSkeleton = injectCobuildProofResult.txSkeleton;
                return _txSkeleton;
            },
            config,
        });
        txSkeleton = injectCapacityAndPayFeeResult.txSkeleton;
    }
    else {
        // Inject CobuildProof
        const injectCobuildProofResult = (0, cobuild_1.injectCommonCobuildProof)({
            txSkeleton: txSkeleton,
            actions: actions,
        });
        txSkeleton = injectCobuildProofResult.txSkeleton;
        // choose an output to pay the fee
        for (const item of injectLiveSporeCellResults) {
            // Pay fee by the spore cell's capacity margin
            try {
                const tkSkeletonNew = await (0, helpers_1.payFeeByOutput)({
                    outputIndex: item.outputIndex,
                    txSkeleton,
                    config,
                });
                txSkeleton = tkSkeletonNew;
                break;
            }
            catch {
                // if an error throwed, try next one, until it loops out
                continue;
            }
        }
    }
    return {
        txSkeleton,
        inputIndecies: injectLiveSporeCellResults.map((cell) => cell.inputIndex),
        outputIndecies: injectLiveSporeCellResults.map((cell) => cell.outputIndex),
    };
}
exports.transferMultipleSpore = transferMultipleSpore;
//# sourceMappingURL=transferSpore.js.map