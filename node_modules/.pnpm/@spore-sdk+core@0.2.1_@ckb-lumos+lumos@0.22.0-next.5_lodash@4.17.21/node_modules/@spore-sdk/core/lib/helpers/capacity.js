"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.returnExceededCapacity = exports.injectNeededCapacity = exports.calculateNeededCapacity = exports.correctChangeCellCapacity = exports.createCapacitySnapshot = exports.createCapacitySnapshotFromTransactionSkeleton = exports.getCellsTotalCapacity = exports.setAbsoluteCapacityMargin = exports.getCellCapacityMargin = exports.assetCellMinimalCapacity = exports.correctCellMinimalCapacity = exports.minimalCellCapacityByLock = void 0;
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const lumos_1 = require("@ckb-lumos/lumos");
const lib_1 = require("@ckb-lumos/common-scripts/lib");
const address_1 = require("./address");
const script_1 = require("./script");
/**
 * Calculate target cell's minimal occupied capacity by lock script.
 */
function minimalCellCapacityByLock(lock) {
    return lumos_1.helpers.minimalCellCapacityCompatible({
        cellOutput: {
            capacity: '0x0',
            lock,
        },
        data: '0x',
    });
}
exports.minimalCellCapacityByLock = minimalCellCapacityByLock;
/**
 * Fix cell's minimal occupied capacity by 'helpers.minimalCellCapacityCompatible' API.
 * Note: this function will modify the original cell object.
 */
function correctCellMinimalCapacity(cell) {
    const occupiedCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    if (!occupiedCapacity.eq(cell.cellOutput.capacity)) {
        cell.cellOutput.capacity = occupiedCapacity.toHexString();
    }
    return cell;
}
exports.correctCellMinimalCapacity = correctCellMinimalCapacity;
/**
 * Make sure the target cell has declared enough amount of capacity.
 */
function assetCellMinimalCapacity(cell) {
    const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    if (minimalCapacity.gt(cell.cellOutput.capacity)) {
        const minimal = minimalCapacity.toString();
        const declared = lumos_1.BI.from(cell.cellOutput.capacity).toString();
        throw new Error(`Target cell required capacity of ${minimal}, but declared ${declared}`);
    }
}
exports.assetCellMinimalCapacity = assetCellMinimalCapacity;
/**
 * Calculate the target cell's capacity margin.
 * Could be negative if the cell's declared capacity is not enough.
 */
function getCellCapacityMargin(cell) {
    const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    return lumos_1.BI.from(cell.cellOutput.capacity).sub(minimalCapacity);
}
exports.getCellCapacityMargin = getCellCapacityMargin;
/**
 * Set absolute capacity margin for a cell.
 * The term 'absolute' means the cell's capacity will be: 'minimal capacity' + 'capacity margin'.
 */
function setAbsoluteCapacityMargin(cell, capacityMargin) {
    cell = (0, cloneDeep_1.default)(cell);
    const currentMargin = getCellCapacityMargin(cell);
    const margin = capacityMargin instanceof Function ? capacityMargin(cell, currentMargin) : capacityMargin;
    const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(cell);
    cell.cellOutput.capacity = minimalCapacity.add(margin).toHexString();
    return cell;
}
exports.setAbsoluteCapacityMargin = setAbsoluteCapacityMargin;
/**
 * Count the total declared capacity in a List<Cell>.
 */
function getCellsTotalCapacity(cells) {
    return cells.reduce((sum, cell) => sum.add(cell.cellOutput.capacity), lumos_1.BI.from(0));
}
exports.getCellsTotalCapacity = getCellsTotalCapacity;
/**
 * Summarize the capacity/length difference between inputs/outputs of a TransactionSkeleton.
 * This is a sugar function of 'createCapacitySnapshot'.
 */
function createCapacitySnapshotFromTransactionSkeleton(txSkeleton) {
    return createCapacitySnapshot(txSkeleton.get('inputs').toArray(), txSkeleton.get('outputs').toArray());
}
exports.createCapacitySnapshotFromTransactionSkeleton = createCapacitySnapshotFromTransactionSkeleton;
/**
 * Summarize the capacity/length difference between inputs/outputs of a Transaction.
 */
function createCapacitySnapshot(inputs, outputs) {
    const inputsCapacity = getCellsTotalCapacity(inputs);
    const outputsCapacity = getCellsTotalCapacity(outputs);
    const inputsRemainCapacity = inputsCapacity.sub(outputsCapacity);
    const outputsRemainCapacity = outputsCapacity.sub(inputsCapacity);
    return {
        inputsLength: inputs.length,
        outputsLength: outputs.length,
        inputsCapacity,
        outputsCapacity,
        inputsRemainCapacity,
        outputsRemainCapacity,
    };
}
exports.createCapacitySnapshot = createCapacitySnapshot;
/**
 * Calculates the capacity different in inputs/outputs of a Transaction,
 * then fix the change cell's containing capacity if inputs' total capacity has any left.
 *
 * Note: normally the change cell is the last cell in Transaction.outputs,
 * but if things are different, you can also provide the change cell's output index.
 */
function correctChangeCellCapacity(props) {
    let txSkeleton = props.txSkeleton;
    const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
    if (snapshot.inputsRemainCapacity.gt(0)) {
        const outputIndex = props.changeOutputIndex ?? txSkeleton.get('outputs').size - 1;
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            const output = outputs.get(outputIndex);
            if (!output) {
                throw new Error('Cannot correct change cell capacity because Transaction.outputs is empty');
            }
            const oldCapacity = lumos_1.BI.from(output.cellOutput.capacity);
            output.cellOutput.capacity = oldCapacity.add(snapshot.inputsRemainCapacity).toHexString();
            return outputs;
        });
    }
    return txSkeleton;
}
exports.correctChangeCellCapacity = correctChangeCellCapacity;
/**
 * Calculate the capacity difference between inputs/outputs of a Transaction,
 * and see how much capacity is needed for the transaction to be constructed.
 */
function calculateNeededCapacity(props) {
    let txSkeleton = props.txSkeleton;
    const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
    const changeLock = lumos_1.helpers.parseAddress(props.changeAddress, { config: props.config });
    const extraCapacity = lumos_1.BI.from(props.extraCapacity ?? 0);
    const minChangeCapacity = minimalCellCapacityByLock(changeLock).add(extraCapacity);
    let exceedCapacity = snapshot.inputsRemainCapacity;
    let neededCapacity = snapshot.outputsRemainCapacity.add(extraCapacity);
    // Collect one more cell if:
    // 1. Has sufficient capacity for transaction construction
    // 2. Has insufficient capacity for adding a change cell to Transaction.outputs
    const sufficientForTransaction = neededCapacity.lte(0) && exceedCapacity.gt(0);
    const insufficientForChangeCell = exceedCapacity.lt(minChangeCapacity);
    if (sufficientForTransaction && insufficientForChangeCell) {
        neededCapacity = minChangeCapacity;
        exceedCapacity = lumos_1.BI.from(0);
    }
    if (neededCapacity.lt(0)) {
        neededCapacity = lumos_1.BI.from(0);
    }
    if (exceedCapacity.lt(0)) {
        exceedCapacity = lumos_1.BI.from(0);
    }
    return {
        snapshot,
        neededCapacity,
        exceedCapacity,
    };
}
exports.calculateNeededCapacity = calculateNeededCapacity;
/**
 * Calculate the minimal required capacity for the transaction to be constructed,
 * and then collect cells to inputs, it also fills cellDeps and witnesses.
 * After collecting, it will generate an output to return unused ckb.
 */
async function injectNeededCapacity(props) {
    let txSkeleton = props.txSkeleton;
    const config = props.config;
    const changeAddress = (0, address_1.fromInfoToAddress)(props.changeAddress ?? props.fromInfos[0], config);
    // Calculate needed or exceeded capacity
    const calculated = calculateNeededCapacity({
        extraCapacity: props.extraCapacity,
        changeAddress,
        txSkeleton,
        config,
    });
    const before = calculated.snapshot;
    let after;
    // Collect needed capacity using `common.injectCapacity` API from lumos
    if (calculated.neededCapacity.gt(0)) {
        txSkeleton = await lib_1.common.injectCapacity(txSkeleton, props.fromInfos, calculated.neededCapacity, props.changeAddress, void 0, {
            enableDeductCapacity: props.enableDeductCapacity,
            config: props.config,
        });
        after = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
    }
    // If no needed capacity, and has exceeded capacity to be return as change
    if (calculated.neededCapacity.lte(0) && calculated.exceedCapacity.gt(0)) {
        const returnResult = returnExceededCapacity({
            txSkeleton,
            changeAddress,
            config,
        });
        if (returnResult.returnedChange) {
            txSkeleton = returnResult.txSkeleton;
        }
    }
    return {
        txSkeleton,
        before,
        after,
    };
}
exports.injectNeededCapacity = injectNeededCapacity;
/**
 * Return exceeded capacity in Transaction.inputs to Transaction.outputs as change.
 * The strategy is:
 * - If there is an unfixed last output with the same lock as change lock, then add the exceeded capacity to it.
 * - If no unfixed output with the same lock as change lock was found, generate a change cell to Transaction.outputs.
 */
function returnExceededCapacity(props) {
    // Summary inputs/outputs capacity status
    let txSkeleton = props.txSkeleton;
    const snapshot = createCapacitySnapshotFromTransactionSkeleton(txSkeleton);
    // Status
    let returnedChange = false;
    let createdChangeCell = false;
    let changeCellOutputIndex = -1;
    let unreturnedCapacity = lumos_1.BI.from(0);
    // If no exceeded capacity, simply end the process
    if (snapshot.inputsRemainCapacity.lte(0)) {
        return {
            txSkeleton,
            returnedChange,
            createdChangeCell,
            changeCellOutputIndex,
            unreturnedCapacity,
        };
    }
    // If found any exceeded capacity
    returnedChange = true;
    const changeLock = lumos_1.helpers.parseAddress(props.changeAddress, {
        config: props.config,
    });
    // Find the last unfixed output with the same lock as change lock
    const fixedOutputs = txSkeleton
        .get('fixedEntries')
        .filter(({ field }) => field === 'outputs')
        .map(({ index }) => index);
    const matchLastOutputIndex = txSkeleton.get('outputs').findLastIndex((r, index) => {
        if (fixedOutputs.includes(index)) {
            return false;
        }
        else {
            return (0, script_1.isScriptValueEquals)(r.cellOutput.lock, changeLock) && r.cellOutput.type === void 0;
        }
    });
    if (matchLastOutputIndex > -1) {
        // If an unfixed output exists and its lock is the same as change lock,
        // then add the exceeded capacity to it.
        changeCellOutputIndex = matchLastOutputIndex;
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            const output = outputs.get(matchLastOutputIndex);
            output.cellOutput.capacity = lumos_1.BI.from(output.cellOutput.capacity).add(snapshot.inputsRemainCapacity).toHexString();
            return outputs.set(matchLastOutputIndex, output);
        });
    }
    else {
        // If no unfixed output with the same lock found in the outputs,
        // generate a change cell to Transaction.outputs.
        const changeCell = {
            cellOutput: {
                capacity: snapshot.inputsRemainCapacity.toHexString(),
                lock: changeLock,
            },
            data: '0x',
        };
        const minimalCapacity = lumos_1.helpers.minimalCellCapacityCompatible(changeCell);
        if (snapshot.inputsRemainCapacity.lt(minimalCapacity)) {
            unreturnedCapacity = snapshot.inputsRemainCapacity;
        }
        else {
            createdChangeCell = true;
            txSkeleton = txSkeleton.update('outputs', (outputs) => {
                changeCellOutputIndex = outputs.size;
                return outputs.push(changeCell);
            });
        }
    }
    return {
        txSkeleton,
        returnedChange,
        createdChangeCell,
        changeCellOutputIndex,
        unreturnedCapacity,
    };
}
exports.returnExceededCapacity = returnExceededCapacity;
//# sourceMappingURL=capacity.js.map