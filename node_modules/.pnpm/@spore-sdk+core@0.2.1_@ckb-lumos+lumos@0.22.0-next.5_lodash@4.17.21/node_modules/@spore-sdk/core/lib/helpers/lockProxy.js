"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.referenceCellOrLockProxy = void 0;
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const script_1 = require("./script");
async function referenceCellOrLockProxy(props) {
    // Env
    const addCellToCellDeps = props.addCellToCellDeps ?? true;
    // TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // The reference cell
    const cell = props.cell;
    const cellLock = cell.cellOutput.lock;
    if (!cell.outPoint) {
        throw new Error('Cannot reference cell because target cell has no OutPoint');
    }
    // Inputs/Outputs conditions
    const hasTargetLockInInputs = props.inputLocks.some((script) => {
        return (0, script_1.isScriptValueEquals)(cellLock, script);
    });
    const hasTargetLockInOutputs = props.outputLocks.some((script) => {
        return (0, script_1.isScriptValueEquals)(cellLock, script);
    });
    // Summarize conditions
    const referencedLockProxy = hasTargetLockInInputs && hasTargetLockInOutputs;
    const referencedCell = !hasTargetLockInInputs || !hasTargetLockInOutputs;
    console.log('referencedLockProxy = ', referencedLockProxy);
    // Inject the target cell's LockProxy to the transaction
    if (referencedLockProxy) {
        txSkeleton = await props.referenceLockProxy(txSkeleton);
    }
    // Inject the target cell directly to inputs & outputs
    if (referencedCell) {
        txSkeleton = await props.referenceCell(txSkeleton);
    }
    // Add the target cell as cell dep to cellDeps
    if (addCellToCellDeps) {
        txSkeleton = (0, helper_1.addCellDep)(txSkeleton, {
            outPoint: cell.outPoint,
            depType: 'code',
        });
    }
    return {
        txSkeleton,
        referencedCell,
        referencedLockProxy,
    };
}
exports.referenceCellOrLockProxy = referenceCellOrLockProxy;
//# sourceMappingURL=lockProxy.js.map