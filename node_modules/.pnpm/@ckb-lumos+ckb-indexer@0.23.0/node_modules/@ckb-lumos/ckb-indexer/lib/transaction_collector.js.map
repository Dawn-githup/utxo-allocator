{"version":3,"file":"transaction_collector.js","names":["_base","require","_ckbIndexerFilter","services","_interopRequireWildcard","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","CKBIndexerTransactionCollector","BaseIndexerModule","TransactionCollector","constructor","indexer","queries","CKBRpcUrl","options","defaultOptions","skipMissing","includeStatus","filterOptions","asBaseTransactionCollector","fetchIndexerTransaction","lastCursor","searchKeyFilter","sizeLimit","bufferSize","order","indexerTransactionList","objects","instanceOfScriptWrapper","lock","type","getTransactionByLockAndTypeIndependent","getTransactions","generateSearchKey","filterByTypeIoTypeAndLockIoType","getResolvedTransactionRequestPayload","unresolvedTransactionList","requestPayload","forEach","unresolvedTransaction","index","indexerTransaction","ioType","unresolvedOutPoint","transaction","inputs","Number","ioIndex","previousOutput","push","txHash","getResolvedCell","resolvedTransactionList","outputs","resolvedTransaction","find","tx","hash","Error","resolvedCell","filterTransaction","filteredTransactionList","filter","isCellScriptArgsValid","map","txStatus","cycles","timeAddedToPool","minReplaceFee","fee","length","getTransactionListFromRpc","requestBatchTransactionWithStatus","queryWithTypeAdditionOptions","queryWithLockAdditionOptions","lockLastCursor","typeLastCursor","split","queriesWithoutType","undefined","transactionByLock","queriesWithoutLock","transactionByType","intersection","transactionList1","transactionList2","result","tx1","tx2","item","targetTx","hashList","getDetailRequestData","hashItem","transactionList","then","response","isLockArgsLenMatched","args","argsLen","getHexStringBytes","targetCell","lockArgsLen","_targetCell$type","typeArgsLen","filterByIoType","inputResult","count","getTxWithCursor","counter","txs","buffer","skippedCount","skip","getTransactionHashes","transactionHashes","collect","exports"],"sources":["../src/transaction_collector.ts"],"sourcesContent":["import {\n  TransactionCollectorOptions,\n  indexer as BaseIndexerModule,\n  Output,\n  OutPoint,\n  TransactionWithStatus,\n  TransactionCollector as BaseTransactionCollector,\n  QueryOptions,\n  Transaction,\n} from \"@ckb-lumos/base\";\nimport {\n  SearchKeyFilter,\n  CKBIndexerQueryOptions,\n  IndexerTransaction,\n  IndexerTransactionList,\n  IOType,\n  Order,\n} from \"./type\";\nimport { CkbIndexer } from \"./indexer\";\nimport { instanceOfScriptWrapper } from \"./ckbIndexerFilter\";\nimport * as services from \"./services\";\n\ninterface GetTransactionDetailResult {\n  objects: TransactionWithStatus[];\n  lastCursor: string | undefined;\n}\n\nexport class CKBIndexerTransactionCollector extends BaseIndexerModule.TransactionCollector {\n  filterOptions: TransactionCollectorOptions;\n  constructor(\n    public indexer: CkbIndexer,\n    public queries: CKBIndexerQueryOptions,\n    public CKBRpcUrl: string,\n    public options?: TransactionCollectorOptions\n  ) {\n    super(indexer, queries, options);\n    const defaultOptions: TransactionCollectorOptions = {\n      skipMissing: false,\n      includeStatus: true,\n    };\n    this.filterOptions = { ...defaultOptions, ...this.options };\n  }\n\n  /**\n   * @deprecated\n   * @param CKBRpcUrl\n   */\n  public static asBaseTransactionCollector(\n    CKBRpcUrl: string\n  ): typeof BaseTransactionCollector {\n    return class extends BaseIndexerModule.TransactionCollector {\n      constructor(\n        indexer: CkbIndexer,\n        queries: QueryOptions,\n        options?: TransactionCollectorOptions\n      ) {\n        super(indexer, queries, options);\n        return new CKBIndexerTransactionCollector(\n          indexer,\n          queries,\n          CKBRpcUrl,\n          options\n        );\n      }\n    };\n  }\n  public async fetchIndexerTransaction(\n    queries: CKBIndexerQueryOptions,\n    lastCursor?: string\n  ): Promise<IndexerTransactionList> {\n    const searchKeyFilter: SearchKeyFilter = {\n      sizeLimit: queries.bufferSize,\n      order: queries.order as Order,\n    };\n    if (lastCursor) {\n      searchKeyFilter.lastCursor = lastCursor;\n    }\n    let indexerTransactionList: IndexerTransactionList = {\n      objects: [],\n      lastCursor: \"\",\n    };\n    /*\n     * if both lock and type exist,we need search them in independent and then get intersection\n     * cause ckb-indexer use searchKey script on each cell but native indexer use lock and type on transaction,\n     * and one transaction may have many cells both in input and output, more detail in test 'Test query transaction by both input lock and output type script'\n     */\n\n    //if both lock and type, search search them in independent and then get intersection, GetTransactionsResults.lastCursor change to `${lockLastCursor}-${typeLastCursor}`\n    if (\n      instanceOfScriptWrapper(queries.lock) &&\n      instanceOfScriptWrapper(queries.type)\n    ) {\n      indexerTransactionList =\n        await this.getTransactionByLockAndTypeIndependent(searchKeyFilter);\n      lastCursor = indexerTransactionList.lastCursor;\n    } else {\n      //query by ScriptWrapper.script,block_range,order\n      indexerTransactionList = await this.indexer.getTransactions(\n        services.generateSearchKey(queries),\n        searchKeyFilter\n      );\n      lastCursor = indexerTransactionList.lastCursor;\n    }\n    // filter by ScriptWrapper.io_type\n    indexerTransactionList.objects = this.filterByTypeIoTypeAndLockIoType(\n      indexerTransactionList.objects,\n      queries\n    );\n    return indexerTransactionList;\n  }\n\n  public getResolvedTransactionRequestPayload(\n    unresolvedTransactionList: TransactionWithStatus[],\n    indexerTransactionList: IndexerTransactionList\n  ): string[] {\n    const requestPayload: string[] = [];\n    unresolvedTransactionList.forEach(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const indexerTransaction = indexerTransactionList.objects[index];\n        if (indexerTransaction.ioType === \"input\") {\n          const unresolvedOutPoint: OutPoint =\n            unresolvedTransaction.transaction.inputs[\n              Number(indexerTransaction.ioIndex)\n            ].previousOutput;\n          requestPayload.push(unresolvedOutPoint.txHash);\n        }\n      }\n    );\n    return requestPayload;\n  }\n\n  public getResolvedCell(\n    unresolvedTransaction: TransactionWithStatus,\n    resolvedTransactionList: TransactionWithStatus[],\n    indexerTransaction: IndexerTransaction\n  ): Output {\n    if (indexerTransaction.ioType !== \"input\") {\n      return unresolvedTransaction.transaction.outputs[\n        Number(indexerTransaction.ioIndex)\n      ];\n    } else {\n      const unresolvedOutPoint =\n        unresolvedTransaction.transaction.inputs[\n          Number(indexerTransaction.ioIndex)\n        ].previousOutput;\n      const resolvedTransaction = resolvedTransactionList.find((tx) => {\n        return tx.transaction.hash === unresolvedOutPoint.txHash;\n      });\n      if (!resolvedTransaction) {\n        throw new Error(`Impossible: can NOT find resolved transaction!`);\n      }\n      const resolvedCell =\n        resolvedTransaction.transaction.outputs[\n          Number(unresolvedOutPoint.index)\n        ];\n      return resolvedCell;\n    }\n  }\n\n  //filter by ScriptWrapper.argsLen\n  private filterTransaction(\n    unresolvedTransactionList: TransactionWithStatus[],\n    resolvedTransactionList: TransactionWithStatus[],\n    indexerTransactionList: IndexerTransactionList\n  ): TransactionWithStatus[] {\n    const filteredTransactionList = unresolvedTransactionList.filter(\n      (unresolvedTransaction: TransactionWithStatus, index: number) => {\n        const resolvedCell: Output = this.getResolvedCell(\n          unresolvedTransaction,\n          resolvedTransactionList,\n          indexerTransactionList.objects[index]\n        );\n        return this.isCellScriptArgsValid(resolvedCell);\n      }\n    );\n    const objects = filteredTransactionList.map<TransactionWithStatus>(\n      (tx) => ({\n        transaction: tx.transaction,\n        txStatus: tx.txStatus,\n        cycles: tx.cycles,\n        timeAddedToPool: tx.timeAddedToPool,\n        minReplaceFee: tx.minReplaceFee,\n        fee: tx.fee,\n      })\n    );\n    return objects;\n  }\n\n  /*\n   *lock?: ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *type?:  ScriptWrapper.script query by ckb-indexer,ScriptWrapper.ioType filter after get transaction from indexer, ScriptWrapper.argsLen filter after get transaction from rpc;\n   *data?: will not filter\n   *argsLen?: filter after get transaction detail;\n   *fromBlock?: query by ckb-indexer;\n   *toBlock?: query by ckb-indexer;\n   *skip?: filter after get transaction from ckb-indexer;;\n   *order?: query by ckb-indexer;\n   */\n  public async getTransactions(\n    lastCursor?: string\n  ): Promise<GetTransactionDetailResult> {\n    const indexerTransactionList: IndexerTransactionList =\n      await this.fetchIndexerTransaction(this.queries, lastCursor);\n    lastCursor = indexerTransactionList.lastCursor;\n\n    // return if transaction hash list if empty\n    if (indexerTransactionList.objects.length === 0) {\n      return {\n        objects: [],\n        lastCursor: lastCursor,\n      };\n    }\n    const unresolvedTransactionList: TransactionWithStatus[] =\n      await this.getTransactionListFromRpc(indexerTransactionList);\n    const requestPayload = this.getResolvedTransactionRequestPayload(\n      unresolvedTransactionList,\n      indexerTransactionList\n    );\n    const resolvedTransactionList =\n      await services.requestBatchTransactionWithStatus(\n        this.CKBRpcUrl,\n        requestPayload\n      );\n    const objects = this.filterTransaction(\n      unresolvedTransactionList,\n      resolvedTransactionList,\n      indexerTransactionList\n    );\n    return {\n      objects: objects,\n      lastCursor: lastCursor,\n    };\n  }\n\n  private async getTransactionByLockAndTypeIndependent(\n    searchKeyFilter: SearchKeyFilter\n  ): Promise<IndexerTransactionList> {\n    const queryWithTypeAdditionOptions = { ...searchKeyFilter };\n    const queryWithLockAdditionOptions = { ...searchKeyFilter };\n    if (searchKeyFilter.lastCursor) {\n      const [lockLastCursor, typeLastCursor] =\n        searchKeyFilter.lastCursor.split(\"-\");\n      queryWithLockAdditionOptions.lastCursor = lockLastCursor;\n      queryWithTypeAdditionOptions.lastCursor = typeLastCursor;\n    }\n    const queriesWithoutType = { ...this.queries, type: undefined };\n    const transactionByLock = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutType),\n      queryWithTypeAdditionOptions\n    );\n    const queriesWithoutLock = { ...this.queries, lock: undefined };\n    const transactionByType = await this.indexer.getTransactions(\n      services.generateSearchKey(queriesWithoutLock),\n      queryWithLockAdditionOptions\n    );\n\n    const intersection = (\n      transactionList1: IndexerTransaction[],\n      transactionList2: IndexerTransaction[]\n    ) => {\n      const result: IndexerTransaction[] = [];\n      transactionList1.forEach((tx1) => {\n        const tx2 = transactionList2.find((item) => item.txHash === tx1.txHash);\n        if (tx2) {\n          // put the output io_type to intersection result, cause output have cells\n          const targetTx = tx1.ioType === \"output\" ? tx1 : tx2;\n          // change io_type to both cause targetTx exist both input and output\n          result.push({ ...targetTx, ioType: \"both\" });\n        }\n      });\n      return result;\n    };\n    const hashList = intersection(\n      transactionByType.objects,\n      transactionByLock.objects\n    );\n    const lastCursor =\n      transactionByLock.lastCursor + \"-\" + transactionByType.lastCursor;\n    const objects = hashList;\n    return { objects, lastCursor };\n  }\n\n  private getTransactionListFromRpc = async (\n    indexerTransactionList: IndexerTransactionList\n  ) => {\n    const getDetailRequestData = indexerTransactionList.objects.map(\n      (hashItem: IndexerTransaction) => {\n        return hashItem.txHash;\n      }\n    );\n\n    const transactionList: TransactionWithStatus[] = await services\n      .requestBatchTransactionWithStatus(this.CKBRpcUrl, getDetailRequestData)\n      .then((response) => {\n        return response.map((item, index) => {\n          if (!this.filterOptions.skipMissing && !item.transaction) {\n            throw new Error(\n              `Transaction ${indexerTransactionList.objects[index].txHash} is missing!`\n            );\n          }\n          return item;\n        });\n      });\n    return transactionList;\n  };\n\n  private isLockArgsLenMatched = (\n    args: string | undefined,\n    argsLen?: number | \"any\"\n  ) => {\n    if (!argsLen) return true;\n    if (argsLen === \"any\") return true;\n    if (argsLen === -1) return true;\n    return services.getHexStringBytes(args as string) === argsLen;\n  };\n\n  // only valid after pass flow three validate\n  private isCellScriptArgsValid = (targetCell: Output) => {\n    if (this.queries.lock) {\n      const lockArgsLen = instanceOfScriptWrapper(this.queries.lock)\n        ? this.queries.lock.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.lock.args, lockArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type !== \"empty\") {\n      const typeArgsLen = instanceOfScriptWrapper(this.queries.type)\n        ? this.queries.type.argsLen\n        : this.queries.argsLen;\n      if (!this.isLockArgsLenMatched(targetCell.type?.args, typeArgsLen)) {\n        return false;\n      }\n    }\n\n    if (this.queries.type && this.queries.type === \"empty\") {\n      if (targetCell.type) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  private filterByIoType = (\n    inputResult: IndexerTransaction[],\n    ioType: IOType\n  ) => {\n    if (ioType === \"both\") {\n      return inputResult;\n    }\n    if (ioType === \"input\" || ioType === \"output\") {\n      return inputResult.filter(\n        (item: IndexerTransaction) =>\n          item.ioType === ioType || item.ioType === \"both\"\n      );\n    }\n    return inputResult;\n  };\n\n  private filterByTypeIoTypeAndLockIoType = (\n    inputResult: IndexerTransaction[],\n    queries: CKBIndexerQueryOptions\n  ) => {\n    let result = inputResult;\n    if (instanceOfScriptWrapper(queries.lock) && queries.lock.ioType) {\n      result = this.filterByIoType(result, queries.lock.ioType);\n    }\n    if (instanceOfScriptWrapper(queries.type) && queries.type.ioType) {\n      result = this.filterByIoType(result, queries.type.ioType);\n    }\n    return result;\n  };\n\n  async count(): Promise<number> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    let counter = 0;\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return 0;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        counter += 1;\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return counter;\n  }\n  async getTransactionHashes(): Promise<string[]> {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n\n    const transactionHashes: string[] = [];\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return [];\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (txs[index].transaction.hash) {\n          transactionHashes.push(txs[index].transaction.hash as string);\n        }\n      }\n\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n    return transactionHashes;\n  }\n  async *collect(): AsyncGenerator<\n    TransactionWithStatus | Transaction,\n    undefined,\n    unknown\n  > {\n    let lastCursor: undefined | string = undefined;\n    const getTxWithCursor = async (): Promise<TransactionWithStatus[]> => {\n      const result: GetTransactionDetailResult = await this.getTransactions(\n        lastCursor\n      );\n      lastCursor = result.lastCursor;\n      return result.objects;\n    };\n    //skip query result in first query\n    let txs: TransactionWithStatus[] = await getTxWithCursor();\n    if (txs.length === 0) {\n      return undefined;\n    }\n    let buffer: Promise<TransactionWithStatus[]> = getTxWithCursor();\n    let index = 0;\n    let skippedCount = 0;\n    while (true) {\n      if (this.queries.skip && skippedCount < this.queries.skip) {\n        skippedCount++;\n      } else {\n        if (this.filterOptions.includeStatus) {\n          yield txs[index];\n        } else {\n          yield txs[index].transaction;\n        }\n      }\n      index++;\n      //reset index and exchange `txs` and `buffer` after count last tx\n      if (index === txs.length) {\n        index = 0;\n        txs = await buffer;\n        // break if can not get more txs\n        if (txs.length === 0) {\n          break;\n        }\n        buffer = getTxWithCursor();\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}