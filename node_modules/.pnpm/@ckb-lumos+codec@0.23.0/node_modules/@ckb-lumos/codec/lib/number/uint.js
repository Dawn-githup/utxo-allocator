"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "BI", {
  enumerable: true,
  get: function () {
    return _bi.BI;
  }
});
Object.defineProperty(exports, "BIish", {
  enumerable: true,
  get: function () {
    return _bi.BIish;
  }
});
exports.Uint8 = exports.Uint64LE = exports.Uint64BE = exports.Uint64 = exports.Uint512LE = exports.Uint512BE = exports.Uint512 = exports.Uint32LE = exports.Uint32BE = exports.Uint32 = exports.Uint256LE = exports.Uint256BE = exports.Uint256 = exports.Uint16LE = exports.Uint16BE = exports.Uint16 = exports.Uint128LE = exports.Uint128BE = exports.Uint128 = void 0;
var _bi = require("@ckb-lumos/bi");
var _base = require("../base");
var _error = require("../error");
function assertNumberRange(value, min, max, typeName) {
  value = _bi.BI.from(value);
  if (value.lt(min) || value.gt(max)) {
    throw new _error.CodecBaseParseError(`Value must be between ${min.toString()} and ${max.toString()}, but got ${value.toString()}`, typeName);
  }
}
function createUintNumberCodec(byteLength, littleEndian = false) {
  const codec = createUintBICodec(byteLength, littleEndian);
  return {
    __isFixedCodec__: true,
    byteLength,
    pack: packable => codec.pack(packable),
    unpack: unpackable => codec.unpack(unpackable).toNumber()
  };
}
const createUintBICodec = (byteLength, littleEndian = false) => {
  const max = _bi.BI.from(1).shl(byteLength * 8).sub(1);
  return (0, _base.createFixedBytesCodec)({
    byteLength,
    pack(biIsh) {
      let endianType = littleEndian ? "LE" : "BE";
      if (byteLength <= 1) {
        endianType = "";
      }
      const typeName = `Uint${byteLength * 8}${endianType}`;
      if (typeof biIsh === "number" && !Number.isSafeInteger(biIsh)) {
        throw new _error.CodecBaseParseError(`${biIsh} is not a safe integer`, typeName);
      }
      let num = _bi.BI.from(biIsh);
      assertNumberRange(num, 0, max, typeName);
      const result = new DataView(new ArrayBuffer(byteLength));
      for (let i = 0; i < byteLength; i++) {
        if (littleEndian) {
          result.setUint8(i, num.and(0xff).toNumber());
        } else {
          result.setUint8(byteLength - i - 1, num.and(0xff).toNumber());
        }
        num = num.shr(8);
      }
      return new Uint8Array(result.buffer);
    },
    unpack: buf => {
      const view = new DataView(Uint8Array.from(buf).buffer);
      let result = _bi.BI.from(0);
      for (let i = 0; i < byteLength; i++) {
        if (littleEndian) {
          result = result.or(_bi.BI.from(view.getUint8(i)).shl(i * 8));
        } else {
          result = result.shl(8).or(view.getUint8(i));
        }
      }
      return result;
    }
  });
};
const Uint8 = exports.Uint8 = createUintNumberCodec(1);
const Uint16LE = exports.Uint16LE = createUintNumberCodec(2, true);
const Uint16BE = exports.Uint16BE = createUintNumberCodec(2);
/**
 * @alias Uint16LE
 */
const Uint16 = exports.Uint16 = Uint16LE;
const Uint32LE = exports.Uint32LE = createUintNumberCodec(4, true);
const Uint32BE = exports.Uint32BE = createUintNumberCodec(4);
/**
 * @alias Uint32LE
 */
const Uint32 = exports.Uint32 = Uint32LE;
const Uint64LE = exports.Uint64LE = createUintBICodec(8, true);
const Uint64BE = exports.Uint64BE = createUintBICodec(8);
/**
 * @alias Uint64LE
 */
const Uint64 = exports.Uint64 = Uint64LE;
const Uint128LE = exports.Uint128LE = createUintBICodec(16, true);
const Uint128BE = exports.Uint128BE = createUintBICodec(16);
/**
 * @alias Uint128LE
 */
const Uint128 = exports.Uint128 = Uint128LE;
const Uint256LE = exports.Uint256LE = createUintBICodec(32, true);
const Uint256BE = exports.Uint256BE = createUintBICodec(32);
/**
 * @alias Uint256LE
 */
const Uint256 = exports.Uint256 = Uint256LE;
const Uint512LE = exports.Uint512LE = createUintBICodec(64, true);
const Uint512BE = exports.Uint512BE = createUintBICodec(64);
/**
 * @alias Uint512LE
 */
const Uint512 = exports.Uint512 = Uint512LE;
//# sourceMappingURL=uint.js.map