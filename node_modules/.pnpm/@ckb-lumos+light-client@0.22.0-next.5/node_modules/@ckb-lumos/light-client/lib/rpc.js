"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LightClientRPC = void 0;
var _rpc = require("@ckb-lumos/rpc");
var _resultFormatter = require("./resultFormatter");
var _crossFetch = _interopRequireDefault(require("cross-fetch"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* c8 ignore next 100 */
class LightClientRPC {
  /**
   *
   * @param uri light client uri
   */
  constructor(uri) {
    this.uri = uri;
  }
  async getTipHeader() {
    return _rpc.ResultFormatter.toHeader(await request(this.uri, "get_tip_header"));
  }
  async getPeers() {
    return _rpc.ResultFormatter.toPeers(await request(this.uri, "get_peers"));
  }
  async localNodeInfo() {
    return _rpc.ResultFormatter.toLocalNodeInfo(await request(this.uri, "local_node_info"));
  }
  async fetchHeader(blockHash) {
    const params = [blockHash];
    return (0, _resultFormatter.toFetchHeaderResult)(await request(this.uri, "fetch_header", params));
  }
  async getHeader(blockHash) {
    const params = [blockHash];
    return _rpc.ResultFormatter.toHeader(await request(this.uri, "get_header", params));
  }
  async fetchTransaction(txHash) {
    const params = [txHash];
    return (0, _resultFormatter.toFetchTransactionResult)(await request(this.uri, "fetch_transaction", params));
  }
  async getTransaction(txHash) {
    const params = [txHash];
    return _rpc.ResultFormatter.toTransactionWithStatus(await request(this.uri, "get_transaction", params));
  }
  async sendTransaction(tx) {
    const params = [_rpc.ParamsFormatter.toRawTransaction(tx)];
    return _rpc.ResultFormatter.toHash(await request(this.uri, "send_transaction", params));
  }
  async getScripts() {
    return (await request(this.uri, "get_scripts")).map(_resultFormatter.toLightClientScript);
  }
  async setScripts(scripts, command) {
    const params = [scripts.map(({
      script,
      scriptType,
      blockNumber
    }) => ({
      script: _rpc.ParamsFormatter.toScript(script),
      script_type: scriptType,
      block_number: blockNumber
    })), command];
    await request(this.uri, "set_scripts", params);
  }
  async getCells(searchKey, order, limit, cursor) {
    const params = [_rpc.ParamsFormatter.toGetCellsSearchKey(searchKey), order, limit, cursor];
    return _rpc.ResultFormatter.toGetCellsResult(await request(this.uri, "get_cells", params));
  }
  async getCellsCapacity(searchKey) {
    const params = [_rpc.ParamsFormatter.toSearchKey(searchKey)];
    return _rpc.ResultFormatter.toCellsCapacity(await request(this.uri, "get_cells_capacity", params));
  }
  async getGenesisBlock() {
    return _rpc.ResultFormatter.toBlock(await request(this.uri, "get_genesis_block"));
  }
  async getTransactions(searchKey, order, limit, cursor) {
    const params = [_rpc.ParamsFormatter.toGetTransactionsSearchKey(searchKey), order, limit, cursor];
    return _rpc.ResultFormatter.toGetTransactionsResult(await request(this.uri, "get_transactions", params));
  }
}
exports.LightClientRPC = LightClientRPC;
const request = async (ckbIndexerUrl, method, params) => {
  const res = await (0, _crossFetch.default)(ckbIndexerUrl, {
    method: "POST",
    body: JSON.stringify({
      id: 0,
      jsonrpc: "2.0",
      method,
      params
    }),
    headers: {
      "Content-Type": "application/json"
    }
  });
  if (res.status !== 200) {
    throw new Error(`indexer request failed with HTTP code ${res.status}`);
  }
  const data = await res.json();
  if (data.error !== undefined) {
    throw new Error(`indexer request rpc failed with error: ${JSON.stringify(data.error)}`);
  }
  return data.result;
};
/* eslint-enalbe @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */
//# sourceMappingURL=rpc.js.map