"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewClusterOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const helpers_1 = require("@ckb-lumos/lumos/helpers");
const codec_2 = require("../../../codec");
const config_1 = require("../../../config");
const helpers_2 = require("../../../helpers");
const injectNewClusterIds_1 = require("./injectNewClusterIds");
function injectNewClusterOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Check the referenced Mutant's ID format
    if (props.data.mutantId !== void 0) {
        const packedMutantId = codec_1.bytes.bytify(props.data.mutantId);
        if (packedMutantId.byteLength !== 32) {
            throw new Error(`Invalid Mutant Id length, expected 32, actually: ${packedMutantId.byteLength}`);
        }
    }
    // Create Cluster cell (the latest version)
    const clusterScript = (0, config_1.getSporeScript)(config, 'Cluster');
    const clusterData = (0, codec_2.packRawClusterData)(props.data, clusterScript.behaviors?.clusterDataVersion);
    let clusterCell = (0, helpers_2.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...clusterScript.script,
                args: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
            },
        },
        data: codec_1.bytes.hexify(clusterData),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            clusterCell = (0, helpers_2.setAbsoluteCapacityMargin)(clusterCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            clusterCell = props.updateOutput(clusterCell);
        }
        return outputs.push(clusterCell);
    });
    // Fix the output's index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Generate ID for the new Cluster if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput) {
        txSkeleton = (0, injectNewClusterIds_1.injectNewClusterIds)({
            outputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add Cluster required cellDeps
    txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, clusterScript.cellDep);
    // Add Mutant cellDeps if ClusterData.mutantId is specified
    if (props.data.mutantId !== void 0) {
        const mutantScript = (0, config_1.getSporeScript)(config, 'Mutant');
        txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, mutantScript.cellDep);
    }
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
    };
}
exports.injectNewClusterOutput = injectNewClusterOutput;
//# sourceMappingURL=injectNewClusterOutput.js.map