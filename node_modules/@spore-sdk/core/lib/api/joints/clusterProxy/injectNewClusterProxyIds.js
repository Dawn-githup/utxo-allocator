"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewClusterProxyIds = void 0;
const codec_1 = require("@ckb-lumos/codec");
const helpers_1 = require("../../../helpers");
const codec_2 = require("../../../codec");
const config_1 = require("../../../config");
function injectNewClusterProxyIds(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get the Transaction.inputs[0]
    const firstInput = txSkeleton.get('inputs').get(0);
    if (!firstInput) {
        throw new Error('Cannot generate ClusterProxy Id because Transaction.inputs[0] does not exist');
    }
    // Generate TypeIds by the output indices
    let outputs = txSkeleton.get('outputs');
    let typeIdGroup = (0, helpers_1.generateTypeIdsByOutputs)(firstInput, outputs.toArray(), (cell) => {
        return !!cell.cellOutput.type && (0, config_1.isSporeScriptSupported)(config, cell.cellOutput.type, 'ClusterProxy');
    });
    // Only keep the TypeIDs corresponding to the specified output indices
    if (props.outputIndices) {
        typeIdGroup = typeIdGroup.filter(([outputIndex]) => {
            const index = props.outputIndices.findIndex((index) => index === outputIndex);
            return index >= 0;
        });
        if (typeIdGroup.length !== props.outputIndices.length) {
            throw new Error('Cannot generate ClusterProxy Id because outputIndices cannot be fully handled');
        }
    }
    // Update results
    for (const [index, typeId] of typeIdGroup) {
        const output = outputs.get(index);
        if (!output) {
            throw new Error(`Cannot generate ClusterProxy Id because Transaction.outputs[${index}] does not exist`);
        }
        const unpackedArgs = (0, codec_2.unpackToRawClusterProxyArgs)(output.cellOutput.type.args);
        const packedNewArgs = (0, codec_2.packRawClusterProxyArgs)({
            id: typeId,
            minPayment: unpackedArgs.minPayment,
        });
        output.cellOutput.type.args = codec_1.bytes.hexify(packedNewArgs);
        outputs = outputs.set(index, output);
    }
    return txSkeleton.set('outputs', outputs);
}
exports.injectNewClusterProxyIds = injectNewClusterProxyIds;
//# sourceMappingURL=injectNewClusterProxyIds.js.map