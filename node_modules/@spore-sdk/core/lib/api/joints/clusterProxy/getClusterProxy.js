"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClusterProxyById = exports.getClusterProxyByOutPoint = exports.getClusterProxyByType = void 0;
const codec_1 = require("@ckb-lumos/codec");
const lumos_1 = require("@ckb-lumos/lumos");
const helpers_1 = require("../../../helpers");
const config_1 = require("../../../config");
const codec_2 = require("../../../codec");
async function getClusterProxyByType(type, config) {
    // Env
    config = config ?? (0, config_1.getSporeConfig)();
    const indexer = new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl);
    // Get cell by type
    const cell = await (0, helpers_1.getCellByType)({ type, indexer });
    if (cell === void 0) {
        throw new Error('Cannot find ClusterProxy by Type because target cell does not exist');
    }
    // Check target cell's type script
    const cellType = cell.cellOutput.type;
    if (!cellType || !(0, config_1.isSporeScriptSupported)(config, cellType, 'ClusterProxy')) {
        throw new Error('Cannot find ClusterProxy by Type because target cell is not a supported version of ClusterProxy');
    }
    return cell;
}
exports.getClusterProxyByType = getClusterProxyByType;
async function getClusterProxyByOutPoint(outPoint, config) {
    // Env
    config = config ?? (0, config_1.getSporeConfig)();
    const rpc = new lumos_1.RPC(config.ckbNodeUrl);
    // Get cell from rpc
    const cellWithStatus = await (0, helpers_1.getCellWithStatusByOutPoint)({
        outPoint,
        rpc,
    });
    if (!cellWithStatus.cell) {
        throw new Error('Cannot find ClusterProxy by OutPoint because target cell was not found');
    }
    if (cellWithStatus.status !== 'live') {
        throw new Error('Cannot find ClusterProxy by OutPoint because target cell is not lived');
    }
    // Check target cell's type script
    const cellType = cellWithStatus.cell.cellOutput.type;
    if (!cellType || !(0, config_1.isSporeScriptSupported)(config, cellType, 'ClusterProxy')) {
        throw new Error('Cannot find ClusterProxy by OutPoint because target cell is not a supported version of ClusterProxy');
    }
    return cellWithStatus.cell;
}
exports.getClusterProxyByOutPoint = getClusterProxyByOutPoint;
async function getClusterProxyById(id, config) {
    // Env
    config = config ?? (0, config_1.getSporeConfig)();
    // Get ClusterProxy script
    const clusterProxyScript = (0, config_1.getSporeScriptCategory)(config, 'ClusterProxy');
    const scripts = (clusterProxyScript.versions ?? []).map((r) => r.script);
    // Search target cluster proxy from the latest version to the oldest
    const args = codec_1.bytes.hexify((0, codec_2.packRawClusterProxyArgs)({
        id,
    }));
    for (const script of scripts) {
        try {
            return await getClusterProxyByType({
                ...script,
                args,
            }, config);
        }
        catch (e) {
            // Not found in the script, don't have to do anything
            console.error('getClusterProxyById error:', e);
        }
    }
    throw new Error(`Cannot find ClusterProxy by ID because target cell does not exist or it's not a supported version of ClusterProxy`);
}
exports.getClusterProxyById = getClusterProxyById;
//# sourceMappingURL=getClusterProxy.js.map