"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectNewMutantOutput = void 0;
const codec_1 = require("@ckb-lumos/codec");
const lumos_1 = require("@ckb-lumos/lumos");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const codec_2 = require("../../../codec");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
const injectNewMutantIds_1 = require("./injectNewMutantIds");
function injectNewMutantOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Create Mutant cell (the latest version)
    const mutantScript = (0, config_1.getSporeScript)(config, 'Mutant');
    let mutantCell = (0, helpers_1.correctCellMinimalCapacity)({
        cellOutput: {
            capacity: '0x0',
            lock: props.toLock,
            type: {
                ...mutantScript.script,
                args: codec_1.bytes.hexify((0, codec_2.packRawMutantArgs)({
                    id: '0x' + '0'.repeat(64), // Fill 32-byte TypeId placeholder
                    minPayment: props.minPayment !== void 0 ? lumos_1.BI.from(props.minPayment) : void 0,
                })),
            },
        },
        data: codec_1.bytes.hexify(props.data),
    });
    // Add to Transaction.outputs
    const outputIndex = txSkeleton.get('outputs').size;
    txSkeleton = txSkeleton.update('outputs', (outputs) => {
        if (props.capacityMargin !== void 0) {
            mutantCell = (0, helpers_1.setAbsoluteCapacityMargin)(mutantCell, props.capacityMargin);
        }
        if (props.updateOutput instanceof Function) {
            mutantCell = props.updateOutput(mutantCell);
        }
        return outputs.push(mutantCell);
    });
    // Fix the output's index to prevent it from future reduction
    txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
        return fixedEntries.push({
            field: 'outputs',
            index: outputIndex,
        });
    });
    // Generate ID for the new Mutant if possible
    const firstInput = txSkeleton.get('inputs').first();
    if (firstInput) {
        txSkeleton = (0, injectNewMutantIds_1.injectNewMutantIds)({
            outputIndices: [outputIndex],
            txSkeleton,
            config,
        });
    }
    // Add Lua lib script as cellDep
    const luaScript = (0, config_1.getSporeScript)(config, 'Lua');
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, luaScript.cellDep);
    // Add Mutant script as cellDep
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, mutantScript.cellDep);
    return {
        txSkeleton,
        outputIndex,
        hasId: firstInput !== void 0,
    };
}
exports.injectNewMutantOutput = injectNewMutantOutput;
//# sourceMappingURL=injectNewMutantOutput.js.map