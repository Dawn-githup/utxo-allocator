"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectLiveMutantCell = void 0;
const codec_1 = require("@ckb-lumos/codec");
const lumos_1 = require("@ckb-lumos/lumos");
const helper_1 = require("@ckb-lumos/common-scripts/lib/helper");
const config_1 = require("../../../config");
const helpers_1 = require("../../../helpers");
const codec_2 = require("../../../codec");
async function injectLiveMutantCell(props) {
    // Env
    const mutantCell = props.cell;
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Check target cell's type
    const mutantCellType = mutantCell.cellOutput.type;
    const mutantScript = (0, config_1.getSporeScript)(config, 'Mutant', mutantCellType);
    if (!mutantCellType || !mutantScript) {
        throw new Error('Cannot inject Mutant because target cell is not a supported version of Mutant');
    }
    // Add Mutant cell to Transaction.inputs
    const setupCellResult = await (0, helpers_1.setupCell)({
        txSkeleton,
        input: props.cell,
        config: config.lumos,
        addOutput: props.addOutput,
        updateOutput(cell) {
            if (props.minPayment !== void 0) {
                const unpackedArgs = (0, codec_2.unpackToRawMutantArgs)(cell.cellOutput.type.args);
                const newArgs = (0, codec_2.packRawMutantArgs)({
                    ...unpackedArgs,
                    minPayment: lumos_1.BI.from(props.minPayment),
                });
                cell.cellOutput.type.args = codec_1.bytes.hexify(newArgs);
            }
            if (props.capacityMargin !== void 0) {
                cell = (0, helpers_1.setAbsoluteCapacityMargin)(cell, props.capacityMargin);
            }
            if (props.updateOutput instanceof Function) {
                cell = props.updateOutput(cell);
            }
            return cell;
        },
        defaultWitness: props.defaultWitness,
        updateWitness: props.updateWitness,
        since: props.since,
    });
    txSkeleton = setupCellResult.txSkeleton;
    // If the Mutant is added to Transaction.outputs
    if (props.addOutput) {
        // Make sure the cell's output has declared enough capacity
        const output = txSkeleton.get('outputs').get(setupCellResult.outputIndex);
        (0, helpers_1.assetCellMinimalCapacity)(output);
        // Fix the cell's output index
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: setupCellResult.outputIndex,
            });
        });
    }
    // Add Mutant required cellDeps
    txSkeleton = (0, helper_1.addCellDep)(txSkeleton, mutantScript.cellDep);
    return {
        txSkeleton,
        inputIndex: setupCellResult.inputIndex,
        outputIndex: setupCellResult.outputIndex,
    };
}
exports.injectLiveMutantCell = injectLiveMutantCell;
//# sourceMappingURL=injectLiveMutantCell.js.map