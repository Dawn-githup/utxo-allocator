"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectLiveSporeCell = void 0;
const lumos_1 = require("@ckb-lumos/lumos");
const helpers_1 = require("@ckb-lumos/lumos/helpers");
const helpers_2 = require("../../../helpers");
const config_1 = require("../../../config");
const codec_1 = require("../../../codec");
const getMutant_1 = require("../mutant/getMutant");
async function injectLiveSporeCell(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const sporeCell = props.cell;
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Check target cell's type script id
    const sporeType = sporeCell.cellOutput.type;
    const sporeScript = (0, config_1.getSporeScript)(config, 'Spore', sporeType);
    if (!sporeType || !sporeScript) {
        throw new Error('Cannot inject live spore because target cell type is not a supported version of Spore');
    }
    // Add spore to Transaction.inputs
    const setupCellResult = await (0, helpers_2.setupCell)({
        txSkeleton,
        input: sporeCell,
        addOutput: props.addOutput,
        updateOutput(cell) {
            if (props.capacityMargin !== void 0) {
                cell = (0, helpers_2.setAbsoluteCapacityMargin)(cell, props.capacityMargin);
            }
            if (props.updateOutput instanceof Function) {
                cell = props.updateOutput(cell);
            }
            return cell;
        },
        defaultWitness: props.defaultWitness,
        updateWitness: props.updateWitness,
        config: config.lumos,
        since: props.since,
    });
    txSkeleton = setupCellResult.txSkeleton;
    // If added to outputs, fix the cell's output index
    if (props.addOutput) {
        txSkeleton = txSkeleton.update('fixedEntries', (fixedEntries) => {
            return fixedEntries.push({
                field: 'outputs',
                index: setupCellResult.outputIndex,
            });
        });
    }
    // Add Spore script as cellDep
    let sporeCelldep = sporeScript.cellDep;
    if (sporeScript.behaviors?.dynamicCelldep) {
        const scriptCell = await (0, helpers_2.getCellByType)({
            type: sporeScript.behaviors?.dynamicCelldep,
            indexer: new lumos_1.Indexer(config.ckbIndexerUrl, config.ckbNodeUrl),
        });
        if (scriptCell) {
            sporeCelldep = {
                outPoint: scriptCell.outPoint,
                depType: 'code',
            };
        }
    }
    txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, sporeCelldep);
    // Validate SporeData.contentType
    const sporeData = (0, codec_1.unpackToRawSporeData)(sporeCell.data);
    // note: consider the compatibility of custom spore-like scripts, skip content-type check is allowed
    if ((0, helpers_2.isContentTypeValid)(sporeData.contentType)) {
        // Add Mutant cells as cellDeps
        const decodedContentType = (0, helpers_2.decodeContentType)(sporeData.contentType);
        if (decodedContentType.parameters.mutant !== void 0) {
            const mutantScript = (0, config_1.getSporeScript)(config, 'Mutant');
            txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, mutantScript.cellDep);
            const mutantParameter = decodedContentType.parameters.mutant;
            const mutantIds = Array.isArray(mutantParameter) ? mutantParameter : [mutantParameter];
            const mutantCells = await Promise.all(mutantIds.map((id) => (0, getMutant_1.getMutantById)(id, config)));
            for (const mutantCell of mutantCells) {
                txSkeleton = (0, helpers_1.addCellDep)(txSkeleton, {
                    outPoint: mutantCell.outPoint,
                    depType: 'code',
                });
            }
        }
    }
    return {
        txSkeleton,
        inputIndex: setupCellResult.inputIndex,
        outputIndex: setupCellResult.outputIndex,
    };
}
exports.injectLiveSporeCell = injectLiveSporeCell;
//# sourceMappingURL=injectLiveSporeCell.js.map