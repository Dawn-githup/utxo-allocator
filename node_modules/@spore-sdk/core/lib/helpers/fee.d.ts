import { FromInfo } from '@ckb-lumos/common-scripts';
import { Address, Transaction } from '@ckb-lumos/base';
import { BI, Header, helpers, RPC } from '@ckb-lumos/lumos';
import { BIish } from '@ckb-lumos/bi';
import { SporeConfig } from '../config';
import { CapacitySnapshot } from './capacity';
/**
 * Get minimal acceptable fee rate from RPC.
 */
export declare function getMinFeeRate(rpc: RPC | string): Promise<BI>;
/**
 * Calculate transaction fee by transaction's byte size and feeRate.
 */
export declare function calculateFee(size: number, feeRate: BIish): BI;
/**
 * Calculate transaction fee by Transaction and a specific feeRate.
 */
export declare function calculateFeeByTransaction(tx: Transaction, feeRate: BIish): BI;
/**
 * Calculate transaction fee by TransactionSkeleton and a specific feeRate.
 */
export declare function calculateFeeByTransactionSkeleton(txSkeleton: helpers.TransactionSkeletonType, feeRate: BIish): BI;
/**
 * Pay transaction fee via a capacity collection process,
 * using the minimal acceptable fee rate from the RPC.
 */
export declare function payFeeThroughCollection(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    fromInfos: FromInfo[];
    changeAddress?: Address;
    feeRate?: BIish;
    tipHeader?: Header;
    enableDeductCapacity?: boolean;
    useLocktimeCellsFirst?: boolean;
    updateTxSkeletonAfterCollection?: (txSkeleton: helpers.TransactionSkeletonType) => Promise<helpers.TransactionSkeletonType> | helpers.TransactionSkeletonType;
    config?: SporeConfig;
}): Promise<helpers.TransactionSkeletonType>;
/**
 * Specify an output to pay transaction fee.
 */
export declare function payFeeByOutput(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    outputIndex: number;
    feeRate?: BIish;
    config?: SporeConfig;
}): Promise<helpers.TransactionSkeletonType>;
/**
 * Inject the needed amount of capacity,
 * and then pay the transaction fee via a capacity collection process.
 */
export declare function injectCapacityAndPayFee(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    fromInfos: FromInfo[];
    config?: SporeConfig;
    feeRate?: BIish;
    extraCapacity?: BIish;
    changeAddress?: Address;
    enableDeductCapacity?: boolean;
    updateTxSkeletonAfterCollection?: (txSkeleton: helpers.TransactionSkeletonType) => Promise<helpers.TransactionSkeletonType> | helpers.TransactionSkeletonType;
}): Promise<{
    txSkeleton: helpers.TransactionSkeletonType;
    before: CapacitySnapshot;
    after: CapacitySnapshot;
}>;
/**
 * Return exceeded capacity (change) to the outputs and then pay fee by the change cell.
 */
export declare function returnExceededCapacityAndPayFee(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    changeAddress: Address;
    fromInfos?: FromInfo[];
    config?: SporeConfig;
    feeRate?: BIish;
}): Promise<{
    txSkeleton: helpers.TransactionSkeletonType;
    changeCellOutputIndex: number;
    createdChangeCell: boolean;
}>;
