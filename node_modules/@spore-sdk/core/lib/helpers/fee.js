"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.returnExceededCapacityAndPayFee = exports.injectCapacityAndPayFee = exports.payFeeByOutput = exports.payFeeThroughCollection = exports.calculateFeeByTransactionSkeleton = exports.calculateFeeByTransaction = exports.calculateFee = exports.getMinFeeRate = void 0;
const common_scripts_1 = require("@ckb-lumos/common-scripts");
const lumos_1 = require("@ckb-lumos/lumos");
const config_1 = require("../config");
const capacity_1 = require("./capacity");
const capacity_2 = require("./capacity");
const transaction_1 = require("./transaction");
/**
 * Get minimal acceptable fee rate from RPC.
 */
async function getMinFeeRate(rpc) {
    rpc = typeof rpc === 'string' ? new lumos_1.RPC(rpc) : rpc;
    const info = await rpc.txPoolInfo();
    return lumos_1.BI.from(info.minFeeRate);
}
exports.getMinFeeRate = getMinFeeRate;
/**
 * Calculate transaction fee by transaction's byte size and feeRate.
 */
function calculateFee(size, feeRate) {
    const ratio = lumos_1.BI.from(1000);
    const base = lumos_1.BI.from(size).mul(feeRate);
    const fee = base.div(ratio);
    if (fee.mul(ratio).lt(base)) {
        return fee.add(1);
    }
    return lumos_1.BI.from(fee);
}
exports.calculateFee = calculateFee;
/**
 * Calculate transaction fee by Transaction and a specific feeRate.
 */
function calculateFeeByTransaction(tx, feeRate) {
    const size = (0, transaction_1.getTransactionSize)(tx);
    return calculateFee(size, feeRate);
}
exports.calculateFeeByTransaction = calculateFeeByTransaction;
/**
 * Calculate transaction fee by TransactionSkeleton and a specific feeRate.
 */
function calculateFeeByTransactionSkeleton(txSkeleton, feeRate) {
    const tx = lumos_1.helpers.createTransactionFromSkeleton(txSkeleton);
    return calculateFeeByTransaction(tx, feeRate);
}
exports.calculateFeeByTransactionSkeleton = calculateFeeByTransactionSkeleton;
/**
 * Pay transaction fee via a capacity collection process,
 * using the minimal acceptable fee rate from the RPC.
 */
async function payFeeThroughCollection(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
    let size = 0;
    let newTxSkeleton = props.txSkeleton;
    /**
     * Loop the collection process until the transaction size is no longer increasing.
     * This is to ensure that the transaction size is as small as possible.
     */
    let currentTransactionSize = (0, transaction_1.getTransactionSkeletonSize)(newTxSkeleton);
    while (currentTransactionSize > size) {
        size = currentTransactionSize;
        const fee = calculateFee(size, feeRate);
        newTxSkeleton = await common_scripts_1.common.injectCapacity(props.txSkeleton, props.fromInfos, fee, props.changeAddress, props.tipHeader, {
            config: config.lumos,
            enableDeductCapacity: props.enableDeductCapacity,
            useLocktimeCellsFirst: props.useLocktimeCellsFirst,
        });
        /**
         * When injection is made and has passed the "updateTxSkeletonUpdateCollection" function,
         * the function will be called to update the TransactionSkeleton as needed.
         */
        if (props.updateTxSkeletonAfterCollection) {
            newTxSkeleton = await props.updateTxSkeletonAfterCollection(newTxSkeleton);
        }
        currentTransactionSize = (0, transaction_1.getTransactionSkeletonSize)(newTxSkeleton);
    }
    return newTxSkeleton;
}
exports.payFeeThroughCollection = payFeeThroughCollection;
/**
 * Specify an output to pay transaction fee.
 */
async function payFeeByOutput(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
    // Get TransactionSkeleton
    let txSkeleton = props.txSkeleton;
    // Get target output cell
    let outputs = txSkeleton.get('outputs');
    const output = outputs.get(props.outputIndex);
    if (!output) {
        throw new Error(`Cannot pay fee by Transaction.outputs[${props.outputIndex}] because it does not exist`);
    }
    // Check can pay fee with capacity margin
    const minimalCellCapacity = lumos_1.helpers.minimalCellCapacityCompatible(output);
    const outputCapacity = lumos_1.BI.from(output.cellOutput.capacity);
    const capacityMargin = outputCapacity.sub(minimalCellCapacity);
    const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
    if (capacityMargin.lt(fee)) {
        throw new Error(`Cannot pay fee by Transaction.outputs[${props.outputIndex}] due to insufficient capacity`);
    }
    // Pay fee and update capacity
    output.cellOutput.capacity = outputCapacity.sub(fee).toHexString();
    outputs = outputs.set(props.outputIndex, output);
    return txSkeleton.set('outputs', outputs);
}
exports.payFeeByOutput = payFeeByOutput;
/**
 * Inject the needed amount of capacity,
 * and then pay the transaction fee via a capacity collection process.
 */
async function injectCapacityAndPayFee(props) {
    // Env
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Collect capacity
    const injectNeededCapacityResult = await (0, capacity_1.injectNeededCapacity)({
        ...props,
        config: config.lumos,
    });
    // Pay fee
    const txSkeleton = await payFeeThroughCollection({
        ...props,
        txSkeleton: injectNeededCapacityResult.txSkeleton,
    });
    return {
        txSkeleton,
        before: injectNeededCapacityResult.before,
        after: (0, capacity_2.createCapacitySnapshotFromTransactionSkeleton)(txSkeleton),
    };
}
exports.injectCapacityAndPayFee = injectCapacityAndPayFee;
/**
 * Return exceeded capacity (change) to the outputs and then pay fee by the change cell.
 */
async function returnExceededCapacityAndPayFee(props) {
    let txSkeleton = props.txSkeleton;
    const config = props.config ?? (0, config_1.getSporeConfig)();
    // Return exceeded (change) capacity
    const returnExceededCapacityResult = (0, capacity_1.returnExceededCapacity)({
        txSkeleton,
        config: config.lumos,
        changeAddress: props.changeAddress,
    });
    txSkeleton = returnExceededCapacityResult.txSkeleton;
    // If no change was returned, throw error as it is unexpected
    if (!returnExceededCapacityResult.returnedChange) {
        throw new Error(`Cannot pay fee with change cell because no change was returned`);
    }
    if (returnExceededCapacityResult.unreturnedCapacity.gt(0)) {
        if (props.fromInfos === void 0) {
            throw new Error(`Cannot pay fee with change cell because fromInfos is required`);
        }
        // Pay fee by capacity collection
        const feeRate = props.feeRate ?? (await getMinFeeRate(config.ckbNodeUrl));
        const fee = calculateFeeByTransactionSkeleton(txSkeleton, feeRate);
        txSkeleton = await common_scripts_1.common.injectCapacity(txSkeleton, props.fromInfos, 1, props.changeAddress, void 0, {
            enableDeductCapacity: false,
            config: props.config?.lumos,
        });
        txSkeleton = txSkeleton.update('outputs', (outputs) => {
            outputs.update(-1, (output) => {
                if (output) {
                    const capacity = lumos_1.BI.from(output.cellOutput.capacity);
                    output.cellOutput.capacity = capacity
                        .add(returnExceededCapacityResult.unreturnedCapacity)
                        .sub(fee)
                        .toHexString();
                }
                return output;
            });
            return outputs;
        });
    }
    else {
        // Pay fee by change cell in outputs
        txSkeleton = await payFeeByOutput({
            outputIndex: returnExceededCapacityResult.changeCellOutputIndex,
            txSkeleton,
            feeRate: props.feeRate,
            config,
        });
    }
    return {
        txSkeleton,
        createdChangeCell: returnExceededCapacityResult.createdChangeCell,
        changeCellOutputIndex: returnExceededCapacityResult.changeCellOutputIndex,
    };
}
exports.returnExceededCapacityAndPayFee = returnExceededCapacityAndPayFee;
//# sourceMappingURL=fee.js.map