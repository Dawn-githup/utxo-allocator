"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForTransaction = exports.waitForTransactionRetryWork = exports.assertTransactionSkeletonSize = exports.assetTransactionSize = exports.isTransactionSkeletonSizeInRange = exports.isTransactionSizeInRange = exports.getTransactionSkeletonSize = exports.getTransactionSize = void 0;
const base_1 = require("@ckb-lumos/base");
const lumos_1 = require("@ckb-lumos/lumos");
const retryWork_1 = require("./retryWork");
/**
 * Calculates the size of a transaction.
 *
 * Note: Why adding 4 bytes to the size of transaction:
 * [Calculate transaction fee](https://github.com/nervosnetwork/ckb/wiki/Transaction-%C2%BB-Transaction-Fee#calculate-transaction-fee)
 */
function getTransactionSize(tx) {
    const serializedTx = base_1.blockchain.Transaction.pack(tx);
    return 4 + serializedTx.buffer.byteLength;
}
exports.getTransactionSize = getTransactionSize;
/**
 * Calculates the size of a TransactionSkeleton.
 */
function getTransactionSkeletonSize(txSkeleton) {
    const tx = lumos_1.helpers.createTransactionFromSkeleton(txSkeleton);
    return getTransactionSize(tx);
}
exports.getTransactionSkeletonSize = getTransactionSkeletonSize;
/**
 * Check if the Transaction's size (in bytes) is as expected.
 * Expected: min < size <= max.
 */
function isTransactionSizeInRange(tx, min, max) {
    const size = getTransactionSize(tx);
    return size <= (min ?? 0) || size > (max ?? Infinity);
}
exports.isTransactionSizeInRange = isTransactionSizeInRange;
/**
 * Check if the TransactionSkeleton's size (in bytes) is as expected.
 * Expected: min < size <= max.
 */
function isTransactionSkeletonSizeInRange(txSkeleton, min, max) {
    const tx = lumos_1.helpers.createTransactionFromSkeleton(txSkeleton);
    return isTransactionSizeInRange(tx, min, max);
}
exports.isTransactionSkeletonSizeInRange = isTransactionSkeletonSizeInRange;
/**
 * Throw an error if the Transaction's size (in bytes) is not as expected.
 * Expected: min < size <= max.
 */
function assetTransactionSize(tx, min, max) {
    min = min ?? 0;
    max = max ?? Infinity;
    const size = getTransactionSize(tx);
    if (size <= min) {
        throw new Error(`Expected the transaction size to be > ${min}, actual size: ${size}`);
    }
    if (size > max) {
        throw new Error(`Expected the transaction size to be <= ${max}, actual size: ${size}`);
    }
}
exports.assetTransactionSize = assetTransactionSize;
/**
 * Throw an error if the TransactionSkeleton's size (in bytes) is not as expected.
 * Expected: min < size <= max.
 */
function assertTransactionSkeletonSize(txSkeleton, min, max) {
    const tx = lumos_1.helpers.createTransactionFromSkeleton(txSkeleton);
    assetTransactionSize(tx, min, max);
}
exports.assertTransactionSkeletonSize = assertTransactionSkeletonSize;
/**
 * Wait for a transaction to be committed on the blockchain.
 * This function returns a RetryWorkResult, including detailed info like the duration of the process.
 */
async function waitForTransactionRetryWork(hash, rpc) {
    return await (0, retryWork_1.retryWork)({
        getter: () => rpc.getTransaction(hash),
        retry: 6,
        interval({ retries }) {
            return 1000 * Math.pow(2, retries);
        },
        onComplete(tx) {
            switch (tx.txStatus.status) {
                case 'rejected':
                    throw new Error(`Transaction rejected: ${hash}, reason: ${tx.txStatus.reason}`);
                case 'committed':
                    return true;
                default:
                    return false;
            }
        },
    });
}
exports.waitForTransactionRetryWork = waitForTransactionRetryWork;
/**
 * Wait for a transaction to be committed on the blockchain.
 * If waited too long or the transaction is rejected, throw an error.
 */
async function waitForTransaction(hash, rpc) {
    const fetched = await waitForTransactionRetryWork(hash, rpc);
    if (fetched.success) {
        return fetched.result;
    }
    else {
        throw new Error(`Failed to wait for transaction: ${hash}, reason: ${fetched.errors[fetched.errors.length - 1]}`);
    }
}
exports.waitForTransaction = waitForTransaction;
//# sourceMappingURL=transaction.js.map