import { BIish } from '@ckb-lumos/bi/lib';
import { BI, helpers } from '@ckb-lumos/lumos';
import { Config } from '@ckb-lumos/config-manager/lib';
import { Address, Script, Cell } from '@ckb-lumos/base/lib';
import { FromInfo } from '@ckb-lumos/common-scripts/lib';
/**
 * Calculate target cell's minimal occupied capacity by lock script.
 */
export declare function minimalCellCapacityByLock(lock: Script): BI;
/**
 * Fix cell's minimal occupied capacity by 'helpers.minimalCellCapacityCompatible' API.
 * Note: this function will modify the original cell object.
 */
export declare function correctCellMinimalCapacity(cell: Cell): Cell;
/**
 * Make sure the target cell has declared enough amount of capacity.
 */
export declare function assetCellMinimalCapacity(cell: Cell): void;
/**
 * Calculate the target cell's capacity margin.
 * Could be negative if the cell's declared capacity is not enough.
 */
export declare function getCellCapacityMargin(cell: Cell): BI;
/**
 * Set absolute capacity margin for a cell.
 * The term 'absolute' means the cell's capacity will be: 'minimal capacity' + 'capacity margin'.
 */
export declare function setAbsoluteCapacityMargin(cell: Cell, capacityMargin: BIish | ((cell: Cell, margin: BI) => BIish)): Cell;
/**
 * Count the total declared capacity in a List<Cell>.
 */
export declare function getCellsTotalCapacity(cells: Cell[]): BI;
/**
 * The snapshot result of inputs/outputs from a Transaction.
 * Note that both inputsRemainCapacity/outputsRemainCapacity can be negative.
 */
export interface CapacitySnapshot {
    inputsLength: number;
    outputsLength: number;
    inputsCapacity: BI;
    outputsCapacity: BI;
    inputsRemainCapacity: BI;
    outputsRemainCapacity: BI;
}
/**
 * Summarize the capacity/length difference between inputs/outputs of a TransactionSkeleton.
 * This is a sugar function of 'createCapacitySnapshot'.
 */
export declare function createCapacitySnapshotFromTransactionSkeleton(txSkeleton: helpers.TransactionSkeletonType): CapacitySnapshot;
/**
 * Summarize the capacity/length difference between inputs/outputs of a Transaction.
 */
export declare function createCapacitySnapshot(inputs: Cell[], outputs: Cell[]): CapacitySnapshot;
/**
 * Calculates the capacity different in inputs/outputs of a Transaction,
 * then fix the change cell's containing capacity if inputs' total capacity has any left.
 *
 * Note: normally the change cell is the last cell in Transaction.outputs,
 * but if things are different, you can also provide the change cell's output index.
 */
export declare function correctChangeCellCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    changeOutputIndex?: number;
}): helpers.TransactionSkeletonType;
/**
 * Calculate the capacity difference between inputs/outputs of a Transaction,
 * and see how much capacity is needed for the transaction to be constructed.
 */
export declare function calculateNeededCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    changeAddress: Address;
    extraCapacity?: BIish;
    config?: Config;
}): {
    snapshot: CapacitySnapshot;
    neededCapacity: BI;
    exceedCapacity: BI;
};
/**
 * Calculate the minimal required capacity for the transaction to be constructed,
 * and then collect cells to inputs, it also fills cellDeps and witnesses.
 * After collecting, it will generate an output to return unused ckb.
 */
export declare function injectNeededCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    fromInfos: FromInfo[];
    config?: Config;
    extraCapacity?: BIish;
    changeAddress?: Address;
    enableDeductCapacity?: boolean;
}): Promise<{
    txSkeleton: helpers.TransactionSkeletonType;
    before: CapacitySnapshot;
    after?: CapacitySnapshot;
}>;
/**
 * Return exceeded capacity in Transaction.inputs to Transaction.outputs as change.
 * The strategy is:
 * - If there is an unfixed last output with the same lock as change lock, then add the exceeded capacity to it.
 * - If no unfixed output with the same lock as change lock was found, generate a change cell to Transaction.outputs.
 */
export declare function returnExceededCapacity(props: {
    txSkeleton: helpers.TransactionSkeletonType;
    changeAddress: Address;
    config?: Config;
}): {
    txSkeleton: helpers.TransactionSkeletonType;
    returnedChange: boolean;
    createdChangeCell: boolean;
    changeCellOutputIndex: number;
    unreturnedCapacity: BI;
};
