"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpackToRawClusterDataV2 = exports.unpackToRawClusterDataV1 = exports.unpackToRawClusterData = exports.packRawClusterDataV2 = exports.packRawClusterDataV1 = exports.packRawClusterData = exports.ClusterDataV2 = exports.ClusterDataV1 = void 0;
const base_1 = require("@ckb-lumos/base");
const codec_1 = require("@ckb-lumos/codec");
const helpers_1 = require("../helpers");
const codec_2 = require("@ckb-lumos/codec");
exports.ClusterDataV1 = codec_1.molecule.table({
    name: base_1.blockchain.Bytes,
    description: base_1.blockchain.Bytes,
}, ['name', 'description']);
exports.ClusterDataV2 = codec_1.molecule.table({
    name: base_1.blockchain.Bytes,
    description: base_1.blockchain.Bytes,
    mutantId: base_1.blockchain.BytesOpt,
}, ['name', 'description', 'mutantId']);
function packRawClusterData(packable, version) {
    if (!version) {
        return packRawClusterDataV2(packable);
    }
    switch (version) {
        case 'v1':
            return packRawClusterDataV1(packable);
        case 'v2':
            return packRawClusterDataV2(packable);
        default:
            throw new Error(`Unsupported ClusterData version: ${version}`);
    }
}
exports.packRawClusterData = packRawClusterData;
function packRawClusterDataV1(packable) {
    return exports.ClusterDataV1.pack({
        name: (0, helpers_1.bytifyRawString)(packable.name),
        description: (0, helpers_1.bytifyRawString)(packable.description),
    });
}
exports.packRawClusterDataV1 = packRawClusterDataV1;
function packRawClusterDataV2(packable) {
    return exports.ClusterDataV2.pack({
        name: (0, helpers_1.bytifyRawString)(packable.name),
        description: (0, helpers_1.bytifyRawString)(packable.description),
        mutantId: packable.mutantId,
    });
}
exports.packRawClusterDataV2 = packRawClusterDataV2;
function unpackToRawClusterData(unpackable, version) {
    if (version) {
        switch (version) {
            case 'v1':
                return unpackToRawClusterDataV1(unpackable);
            case 'v2':
                return unpackToRawClusterDataV2(unpackable);
            default:
                throw new Error(`Unsupported ClusterData version: ${version}`);
        }
    }
    try {
        return unpackToRawClusterDataV2(unpackable);
    }
    catch {
        try {
            return unpackToRawClusterDataV1(unpackable);
        }
        catch {
            throw new Error(`Cannot unpack ClusterData, no matching molecule: ${codec_2.bytes.hexify(unpackable)}`);
        }
    }
}
exports.unpackToRawClusterData = unpackToRawClusterData;
function unpackToRawClusterDataV1(unpackable) {
    const decoded = exports.ClusterDataV1.unpack(unpackable);
    return {
        name: (0, helpers_1.bufferToRawString)(decoded.name),
        description: (0, helpers_1.bufferToRawString)(decoded.description),
    };
}
exports.unpackToRawClusterDataV1 = unpackToRawClusterDataV1;
function unpackToRawClusterDataV2(unpackable) {
    const decoded = exports.ClusterDataV2.unpack(unpackable);
    return {
        name: (0, helpers_1.bufferToRawString)(decoded.name),
        description: (0, helpers_1.bufferToRawString)(decoded.description),
        mutantId: decoded.mutantId,
    };
}
exports.unpackToRawClusterDataV2 = unpackToRawClusterDataV2;
//# sourceMappingURL=cluster.js.map