"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMap = void 0;
const tslib_1 = require("tslib");
const ckb_sdk_utils_1 = require("@nervosnetwork/ckb-sdk-utils");
const signWitnessGroup_js_1 = (0, tslib_1.__importDefault)(require("./signWitnessGroup.js"));
const groupScripts_js_1 = (0, tslib_1.__importDefault)(require("./groupScripts.js"));
const multisig_js_1 = require("./multisig.js");
const isMap = (val) => {
    return val.size !== undefined;
};
exports.isMap = isMap;
function isMultisigOption(params) {
    if (params.sk && params.blake160 && params.config && params.signatures) {
        if ((typeof params.sk === 'string' || typeof params.sk === 'function') &&
            typeof params.blake160 === 'string' &&
            Array.isArray(params.signatures) &&
            (0, multisig_js_1.isMultisigConfig)(params.config)) {
            return true;
        }
        throw new Error('Multisig options is incorrect');
    }
    throw new Error('Multisig options miss some property');
}
const signWitnesses = (key) => ({ transactionHash, witnesses = [], inputCells = [], skipMissingKeys = false, }) => {
    if (!key)
        throw new ckb_sdk_utils_1.ParameterRequiredException('Signature provider');
    if (!transactionHash)
        throw new ckb_sdk_utils_1.ParameterRequiredException('Transaction hash');
    if (!witnesses.length)
        throw new Error('Witnesses is empty');
    if ((0, exports.isMap)(key)) {
        if (!inputCells.length) {
            throw new Error(`Cell shouldn't be empty when key is Map`);
        }
        const rawWitnesses = witnesses;
        const restWitnesses = witnesses.slice(inputCells.length);
        const groupedScripts = (0, groupScripts_js_1.default)(inputCells);
        groupedScripts.forEach((indices, lockhash) => {
            const sk = key.get(lockhash);
            if (!sk) {
                if (!skipMissingKeys) {
                    throw new Error(`The signature provider to sign lockhash ${lockhash} is not found`);
                }
                else {
                    return;
                }
            }
            const ws = [...indices.map(idx => witnesses[idx]), ...restWitnesses];
            if (typeof sk === 'object' && isMultisigOption(sk)) {
                const witnessIncludeSignature = (0, signWitnessGroup_js_1.default)(sk.sk, transactionHash, ws, sk.config)[0];
                const firstWitness = rawWitnesses[indices[0]];
                if (typeof firstWitness !== 'object') {
                    throw new Error('The first witness in the group should be type of WitnessArgs');
                }
                let lockAfterSign = witnessIncludeSignature.lock;
                if (firstWitness.lock) {
                    lockAfterSign = firstWitness.lock + (lockAfterSign === null || lockAfterSign === void 0 ? void 0 : lockAfterSign.slice(2));
                }
                else {
                    lockAfterSign = (0, multisig_js_1.serializeMultisigConfig)(sk.config) + (lockAfterSign === null || lockAfterSign === void 0 ? void 0 : lockAfterSign.slice(2));
                }
                const firstWitSigned = Object.assign(Object.assign({}, firstWitness), { lock: lockAfterSign });
                rawWitnesses[indices[0]] = firstWitSigned;
                if ((0, multisig_js_1.getMultisigStatus)(sk.config, [...sk.signatures, sk.blake160]) === multisig_js_1.SignStatus.Signed) {
                    indices.forEach(idx => {
                        const wit = rawWitnesses[idx];
                        rawWitnesses[idx] = typeof wit === 'string' ? wit : (0, ckb_sdk_utils_1.serializeWitnessArgs)(wit);
                    });
                }
            }
            else {
                const witnessIncludeSignature = (0, signWitnessGroup_js_1.default)(sk, transactionHash, ws)[0];
                rawWitnesses[indices[0]] = witnessIncludeSignature;
            }
        });
        return rawWitnesses;
    }
    const signedWitnesses = (0, signWitnessGroup_js_1.default)(key, transactionHash, witnesses);
    return signedWitnesses;
};
exports.default = signWitnesses;
//# sourceMappingURL=signWitnesses.js.map