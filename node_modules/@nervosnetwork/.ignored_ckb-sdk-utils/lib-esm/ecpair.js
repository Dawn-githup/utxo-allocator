import elliptic from 'elliptic';
import { hexToBytes } from './convertors/index.js';
import { HexStringWithout0xException, ParameterRequiredException, PrivateKeyLenException, SignMessageException, } from './exceptions/index.js';
const ec = new elliptic.ec('secp256k1');
class ECPair {
    constructor(sk, { compressed = true } = {
        compressed: true,
    }) {
        this.compressed = false;
        this.getPrivateKey = (enc = 'hex') => {
            if (enc === 'hex') {
                return this.privateKey;
            }
            return this.key.getPrivate(enc);
        };
        this.getPublicKey = (enc) => {
            if (enc === 'hex') {
                return this.publicKey;
            }
            return this.key.getPublic(this.compressed, enc);
        };
        this.sign = (message) => {
            const msg = typeof message === 'string' ? hexToBytes(message) : message;
            return `0x${this.key
                .sign(msg, {
                canonical: true,
            })
                .toDER('hex')}`;
        };
        this.verify = (message, sig) => {
            const msg = typeof message === 'string' ? hexToBytes(message) : message;
            const signature = typeof sig === 'string' ? hexToBytes(sig) : sig;
            return this.key.verify(msg, signature);
        };
        this.signRecoverable = (message) => {
            const msg = typeof message === 'string' ? hexToBytes(message) : message;
            const { r, s, recoveryParam } = this.key.sign(msg, {
                canonical: true,
            });
            if (recoveryParam === null)
                throw new SignMessageException();
            const fmtR = r.toString(16).padStart(64, '0');
            const fmtS = s.toString(16).padStart(64, '0');
            return `0x${fmtR}${fmtS}0${recoveryParam}`;
        };
        if (sk === undefined)
            throw new ParameterRequiredException('Private key');
        if (typeof sk === 'string' && !sk.startsWith('0x')) {
            throw new HexStringWithout0xException(sk);
        }
        if (typeof sk === 'string' && sk.length !== 66) {
            throw new PrivateKeyLenException();
        }
        if (typeof sk === 'object' && sk.byteLength !== 32) {
            throw new PrivateKeyLenException();
        }
        this.key = ec.keyFromPrivate(typeof sk === 'string' ? sk.replace(/^0x/, '') : sk);
        this.compressed = compressed;
    }
    get privateKey() {
        return `0x${this.key.getPrivate('hex').padStart(64, '0')}`;
    }
    get publicKey() {
        return `0x${this.key.getPublic(this.compressed, 'hex')}`;
    }
}
export default ECPair;
//# sourceMappingURL=ecpair.js.map