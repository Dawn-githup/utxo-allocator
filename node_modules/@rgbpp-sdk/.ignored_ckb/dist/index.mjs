// src/schemas/generated/blockchain.ts
import { bytes, createFixedBytesCodec as createFixedBytesCodec2, molecule } from "@ckb-lumos/codec";

// src/schemas/customized.ts
import { createFixedBytesCodec, number } from "@ckb-lumos/codec";
var { Uint32, Uint64, Uint128 } = number;
var HashType = createFixedBytesCodec({
  byteLength: 1,
  // prettier-ignore
  pack: (hashType) => {
    if (hashType === "type") return new Uint8Array([1]);
    if (hashType === "data") return new Uint8Array([0]);
    if (hashType === "data1") return new Uint8Array([2]);
    if (hashType === "data2") return new Uint8Array([4]);
    throw new Error("Unknown hash type");
  },
  unpack: (byte3) => {
    if (byte3[0] === 1) return "type";
    if (byte3[0] === 0) return "data";
    if (byte3[0] === 2) return "data1";
    if (byte3[0] === 4) return "data2";
    throw new Error("Unknown hash type");
  }
});
var DepType = createFixedBytesCodec({
  byteLength: 1,
  // prettier-ignore
  pack: (depType) => {
    if (depType === "code") return new Uint8Array([0]);
    if (depType === "depGroup") return new Uint8Array([1]);
    throw new Error("Unknown dep type");
  },
  unpack: (byte3) => {
    if (byte3[0] === 0) return "code";
    if (byte3[0] === 1) return "depGroup";
    throw new Error("Unknown dep type");
  }
});

// src/schemas/generated/blockchain.ts
var { array, vector, union, option, struct, table, byteVecOf } = molecule;
var fallbackBytesCodec = byteVecOf({ pack: bytes.bytify, unpack: bytes.hexify });
function createFallbackFixedBytesCodec(byteLength) {
  return createFixedBytesCodec2({
    pack: bytes.bytify,
    unpack: bytes.hexify,
    byteLength
  });
}
var byte = createFallbackFixedBytesCodec(1);
var Byte32 = createFallbackFixedBytesCodec(32);
var Uint256 = createFallbackFixedBytesCodec(32);
var Bytes = fallbackBytesCodec;
var BytesOpt = option(Bytes);
var BytesOptVec = vector(BytesOpt);
var BytesVec = vector(Bytes);
var Byte32Vec = vector(Byte32);
var ProposalShortId = createFallbackFixedBytesCodec(10);
var ProposalShortIdVec = vector(ProposalShortId);
var Script = table(
  {
    codeHash: Byte32,
    hashType: byte,
    args: Bytes
  },
  ["codeHash", "hashType", "args"]
);
var OutPoint = struct(
  {
    txHash: Byte32,
    index: Uint32
  },
  ["txHash", "index"]
);
var CellInput = struct(
  {
    since: Uint64,
    previousOutput: OutPoint
  },
  ["since", "previousOutput"]
);
var CellDep = struct(
  {
    outPoint: OutPoint,
    depType: byte
  },
  ["outPoint", "depType"]
);
var RawHeader = struct(
  {
    version: Uint32,
    compactTarget: Uint32,
    timestamp: Uint64,
    number: Uint64,
    epoch: Uint64,
    parentHash: Byte32,
    transactionsRoot: Byte32,
    proposalsHash: Byte32,
    extraHash: Byte32,
    dao: Byte32
  },
  [
    "version",
    "compactTarget",
    "timestamp",
    "number",
    "epoch",
    "parentHash",
    "transactionsRoot",
    "proposalsHash",
    "extraHash",
    "dao"
  ]
);
var Header = struct(
  {
    raw: RawHeader,
    nonce: Uint128
  },
  ["raw", "nonce"]
);
var UncleBlock = table(
  {
    header: Header,
    proposals: ProposalShortIdVec
  },
  ["header", "proposals"]
);
var CellbaseWitness = table(
  {
    lock: Script,
    message: Bytes
  },
  ["lock", "message"]
);
var WitnessArgs = table(
  {
    lock: BytesOpt,
    inputType: BytesOpt,
    outputType: BytesOpt
  },
  ["lock", "inputType", "outputType"]
);
var ScriptOpt = option(Script);
var UncleBlockVec = vector(UncleBlock);
var CellDepVec = vector(CellDep);
var CellInputVec = vector(CellInput);
var CellOutput = table(
  {
    capacity: Uint64,
    lock: Script,
    type_: ScriptOpt
  },
  ["capacity", "lock", "type_"]
);
var CellOutputVec = vector(CellOutput);
var RawTransaction = table(
  {
    version: Uint32,
    cellDeps: CellDepVec,
    headerDeps: Byte32Vec,
    inputs: CellInputVec,
    outputs: CellOutputVec,
    outputsData: BytesVec
  },
  ["version", "cellDeps", "headerDeps", "inputs", "outputs", "outputsData"]
);
var Transaction = table(
  {
    raw: RawTransaction,
    witnesses: BytesVec
  },
  ["raw", "witnesses"]
);
var TransactionVec = vector(Transaction);
var Block = table(
  {
    header: Header,
    uncles: UncleBlockVec,
    transactions: TransactionVec,
    proposals: ProposalShortIdVec
  },
  ["header", "uncles", "transactions", "proposals"]
);
var BlockV1 = table(
  {
    header: Header,
    uncles: UncleBlockVec,
    transactions: TransactionVec,
    proposals: ProposalShortIdVec,
    extension: Bytes
  },
  ["header", "uncles", "transactions", "proposals", "extension"]
);

// src/schemas/generated/rgbpp.ts
import { bytes as bytes2, createFixedBytesCodec as createFixedBytesCodec3, molecule as molecule2 } from "@ckb-lumos/codec";
var { array: array2, vector: vector2, union: union2, option: option2, struct: struct2, table: table2, byteVecOf: byteVecOf2 } = molecule2;
var fallbackBytesCodec2 = byteVecOf2({ pack: bytes2.bytify, unpack: bytes2.hexify });
function createFallbackFixedBytesCodec2(byteLength) {
  return createFixedBytesCodec3({
    pack: bytes2.bytify,
    unpack: bytes2.hexify,
    byteLength
  });
}
var byte2 = createFallbackFixedBytesCodec2(1);
var RGBPPConfig = struct2(
  {
    btcLcTypeHash: Byte32,
    btcTimeLockTypeHash: Byte32
  },
  ["btcLcTypeHash", "btcTimeLockTypeHash"]
);
var RGBPPLock = struct2(
  {
    outIndex: Uint32,
    btcTxid: Byte32
  },
  ["outIndex", "btcTxid"]
);
var ExtraCommitmentData = struct2(
  {
    inputLen: byte2,
    outputLen: byte2
  },
  ["inputLen", "outputLen"]
);
var Uint16 = createFallbackFixedBytesCodec2(2);
var RGBPPUnlock = table2(
  {
    version: Uint16,
    extraData: ExtraCommitmentData,
    btcTx: Bytes,
    btcTxProof: Bytes
  },
  ["version", "extraData", "btcTx", "btcTxProof"]
);
var BTCTimeLock = table2(
  {
    lockScript: Script,
    after: Uint32,
    btcTxid: Byte32
  },
  ["lockScript", "after", "btcTxid"]
);
var BTCTimeLockConfig = struct2(
  {
    btcLcTypeHash: Byte32
  },
  ["btcLcTypeHash"]
);
var BTCTimeUnlock = table2(
  {
    btcTxProof: Bytes
  },
  ["btcTxProof"]
);

// src/collector/index.ts
import axios2 from "axios";
import CKB from "@nervosnetwork/ckb-sdk-core";

// src/constants/index.ts
var CKB_UNIT = BigInt(1e8);
var MAX_FEE = BigInt(2e7);
var MIN_CAPACITY = BigInt(61) * BigInt(1e8);
var SECP256K1_WITNESS_LOCK_SIZE = 65;
var BTC_JUMP_CONFIRMATION_BLOCKS = 6;
var RGBPP_TX_WITNESS_MAX_SIZE = 5e3;
var RGBPP_TX_INPUTS_MAX_LENGTH = 40;
var RGBPP_WITNESS_PLACEHOLDER = "0xFF";
var RGBPP_TX_ID_PLACEHOLDER = "0000000000000000000000000000000000000000000000000000000000000000";
var TestnetInfo = {
  Secp256k1LockDep: {
    outPoint: {
      txHash: "0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37",
      index: "0x0"
    },
    depType: "depGroup"
  },
  RgbppLockScript: {
    codeHash: "0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248",
    hashType: "type",
    args: ""
  },
  RgbppLockDep: {
    outPoint: { txHash: "0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00", index: "0x0" },
    depType: "code"
  },
  RgbppLockConfigDep: {
    outPoint: { txHash: "0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00", index: "0x1" },
    depType: "code"
  },
  BtcTimeLockScript: {
    codeHash: "0x00cdf8fab0f8ac638758ebf5ea5e4052b1d71e8a77b9f43139718621f6849326",
    hashType: "type",
    args: ""
  },
  BtcTimeLockDep: {
    outPoint: { txHash: "0xde0f87878a97500f549418e5d46d2f7704c565a262aa17036c9c1c13ad638529", index: "0x0" },
    depType: "code"
  },
  BtcTimeLockConfigDep: {
    outPoint: { txHash: "0xde0f87878a97500f549418e5d46d2f7704c565a262aa17036c9c1c13ad638529", index: "0x1" },
    depType: "code"
  },
  XUDTTypeScript: {
    codeHash: "0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb",
    hashType: "type",
    args: ""
  },
  XUDTTypeDep: {
    outPoint: {
      txHash: "0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f",
      index: "0x0"
    },
    depType: "code"
  },
  UniqueTypeScript: {
    codeHash: "0x8e341bcfec6393dcd41e635733ff2dca00a6af546949f70c57a706c0f344df8b",
    hashType: "type",
    args: ""
  },
  UniqueTypeDep: {
    outPoint: {
      txHash: "0xff91b063c78ed06f10a1ed436122bd7d671f9a72ef5f5fa28d05252c17cf4cef",
      index: "0x0"
    },
    depType: "code"
  },
  ClusterTypeScript: {
    codeHash: "0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058",
    hashType: "data1",
    args: ""
  },
  ClusterTypeDep: {
    outPoint: {
      txHash: "0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a",
      index: "0x0"
    },
    depType: "code"
  },
  SporeTypeScript: {
    codeHash: "0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d",
    hashType: "data1",
    args: ""
  },
  SporeTypeDep: {
    outPoint: {
      txHash: "0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f",
      index: "0x0"
    },
    depType: "code"
  },
  // The CKB testnet RGB++ deployment information for the BTC Signet network
  RgbppSignetLockScript: {
    codeHash: "0xd07598deec7ce7b5665310386b4abd06a6d48843e953c5cc2112ad0d5a220364",
    hashType: "type",
    args: ""
  },
  RgbppSignetLockDep: {
    outPoint: { txHash: "0x61efdeddbaa0bb4132c0eb174b3e8002ff5ec430f61ba46f30768d683c516eec", index: "0x0" },
    depType: "code"
  },
  RgbppSignetLockConfigDep: {
    outPoint: { txHash: "0x61efdeddbaa0bb4132c0eb174b3e8002ff5ec430f61ba46f30768d683c516eec", index: "0x1" },
    depType: "code"
  },
  BtcTimeSignetLockScript: {
    codeHash: "0x80a09eca26d77cea1f5a69471c59481be7404febf40ee90f886c36a948385b55",
    hashType: "type",
    args: ""
  },
  BtcTimeSignetLockDep: {
    outPoint: { txHash: "0x5364b3535965e9eac9a35dd7af8e9e45a61d30a16e115923c032f80b28783e21", index: "0x0" },
    depType: "code"
  },
  BtcTimeSignetLockConfigDep: {
    outPoint: { txHash: "0x5364b3535965e9eac9a35dd7af8e9e45a61d30a16e115923c032f80b28783e21", index: "0x1" },
    depType: "code"
  }
};
var MainnetInfo = {
  Secp256k1LockDep: {
    outPoint: {
      txHash: "0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c",
      index: "0x0"
    },
    depType: "depGroup"
  },
  RgbppLockScript: {
    codeHash: "0xbc6c568a1a0d0a09f6844dc9d74ddb4343c32143ff25f727c59edf4fb72d6936",
    hashType: "type",
    args: ""
  },
  RgbppLockDep: {
    outPoint: { txHash: "0x04c5c3e69f1aa6ee27fb9de3d15a81704e387ab3b453965adbe0b6ca343c6f41", index: "0x0" },
    depType: "code"
  },
  RgbppLockConfigDep: {
    outPoint: { txHash: "0x04c5c3e69f1aa6ee27fb9de3d15a81704e387ab3b453965adbe0b6ca343c6f41", index: "0x1" },
    depType: "code"
  },
  BtcTimeLockScript: {
    codeHash: "0x70d64497a075bd651e98ac030455ea200637ee325a12ad08aff03f1a117e5a62",
    hashType: "type",
    args: ""
  },
  BtcTimeLockDep: {
    outPoint: { txHash: "0x6257bf4297ee75fcebe2654d8c5f8d93bc9fc1b3dc62b8cef54ffe166162e996", index: "0x0" },
    depType: "code"
  },
  BtcTimeLockConfigDep: {
    outPoint: { txHash: "0x6257bf4297ee75fcebe2654d8c5f8d93bc9fc1b3dc62b8cef54ffe166162e996", index: "0x1" },
    depType: "code"
  },
  XUDTTypeScript: {
    codeHash: "0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95",
    hashType: "data1",
    args: ""
  },
  XUDTTypeDep: {
    outPoint: {
      txHash: "0xc07844ce21b38e4b071dd0e1ee3b0e27afd8d7532491327f39b786343f558ab7",
      index: "0x0"
    },
    depType: "code"
  },
  UniqueTypeScript: {
    codeHash: "0x2c8c11c985da60b0a330c61a85507416d6382c130ba67f0c47ab071e00aec628",
    hashType: "data1",
    args: ""
  },
  UniqueTypeDep: {
    outPoint: {
      txHash: "0x67524c01c0cb5492e499c7c7e406f2f9d823e162d6b0cf432eacde0c9808c2ad",
      index: "0x0"
    },
    depType: "code"
  },
  ClusterTypeScript: {
    codeHash: "0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075",
    hashType: "data1",
    args: ""
  },
  ClusterTypeDep: {
    outPoint: {
      txHash: "0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938",
      index: "0x0"
    },
    depType: "code"
  },
  SporeTypeScript: {
    codeHash: "0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5",
    hashType: "data1",
    args: ""
  },
  SporeTypeDep: {
    outPoint: {
      txHash: "0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824",
      index: "0x0"
    },
    depType: "code"
  }
};
var UNLOCKABLE_LOCK_SCRIPT = {
  codeHash: "0x0000000000000000000000000000000000000000000000000000000000000000",
  hashType: "data",
  args: "0x"
};
var getSecp256k1CellDep = (isMainnet) => isMainnet ? MainnetInfo.Secp256k1LockDep : TestnetInfo.Secp256k1LockDep;
var getXudtTypeScript = (isMainnet) => isMainnet ? MainnetInfo.XUDTTypeScript : TestnetInfo.XUDTTypeScript;
var getXudtDep = (isMainnet) => isMainnet ? MainnetInfo.XUDTTypeDep : TestnetInfo.XUDTTypeDep;
var getRgbppLockScript = (isMainnet, btcTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.RgbppLockScript;
  }
  return btcTestnetType === "Signet" ? TestnetInfo.RgbppSignetLockScript : TestnetInfo.RgbppLockScript;
};
var getRgbppLockDep = (isMainnet, btcTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.RgbppLockDep;
  }
  return btcTestnetType === "Signet" ? TestnetInfo.RgbppSignetLockDep : TestnetInfo.RgbppLockDep;
};
var getRgbppLockConfigDep = (isMainnet, btcTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.RgbppLockConfigDep;
  }
  return btcTestnetType === "Signet" ? TestnetInfo.RgbppSignetLockConfigDep : TestnetInfo.RgbppLockConfigDep;
};
var getBtcTimeLockScript = (isMainnet, btcTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.BtcTimeLockScript;
  }
  return btcTestnetType === "Signet" ? TestnetInfo.BtcTimeSignetLockScript : TestnetInfo.BtcTimeLockScript;
};
var getBtcTimeLockDep = (isMainnet, btcTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.BtcTimeLockDep;
  }
  return btcTestnetType === "Signet" ? TestnetInfo.BtcTimeSignetLockDep : TestnetInfo.BtcTimeLockDep;
};
var getBtcTimeLockConfigDep = (isMainnet, btcTestnetType) => {
  if (isMainnet) {
    return MainnetInfo.BtcTimeLockConfigDep;
  }
  return btcTestnetType === "Signet" ? TestnetInfo.BtcTimeSignetLockConfigDep : TestnetInfo.BtcTimeLockConfigDep;
};
var getUniqueTypeScript = (isMainnet) => isMainnet ? MainnetInfo.UniqueTypeScript : TestnetInfo.UniqueTypeScript;
var getUniqueTypeDep = (isMainnet) => isMainnet ? MainnetInfo.UniqueTypeDep : TestnetInfo.UniqueTypeDep;
var getClusterTypeScript = (isMainnet) => isMainnet ? MainnetInfo.ClusterTypeScript : TestnetInfo.ClusterTypeScript;
var getClusterTypeDep = (isMainnet) => isMainnet ? MainnetInfo.ClusterTypeDep : TestnetInfo.ClusterTypeDep;
var getSporeTypeScript = (isMainnet) => isMainnet ? MainnetInfo.SporeTypeScript : TestnetInfo.SporeTypeScript;
var getSporeTypeDep = (isMainnet) => isMainnet ? MainnetInfo.SporeTypeDep : TestnetInfo.SporeTypeDep;

// src/error/index.ts
var CapacityNotEnoughError = class extends Error {
  code = 100 /* CapacityNotEnough */;
  constructor(message) {
    super(message);
  }
};
var IndexerError = class extends Error {
  code = 101 /* IndexerRpcError */;
  constructor(message) {
    super(message);
  }
};
var NoLiveCellError = class extends Error {
  code = 102 /* NoLiveCell */;
  constructor(message) {
    super(message);
  }
};
var NoXudtLiveCellError = class extends Error {
  code = 103 /* NoXudtLiveCell */;
  constructor(message) {
    super(message);
  }
};
var NoRgbppLiveCellError = class extends Error {
  code = 104 /* NoRgbppLiveCell */;
  constructor(message) {
    super(message);
  }
};
var UdtAmountNotEnoughError = class extends Error {
  code = 105 /* UdtAmountNotEnough */;
  constructor(message) {
    super(message);
  }
};
var InputsCapacityNotEnoughError = class extends Error {
  code = 106 /* InputsCapacityNotEnough */;
  constructor(message) {
    super(message);
  }
};
var TypeAssetNotSupportedError = class extends Error {
  code = 107 /* TypeAssetNotSupported */;
  constructor(message) {
    super(message);
  }
};
var InputsOrOutputsLenError = class extends Error {
  code = 108 /* InputsOrOutputsLenInvalid */;
  constructor(message) {
    super(message);
  }
};
var RgbppCkbTxInputsExceededError = class extends Error {
  code = 109 /* RgbppCkbTxInputsExceeded */;
  constructor(message) {
    super(message);
  }
};
var RgbppUtxoBindMultiTypeAssetsError = class extends Error {
  code = 110 /* RgbppUtxoBindMultiTypeAssets */;
  constructor(message) {
    super(message);
  }
};
var RgbppSporeTypeMismatchError = class extends Error {
  code = 111 /* RgbppSporeTypeMismatch */;
  constructor(message) {
    super(message);
  }
};
var InvalidCellIdError = class extends Error {
  code = 112 /* InvalidCellId */;
  constructor(message) {
    super(message);
  }
};

// src/utils/case-parser.ts
import camelcaseKeys from "camelcase-keys";
var toCamelcase = (obj) => {
  try {
    return camelcaseKeys(obj, {
      deep: true
    });
  } catch (error) {
    console.error(error);
  }
  return null;
};

// src/utils/hex.ts
import { hexToBytes, bytesToHex } from "@nervosnetwork/ckb-sdk-utils";
var remove0x = (hex) => {
  if (hex.startsWith("0x")) {
    return hex.substring(2);
  }
  return hex;
};
var append0x = (hex) => {
  return hex?.startsWith("0x") ? hex : `0x${hex}`;
};
var ArrayBufferToHex = (arrayBuffer) => {
  return Array.prototype.map.call(new Uint8Array(arrayBuffer), (x) => ("00" + x.toString(16)).slice(-2)).join("");
};
var u8ToHex = (u8) => {
  const buffer = new ArrayBuffer(1);
  const view = new DataView(buffer);
  view.setUint8(0, u8);
  return ArrayBufferToHex(buffer);
};
var u16ToLe = (u16) => {
  const buffer = new ArrayBuffer(2);
  const view = new DataView(buffer);
  view.setUint16(0, u16, true);
  return ArrayBufferToHex(buffer);
};
var u32ToHex = (u32, littleEndian) => {
  const buffer = new ArrayBuffer(4);
  const view = new DataView(buffer);
  view.setUint32(0, Number(u32), littleEndian);
  return ArrayBufferToHex(buffer);
};
var u32ToBe = (u32) => {
  return u32ToHex(u32, false);
};
var u32ToLe = (u32) => {
  return u32ToHex(u32, true);
};
var u32ToLeHex = (u32) => {
  const hex = u32ToBe(u32);
  const le = reverseHex(parseInt(hex, 16).toString(16));
  return append0x(parseInt(le, 16).toString(16));
};
var leToU32 = (leHex) => {
  const bytes3 = hexToBytes(append0x(leHex));
  const beHex = `0x${bytes3.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, "0"), "")}`;
  return parseInt(beHex, 16);
};
var u64ToLe = (u64) => {
  const val = u64.toString(16).padStart(16, "0");
  const viewLeft = u32ToLe(`0x${val.slice(8)}`);
  const viewRight = u32ToLe(`0x${val.slice(0, 8)}`);
  return `${viewLeft}${viewRight}`;
};
var u128ToLe = (u128) => {
  const val = u128.toString(16).padStart(32, "0");
  const viewLeft = u64ToLe(BigInt(`0x${val.slice(16)}`));
  const viewRight = u64ToLe(BigInt(`0x${val.slice(0, 16)}`));
  return `${viewLeft}${viewRight}`;
};
var leToU128 = (leHex) => {
  const bytes3 = hexToBytes(append0x(leHex));
  const beHex = `0x${bytes3.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, "0"), "")}`;
  return BigInt(beHex);
};
var utf8ToHex = (text) => {
  let result = text.trim();
  if (result.startsWith("0x")) {
    return result;
  }
  result = bytesToHex(new TextEncoder().encode(result));
  return result;
};
var hexToUtf8 = (hex) => {
  let result = hex.trim();
  try {
    result = new TextDecoder().decode(hexToBytes(result));
  } catch (error) {
    console.error("hexToUtf8 error:", error);
  }
  return result;
};
var reverseHex = (str) => {
  return bytesToHex(hexToBytes(append0x(str)).reverse());
};

// src/utils/ckb-tx.ts
import { PERSONAL, blake2b, hexToBytes as hexToBytes3, serializeInput, serializeScript as serializeScript2 } from "@nervosnetwork/ckb-sdk-utils";
import { packRawClusterData, packRawSporeData } from "@spore-sdk/core";

// src/utils/rgbpp.ts
import { sha256 } from "js-sha256";
import { blockchain } from "@ckb-lumos/base";
import {
  bytesToHex as bytesToHex2,
  hexToBytes as hexToBytes2,
  serializeOutPoint,
  serializeOutput,
  serializeScript
} from "@nervosnetwork/ckb-sdk-utils";
var genRgbppLockScript = (rgbppLockArgs, isMainnet, btcTestnetType) => {
  return {
    ...getRgbppLockScript(isMainnet, btcTestnetType),
    args: append0x(rgbppLockArgs)
  };
};
var genBtcTimeLockArgs = (lock, btcTxId, after) => {
  const btcTxid = blockchain.Byte32.pack(reverseHex(btcTxId));
  const lockScript = Script.unpack(serializeScript(lock));
  return bytesToHex2(BTCTimeLock.pack({ lockScript, after, btcTxid }));
};
var genBtcTimeLockScript = (toLock, isMainnet, btcTestnetType, btcConfirmationBlocks) => {
  const args = genBtcTimeLockArgs(
    toLock,
    RGBPP_TX_ID_PLACEHOLDER,
    btcConfirmationBlocks ?? BTC_JUMP_CONFIRMATION_BLOCKS
  );
  return {
    ...getBtcTimeLockScript(isMainnet, btcTestnetType),
    args
  };
};
var MAX_RGBPP_CELL_NUM = 255;
var calculateCommitment = (rgbppVirtualTx) => {
  const hash = sha256.create();
  hash.update(hexToBytes2(utf8ToHex("RGB++")));
  const version = [0, 0];
  hash.update(version);
  const { inputs, outputs, outputsData } = rgbppVirtualTx;
  if (inputs.length > MAX_RGBPP_CELL_NUM || outputs.length > MAX_RGBPP_CELL_NUM) {
    throw new InputsOrOutputsLenError(
      "The inputs or outputs length of RGB++ CKB virtual tx cannot be greater than 255"
    );
  }
  hash.update([inputs.length, outputs.length]);
  for (const input of inputs) {
    hash.update(hexToBytes2(serializeOutPoint(input.previousOutput)));
  }
  for (let index = 0; index < outputs.length; index++) {
    const output = outputs[index];
    const outputData = outputsData[index];
    hash.update(hexToBytes2(serializeOutput(output)));
    const outputDataLen = u32ToLe(remove0x(outputData).length / 2);
    hash.update(hexToBytes2(append0x(outputDataLen)));
    hash.update(hexToBytes2(outputData));
  }
  return sha256(hash.array());
};
var lockScriptFromBtcTimeLockArgs = (args) => {
  const { lockScript } = BTCTimeLock.unpack(append0x(args));
  return {
    ...lockScript,
    hashType: HashType.unpack(lockScript.hashType)
  };
};
var btcTxIdAndAfterFromBtcTimeLockArgs = (args) => {
  const { btcTxid, after } = BTCTimeLock.unpack(append0x(args));
  console.log(btcTxid);
  console.log(after);
  return {
    btcTxId: reverseHex(append0x(btcTxid)),
    after
  };
};
var buildRgbppLockArgs = (outIndex, btcTxId) => {
  return `0x${u32ToLe(outIndex)}${remove0x(reverseHex(btcTxId))}`;
};
var buildPreLockArgs = (outIndex) => {
  return buildRgbppLockArgs(outIndex, RGBPP_TX_ID_PLACEHOLDER);
};
var unpackRgbppLockArgs = (source) => {
  const unpacked = RGBPPLock.unpack(source);
  return {
    btcTxId: reverseHex(unpacked.btcTxid),
    outIndex: unpacked.outIndex
  };
};
var compareInputs = (a, b) => {
  if (a.output.lock.args < b.output.lock.args) {
    return -1;
  }
  if (a.output.lock.args > b.output.lock.args) {
    return 1;
  }
  return 0;
};
var RGBPP_MIN_LOCK_ARGS_SIZE = 36 * 2;
var BTC_TX_ID_SIZE = 32 * 2;
var replaceLockArgsWithRealBtcTxId = (lockArgs, txId) => {
  const argsLength = remove0x(lockArgs).length;
  if (argsLength < RGBPP_MIN_LOCK_ARGS_SIZE) {
    throw new Error("Rgbpp lock args or BTC time lock args length is invalid");
  }
  return `0x${remove0x(lockArgs).substring(0, argsLength - BTC_TX_ID_SIZE)}${remove0x(reverseHex(txId))}`;
};
var BTC_TESTNETS = ["Testnet3", "Signet"];
var isLockEqual = (lock1, lock2) => lock1.codeHash === lock2.codeHash && lock1.hashType === lock2.hashType;
var isRgbppLockCell = (cell, isMainnet) => {
  if (isMainnet) {
    return isLockEqual(cell.lock, getRgbppLockScript(isMainnet));
  }
  return BTC_TESTNETS.some((network) => isLockEqual(cell.lock, getRgbppLockScript(isMainnet, network)));
};
var isRgbppLockCellIgnoreChain = (cell) => {
  return isRgbppLockCell(cell, true) || isRgbppLockCell(cell, false);
};
var isBtcTimeLockCell = (cell, isMainnet) => {
  if (isMainnet) {
    return isLockEqual(cell.lock, getBtcTimeLockScript(isMainnet));
  }
  return BTC_TESTNETS.some((network) => isLockEqual(cell.lock, getBtcTimeLockScript(isMainnet, network)));
};
var isRgbppLockOrBtcTimeLock = (lock, isMainnet) => {
  if (isMainnet) {
    return isLockEqual(lock, getRgbppLockScript(isMainnet)) || isLockEqual(lock, getBtcTimeLockScript(isMainnet));
  }
  return BTC_TESTNETS.flatMap((network) => [
    getRgbppLockScript(isMainnet, network),
    getBtcTimeLockScript(isMainnet, network)
  ]).some((script) => isLockEqual(script, lock));
};
var transformSpvProof = (spvProof) => {
  return toCamelcase(spvProof);
};
var buildSpvClientCellDep = (spvClient) => {
  const cellDep = {
    outPoint: spvClient,
    depType: "code"
  };
  return cellDep;
};
var estimateWitnessSize = (rgbppLockArgsList) => {
  const rgbppLockArgsSet = new Set(rgbppLockArgsList);
  const inputsGroupSize = rgbppLockArgsSet.size;
  return RGBPP_TX_WITNESS_MAX_SIZE * inputsGroupSize;
};
var encodeRgbppTokenInfo = (tokenInfo) => {
  const decimal = u8ToHex(tokenInfo.decimal);
  const name = remove0x(utf8ToHex(tokenInfo.name));
  const nameSize = u8ToHex(name.length / 2);
  const symbol = remove0x(utf8ToHex(tokenInfo.symbol));
  const symbolSize = u8ToHex(symbol.length / 2);
  return `0x${decimal}${nameSize}${name}${symbolSize}${symbol}`;
};
var calculateRgbppTokenInfoSize = (tokenInfo) => {
  const encodedTokenInfo = encodeRgbppTokenInfo(tokenInfo);
  return BigInt(remove0x(encodedTokenInfo).length / 2);
};
var throwErrorWhenTxInputsExceeded = (inputLen) => {
  if (inputLen > RGBPP_TX_INPUTS_MAX_LENGTH) {
    throw new RgbppCkbTxInputsExceededError(`Please ensure the tx inputs do not exceed ${RGBPP_TX_INPUTS_MAX_LENGTH}`);
  }
};
var throwErrorWhenRgbppCellsInvalid = (cells, xudtTypeBytes, isMainnet) => {
  if (!cells || cells.length === 0) {
    throw new NoRgbppLiveCellError("No rgbpp cells found with the rgbpp lock args");
  }
  const typeCells = cells.filter((cell) => !!cell.output.type);
  if (typeCells.length === 0) {
    throw new NoRgbppLiveCellError("No rgbpp cells found with the rgbpp lock args");
  }
  const isUDTTypeNotSupported = typeCells.some(
    (cell) => cell.output.type && !isUDTTypeSupported(cell.output.type, isMainnet)
  );
  if (isUDTTypeNotSupported) {
    throw new RgbppUtxoBindMultiTypeAssetsError(
      "The BTC UTXO must not be bound to xUDT and other type cells at the same time"
    );
  }
  const isTargetExist = typeCells.some((cell) => isScriptEqual(cell.output.type, xudtTypeBytes));
  if (!isTargetExist) {
    throw new NoRgbppLiveCellError("No rgbpp cells found with the xudt type script and the rgbpp lock args");
  }
};
var isRgbppCapacitySufficientForChange = (sumUdtInputsCapacity, receiverOutputCapacity) => {
  const rgbppOccupiedCapacity = calculateRgbppCellCapacity();
  return sumUdtInputsCapacity > receiverOutputCapacity + rgbppOccupiedCapacity;
};

// src/utils/ckb-tx.ts
var calculateTransactionFee = (txSize, feeRate) => {
  const rate = feeRate ?? BigInt(1100);
  const ratio = BigInt(1e3);
  const base = BigInt(txSize) * rate;
  const fee = base / ratio;
  return fee * ratio < base ? fee + BigInt(1) : fee;
};
var isUDTTypeSupported = (type, isMainnet) => {
  const xudtType = serializeScript2(getXudtTypeScript(isMainnet));
  const typeAsset = serializeScript2({
    ...type,
    args: ""
  });
  return xudtType === typeAsset;
};
var isSporeTypeSupported = (type, isMainnet) => {
  const sporeType = serializeScript2(getSporeTypeScript(isMainnet));
  const typeAsset = serializeScript2({
    ...type,
    args: ""
  });
  return sporeType === typeAsset;
};
var isClusterSporeTypeSupported = (type, isMainnet) => {
  const typeAsset = serializeScript2({
    ...type,
    args: ""
  });
  const clusterType = serializeScript2(getClusterTypeScript(isMainnet));
  return isSporeTypeSupported(type, isMainnet) || clusterType === typeAsset;
};
var isTypeAssetSupported = (type, isMainnet) => {
  return isUDTTypeSupported(type, isMainnet) || isClusterSporeTypeSupported(type, isMainnet);
};
var CELL_CAPACITY_SIZE = 8;
var UDT_CELL_DATA_SIZE = 16;
var LOCK_ARGS_HEX_MAX_SIZE = 26;
var isLockArgsSizeExceeded = (args) => remove0x(args).length > LOCK_ARGS_HEX_MAX_SIZE * 2;
var BTC_TIME_CELL_INCREASED_SIZE = 95;
var RGBPP_LOCK_SIZE = 32 + 1 + 36;
var calculateRgbppCellCapacity = (xudtType) => {
  const typeArgsSize = xudtType ? remove0x(xudtType.args).length / 2 : 32;
  const udtTypeSize = 33 + typeArgsSize;
  const cellSize = RGBPP_LOCK_SIZE + udtTypeSize + CELL_CAPACITY_SIZE + UDT_CELL_DATA_SIZE + BTC_TIME_CELL_INCREASED_SIZE;
  return BigInt(cellSize) * CKB_UNIT;
};
var DEFAULT_UDT_ARGS_SIZE = 32;
var calculateUdtCellCapacity = (lock, udtType) => {
  const lockArgsSize = remove0x(lock.args).length / 2;
  const typeArgsSize = udtType ? remove0x(udtType.args).length / 2 : DEFAULT_UDT_ARGS_SIZE;
  const lockSize = 33 + lockArgsSize;
  const typeSize = 33 + typeArgsSize;
  const cellSize = lockSize + typeSize + CELL_CAPACITY_SIZE + UDT_CELL_DATA_SIZE;
  return BigInt(cellSize + 1) * CKB_UNIT;
};
var calculateXudtTokenInfoCellCapacity = (tokenInfo, lock) => {
  const lockSize = remove0x(lock.args).length / 2 + 33;
  const cellDataSize = remove0x(encodeRgbppTokenInfo(tokenInfo)).length / 2;
  const uniqueTypeSize = 32 + 1 + 20;
  const cellSize = lockSize + uniqueTypeSize + CELL_CAPACITY_SIZE + cellDataSize;
  return BigInt(cellSize) * CKB_UNIT;
};
var calculateRgbppTokenInfoCellCapacity = (tokenInfo, isMainnet) => {
  const btcTimeLock = genBtcTimeLockScript(UNLOCKABLE_LOCK_SCRIPT, isMainnet);
  const lockSize = remove0x(btcTimeLock.args).length / 2 + 33;
  const cellDataSize = remove0x(encodeRgbppTokenInfo(tokenInfo)).length / 2;
  const typeSize = 32 + 1 + 20;
  const cellSize = lockSize + typeSize + CELL_CAPACITY_SIZE + cellDataSize;
  return BigInt(cellSize) * CKB_UNIT;
};
var generateUniqueTypeArgs = (firstInput, firstOutputIndex) => {
  const input = hexToBytes3(serializeInput(firstInput));
  const s = blake2b(32, null, null, PERSONAL);
  s.update(input);
  s.update(hexToBytes3(`0x${u64ToLe(BigInt(firstOutputIndex))}`));
  return `0x${s.digest("hex").slice(0, 40)}`;
};
var calculateRgbppClusterCellCapacity = (clusterData) => {
  const clusterDataSize = packRawClusterData(clusterData).length;
  const clusterTypeSize = 32 + 1 + 32;
  const cellSize = RGBPP_LOCK_SIZE + clusterTypeSize + CELL_CAPACITY_SIZE + clusterDataSize;
  return BigInt(cellSize + 1) * CKB_UNIT;
};
var calculateRgbppSporeCellCapacity = (sporeData) => {
  const sporeDataSize = packRawSporeData(sporeData).length;
  const sporeTypeSize = 32 + 1 + 32;
  const cellSize = RGBPP_LOCK_SIZE + sporeTypeSize + CELL_CAPACITY_SIZE + sporeDataSize + BTC_TIME_CELL_INCREASED_SIZE;
  return BigInt(cellSize + 1) * CKB_UNIT;
};
var calculateCellOccupiedCapacity = (cell) => {
  const cellDataSize = remove0x(cell.outputData).length / 2;
  const lockSize = remove0x(cell.output.lock.args).length / 2 + 1 + 32;
  const typeSize = cell.output.type ? remove0x(cell.output.type.args).length / 2 + 1 + 32 : 0;
  const cellSize = cellDataSize + lockSize + typeSize + CELL_CAPACITY_SIZE;
  return BigInt(cellSize) * CKB_UNIT;
};
var deduplicateList = (rgbppLockArgsList) => {
  return Array.from(new Set(rgbppLockArgsList));
};
var isScriptEqual = (s1, s2) => {
  const temp1 = typeof s1 === "string" ? remove0x(s1) : remove0x(serializeScript2(s1));
  const temp2 = typeof s2 === "string" ? remove0x(s2) : remove0x(serializeScript2(s2));
  return temp1 === temp2;
};
var checkCkbTxInputsCapacitySufficient = async (ckbTx, collector) => {
  let sumInputsCapacity = BigInt(0);
  for await (const input of ckbTx.inputs) {
    const liveCell = await collector.getLiveCell(input.previousOutput);
    if (!liveCell) {
      throw new NoLiveCellError("The cell with the specific out point is dead");
    }
    sumInputsCapacity += BigInt(liveCell.output.capacity);
  }
  const sumOutputsCapacity = ckbTx.outputs.map((output) => BigInt(output.capacity)).reduce((prev, current) => prev + current, BigInt(0));
  return sumInputsCapacity > sumOutputsCapacity;
};

// src/utils/spore.ts
import {
  assembleTransferSporeAction,
  assembleCobuildWitnessLayout,
  assembleCreateClusterAction,
  assembleCreateSporeAction,
  assembleTransferClusterAction
} from "@spore-sdk/core/lib/cobuild/index.js";
import { blake2b as blake2b2, hexToBytes as hexToBytes4, PERSONAL as PERSONAL2, serializeInput as serializeInput2 } from "@nervosnetwork/ckb-sdk-utils";
var generateClusterId = (firstInput, firstOutputIndex) => {
  const input = hexToBytes4(serializeInput2(firstInput));
  const s = blake2b2(32, null, null, PERSONAL2);
  s.update(input);
  s.update(hexToBytes4(`0x${u64ToLe(BigInt(firstOutputIndex))}`));
  return `0x${s.digest("hex")}`;
};
var generateSporeId = (firstInput, firstOutputIndex) => {
  return generateClusterId(firstInput, firstOutputIndex);
};
var generateClusterCreateCoBuild = (clusterOutput, clusterOutputData) => {
  const output = {
    cellOutput: clusterOutput,
    data: clusterOutputData
  };
  const { actions } = assembleCreateClusterAction(output);
  return assembleCobuildWitnessLayout(actions);
};
var generateSporeCreateCoBuild = ({
  sporeOutputs,
  sporeOutputsData,
  clusterCell,
  clusterOutputCell
}) => {
  if (sporeOutputs.length !== sporeOutputsData.length) {
    throw new Error("The length of spore outputs and spore cell data are not same");
  }
  let sporeActions = [];
  const clusterInput = {
    cellOutput: clusterCell.output,
    data: clusterCell.outputData
  };
  const clusterOutput = {
    cellOutput: clusterOutputCell,
    data: clusterCell.outputData
  };
  const { actions } = assembleTransferClusterAction(clusterInput, clusterOutput);
  sporeActions = sporeActions.concat(actions);
  for (let index = 0; index < sporeOutputs.length; index++) {
    const sporeOutput = {
      cellOutput: sporeOutputs[index],
      data: sporeOutputsData[index]
    };
    const { actions: actions2 } = assembleCreateSporeAction(sporeOutput);
    sporeActions = sporeActions.concat(actions2);
  }
  return assembleCobuildWitnessLayout(sporeActions);
};
var generateSporeTransferCoBuild = (sporeCells, outputCells) => {
  if (sporeCells.length !== outputCells.length) {
    throw new Error("The length of spore input cells and spore output cells are not same");
  }
  let sporeActions = [];
  for (let index = 0; index < sporeCells.length; index++) {
    const sporeCell = sporeCells[index];
    const outputData = "outputData" in sporeCell ? sporeCell.outputData : sporeCell.data.content;
    const sporeInput = {
      cellOutput: sporeCells[index].output,
      data: outputData
    };
    const sporeOutput = {
      cellOutput: outputCells[index],
      data: outputData
    };
    const { actions } = assembleTransferSporeAction(sporeInput, sporeOutput);
    sporeActions = sporeActions.concat(actions);
  }
  return assembleCobuildWitnessLayout(sporeActions);
};
var throwErrorWhenSporeCellsInvalid = (sporeCells, sporeTypeBytes, isMainnet) => {
  if (!sporeCells || sporeCells.length === 0) {
    throw new NoRgbppLiveCellError("No spore rgbpp cells found with the spore rgbpp lock args");
  }
  if (sporeCells.length > 1) {
    throw new RgbppUtxoBindMultiTypeAssetsError("The BTC UTXO must not be bound to multiple CKB cells");
  }
  const sporeCell = sporeCells[0];
  if (!sporeCell.output.type) {
    throw new RgbppSporeTypeMismatchError("The cell with the rgbpp lock args has no spore asset");
  }
  if (!isSporeTypeSupported(sporeCell.output.type, isMainnet)) {
    throw new RgbppSporeTypeMismatchError("The cell type is not the supported spore type script");
  }
  if (!isScriptEqual(sporeCell.output.type, sporeTypeBytes)) {
    throw new RgbppSporeTypeMismatchError("The spore cell type with the rgbpp lock args does not match");
  }
};

// src/utils/cell-dep.ts
import axios from "axios";
var GITHUB_CELL_DEPS_JSON_URL = "https://raw.githubusercontent.com/ckb-cell/typeid-contract-cell-deps/main/deployment/cell-deps.json";
var CDN_GITHUB_CELL_DEPS_JSON_URL = "https://cdn.jsdelivr.net/gh/ckb-cell/typeid-contract-cell-deps@main/deployment/cell-deps.json";
var request = (url) => axios.get(url, { timeout: 2e3 });
var fetchCellDepsJson = async () => {
  try {
    const response = await Promise.any([request(GITHUB_CELL_DEPS_JSON_URL), request(CDN_GITHUB_CELL_DEPS_JSON_URL)]);
    return response.data;
  } catch (error) {
  }
};
var fetchTypeIdCellDeps = async (isMainnet, selected, btcTestnetType) => {
  let rgbppLockDep = getRgbppLockDep(isMainnet, btcTestnetType);
  let btcTimeDep = getBtcTimeLockDep(isMainnet, btcTestnetType);
  let xudtDep = getXudtDep(isMainnet);
  let uniqueDep = getUniqueTypeDep(isMainnet);
  const cellDepsObj = await fetchCellDepsJson();
  if (cellDepsObj) {
    if (btcTestnetType === "Signet") {
      rgbppLockDep = cellDepsObj.rgbpp.signet;
      btcTimeDep = cellDepsObj.btcTime.signet;
    } else {
      rgbppLockDep = isMainnet ? cellDepsObj.rgbpp.mainnet : cellDepsObj.rgbpp.testnet;
      btcTimeDep = isMainnet ? cellDepsObj.btcTime.mainnet : cellDepsObj.btcTime.testnet;
    }
    if (!isMainnet) {
      xudtDep = cellDepsObj.xudt.testnet;
      uniqueDep = cellDepsObj.unique.testnet;
    }
  }
  let cellDeps = [];
  if (selected.rgbpp) {
    cellDeps = [
      ...cellDeps,
      rgbppLockDep,
      {
        ...rgbppLockDep,
        outPoint: {
          ...rgbppLockDep.outPoint,
          index: "0x1"
        }
      }
    ];
  }
  if (selected.btcTime) {
    cellDeps = [
      ...cellDeps,
      btcTimeDep,
      {
        ...btcTimeDep,
        outPoint: {
          ...btcTimeDep.outPoint,
          index: "0x1"
        }
      }
    ];
  }
  if (selected.xudt) {
    cellDeps = [...cellDeps, xudtDep];
  }
  if (selected.unique) {
    cellDeps = [...cellDeps, uniqueDep];
  }
  return cellDeps;
};

// src/utils/id.ts
import { blockchain as blockchain2 } from "@ckb-lumos/base";
var encodeCellId = (txHash, index) => {
  if (!txHash.startsWith("0x") || !index.startsWith("0x")) {
    throw new InvalidCellIdError(`Cannot encode CellId due to valid format: txHash=${txHash}, index=${index}`);
  }
  try {
    blockchain2.OutPoint.pack({
      txHash,
      index
    });
    return `${txHash}:${index}`;
  } catch {
    throw new InvalidCellIdError(`Cannot encode CellId due to valid format: txHash=${txHash}, index=${index}`);
  }
};
var decodeCellId = (cellId) => {
  const [txHash, index] = cellId.split(":");
  if (!txHash.startsWith("0x") || !index.startsWith("0x")) {
    throw new InvalidCellIdError(`Cannot decode CellId: ${cellId}`);
  }
  try {
    blockchain2.OutPoint.pack({
      txHash,
      index
    });
    return {
      txHash: append0x(txHash),
      index: append0x(index)
    };
  } catch {
    throw new InvalidCellIdError(`Cannot decode CellId due to valid format: ${cellId}`);
  }
};

// src/collector/index.ts
var parseScript = (script) => ({
  code_hash: script.codeHash,
  hash_type: script.hashType,
  args: script.args
});
var Collector = class {
  ckbNodeUrl;
  ckbIndexerUrl;
  constructor({ ckbNodeUrl, ckbIndexerUrl }) {
    this.ckbNodeUrl = ckbNodeUrl;
    this.ckbIndexerUrl = ckbIndexerUrl;
  }
  getCkb() {
    return new CKB(this.ckbNodeUrl);
  }
  async getCells({
    lock,
    type,
    isDataMustBeEmpty = true,
    outputCapacityRange
  }) {
    let searchKey = {};
    if (lock) {
      searchKey = {
        script_search_mode: "exact",
        script: parseScript(lock),
        script_type: "lock",
        filter: {
          script: type ? parseScript(type) : void 0,
          output_data_len_range: isDataMustBeEmpty && !type ? ["0x0", "0x1"] : void 0,
          output_capacity_range: outputCapacityRange
        }
      };
    } else if (type) {
      searchKey = {
        script_search_mode: "exact",
        script: parseScript(type),
        script_type: "type"
      };
    }
    const payload = {
      id: Math.floor(Math.random() * 1e5),
      jsonrpc: "2.0",
      method: "get_cells",
      params: [searchKey, "asc", "0x3E8"]
    };
    const body = JSON.stringify(payload, null, "  ");
    const response = (await axios2({
      method: "post",
      url: this.ckbIndexerUrl,
      headers: {
        "Content-Type": "application/json"
      },
      timeout: 2e4,
      data: body
    })).data;
    if (response.error) {
      console.error(response.error);
      throw new IndexerError("Get cells from indexer error");
    } else {
      const res = toCamelcase(response.result.objects);
      if (res === null) {
        throw new IndexerError("The response of indexer RPC get_cells is invalid");
      }
      return res;
    }
  }
  collectInputs(liveCells, needCapacity, fee, config) {
    const changeCapacity = config?.minCapacity ?? MIN_CAPACITY;
    const inputs = [];
    let sumInputsCapacity = BigInt(0);
    const isRgbppLock = liveCells.length > 0 && isRgbppLockCellIgnoreChain(liveCells[0].output);
    for (const cell of liveCells) {
      inputs.push({
        previousOutput: {
          txHash: cell.outPoint.txHash,
          index: cell.outPoint.index
        },
        since: "0x0"
      });
      sumInputsCapacity += BigInt(cell.output.capacity);
      if (sumInputsCapacity >= needCapacity + changeCapacity + fee && !isRgbppLock) {
        break;
      }
    }
    if (sumInputsCapacity < needCapacity + changeCapacity + fee) {
      const message = config?.errMsg ?? "Insufficient free CKB balance";
      throw new CapacityNotEnoughError(message);
    }
    return { inputs, sumInputsCapacity };
  }
  collectUdtInputs({ liveCells, needAmount }) {
    const inputs = [];
    let sumInputsCapacity = BigInt(0);
    let sumAmount = BigInt(0);
    const isRgbppLock = liveCells.length > 0 && isRgbppLockCellIgnoreChain(liveCells[0].output);
    for (const cell of liveCells) {
      if (cell.outputData === "0x") {
        continue;
      }
      inputs.push({
        previousOutput: {
          txHash: cell.outPoint.txHash,
          index: cell.outPoint.index
        },
        since: "0x0"
      });
      sumInputsCapacity = sumInputsCapacity + BigInt(cell.output.capacity);
      sumAmount += leToU128(remove0x(cell.outputData).slice(0, 32));
      if (sumAmount >= needAmount && !isRgbppLock) {
        break;
      }
    }
    if (sumAmount < needAmount) {
      throw new UdtAmountNotEnoughError("Insufficient UDT balance");
    }
    return { inputs, sumInputsCapacity, sumAmount };
  }
  async getLiveCell(outPoint, withData = true) {
    const ckb = new CKB(this.ckbNodeUrl);
    const { cell } = await ckb.rpc.getLiveCell(outPoint, withData);
    return cell;
  }
  async getLiveCells(outPoints, withData = false) {
    const ckb = new CKB(this.ckbNodeUrl);
    const batch = ckb.rpc.createBatchRequest(outPoints.map((outPoint) => ["getLiveCell", outPoint, withData]));
    return batch.exec().then((liveCells) => liveCells.map((liveCell) => liveCell.cell));
  }
};

// src/paymaster/index.ts
import { AddressPrefix, addressToScript, getTransactionSize, privateKeyToAddress } from "@nervosnetwork/ckb-sdk-utils";
var SECP256K1_MIN_CAPACITY = BigInt(61) * CKB_UNIT;
var splitMultiCellsWithSecp256k1 = async ({
  masterPrivateKey,
  collector,
  receiverAddress,
  capacityWithCKB,
  cellAmount
}) => {
  const isMainnet = receiverAddress.startsWith("ckb");
  const masterAddress = privateKeyToAddress(masterPrivateKey, {
    prefix: isMainnet ? AddressPrefix.Mainnet : AddressPrefix.Testnet
  });
  const masterLock = addressToScript(masterAddress);
  let emptyCells = await collector.getCells({
    lock: masterLock
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError("The address has no empty cells");
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  const cellCapacity = BigInt(capacityWithCKB) * CKB_UNIT;
  const needCapacity = cellCapacity * BigInt(cellAmount);
  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee, {
    minCapacity: SECP256K1_MIN_CAPACITY
  });
  const outputs = new Array(cellAmount).fill({
    lock: addressToScript(receiverAddress),
    capacity: append0x(cellCapacity.toString(16))
  });
  const changeCapacity = sumInputsCapacity - needCapacity - txFee;
  outputs.push({
    lock: masterLock,
    capacity: append0x(changeCapacity.toString(16))
  });
  const outputsData = new Array(cellAmount + 1).fill("0x");
  const emptyWitness = { lock: "", inputType: "", outputType: "" };
  const witnesses = inputs.map((_, index) => index === 0 ? emptyWitness : "0x");
  const cellDeps = [getSecp256k1CellDep(isMainnet)];
  const unsignedTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;
    const estimatedTxFee = calculateTransactionFee(txSize);
    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);
    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));
  }
  const signedTx = collector.getCkb().signTransaction(masterPrivateKey)(unsignedTx);
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, "passthrough");
  console.info(`Paymaster cells has been split and tx hash is ${txHash}`);
};

// src/rgbpp/btc-transfer.ts
import { blockchain as blockchain3 } from "@ckb-lumos/base";
import signWitnesses from "@nervosnetwork/ckb-sdk-core/lib/signWitnesses";
import {
  addressToScript as addressToScript2,
  getTransactionSize as getTransactionSize2,
  rawTransactionToHash,
  scriptToHash,
  serializeWitnessArgs
} from "@nervosnetwork/ckb-sdk-utils";
var genBtcTransferCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  transferAmount,
  isMainnet,
  noMergeOutputCells,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const xudtType = blockchain3.Script.unpack(xudtTypeBytes);
  if (!isUDTTypeSupported(xudtType, isMainnet)) {
    throw new TypeAssetNotSupportedError("The type script asset is not supported now");
  }
  const deduplicatedLockArgsList = deduplicateList(rgbppLockArgsList);
  const rgbppLocks = deduplicatedLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));
  let rgbppTargetCells = [];
  let rgbppOtherTypeCells = [];
  for await (const rgbppLock of rgbppLocks) {
    const cells = await collector.getCells({ lock: rgbppLock, isDataMustBeEmpty: false });
    throwErrorWhenRgbppCellsInvalid(cells, xudtTypeBytes, isMainnet);
    const targetCells = cells.filter((cell) => isScriptEqual(cell.output.type, xudtTypeBytes));
    const otherTypeCells = cells.filter((cell) => !isScriptEqual(cell.output.type, xudtTypeBytes));
    rgbppTargetCells = [...rgbppTargetCells, ...targetCells];
    rgbppOtherTypeCells = [...rgbppOtherTypeCells, ...otherTypeCells];
  }
  rgbppTargetCells = rgbppTargetCells.sort(compareInputs);
  rgbppOtherTypeCells = rgbppOtherTypeCells.sort(compareInputs);
  let inputs = [];
  let sumInputsCapacity = BigInt(0);
  const outputs = [];
  const outputsData = [];
  let needPaymasterCell = false;
  const handleNonTargetRgbppCells = (targetRgbppOutputLen) => {
    for (const [index, otherRgbppCell] of rgbppOtherTypeCells.entries()) {
      inputs.push({
        previousOutput: otherRgbppCell.outPoint,
        since: "0x0"
      });
      sumInputsCapacity += BigInt(otherRgbppCell.output.capacity);
      outputs.push({
        ...otherRgbppCell.output,
        // Vouts[targetRgbppOutputLen + 1], ..., Vouts[targetRgbppOutputLen + rgbppOtherTypeCells.length] for other RGBPP assets
        lock: genRgbppLockScript(buildPreLockArgs(targetRgbppOutputLen + index + 1), isMainnet, btcTestnetType)
      });
      outputsData.push(otherRgbppCell.outputData);
    }
  };
  if (noMergeOutputCells) {
    for (const [index, targetRgbppCell] of rgbppTargetCells.entries()) {
      inputs.push({
        previousOutput: targetRgbppCell.outPoint,
        since: "0x0"
      });
      sumInputsCapacity += BigInt(targetRgbppCell.output.capacity);
      outputs.push({
        ...targetRgbppCell.output,
        // The Vouts[0] for OP_RETURN and Vouts[1], ..., Vouts[rgbppTargetCells.length] for target RGBPP assets
        lock: genRgbppLockScript(buildPreLockArgs(index + 1), isMainnet, btcTestnetType)
      });
      outputsData.push(targetRgbppCell.outputData);
    }
    handleNonTargetRgbppCells(rgbppTargetCells.length);
  } else {
    const collectResult = collector.collectUdtInputs({
      liveCells: rgbppTargetCells,
      needAmount: transferAmount
    });
    inputs = collectResult.inputs;
    throwErrorWhenTxInputsExceeded(inputs.length);
    sumInputsCapacity = collectResult.sumInputsCapacity;
    const rgbppCellCapacity = calculateRgbppCellCapacity(xudtType);
    const needRgbppChange = collectResult.sumAmount > transferAmount;
    const receiverOutputCapacity = needRgbppChange ? BigInt(rgbppTargetCells[0].output.capacity) : sumInputsCapacity;
    outputs.push({
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(receiverOutputCapacity.toString(16))
    });
    outputsData.push(append0x(u128ToLe(transferAmount)));
    if (needRgbppChange) {
      const isCapacitySufficient = isRgbppCapacitySufficientForChange(sumInputsCapacity, receiverOutputCapacity);
      needPaymasterCell = !isCapacitySufficient;
      const udtChangeCapacity = isCapacitySufficient ? sumInputsCapacity - receiverOutputCapacity : rgbppCellCapacity;
      outputs.push({
        lock: genRgbppLockScript(buildPreLockArgs(2), isMainnet, btcTestnetType),
        type: xudtType,
        capacity: append0x(udtChangeCapacity.toString(16))
      });
      outputsData.push(append0x(u128ToLe(collectResult.sumAmount - transferAmount)));
    }
    handleNonTargetRgbppCells(outputs.length);
  }
  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true }, btcTestnetType);
  if (needPaymasterCell) {
    cellDeps.push(getSecp256k1CellDep(isMainnet));
  }
  const witnesses = [];
  const lockArgsSet = /* @__PURE__ */ new Set();
  const allRgbppCells = rgbppTargetCells.concat(rgbppOtherTypeCells);
  for (const cell of allRgbppCells) {
    if (lockArgsSet.has(cell.output.lock.args)) {
      witnesses.push("0x");
    } else {
      lockArgsSet.add(cell.output.lock.args);
      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);
    }
  }
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  if (!needPaymasterCell) {
    const txSize = getTransactionSize2(ckbRawTx) + (witnessLockPlaceholderSize ?? estimateWitnessSize(deduplicatedLockArgsList));
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const changeCapacity = BigInt(outputs[outputs.length - 1].capacity) - estimatedTxFee;
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    needPaymasterCell,
    sumInputsCapacity: append0x(sumInputsCapacity.toString(16))
  };
};
var genBtcBatchTransferCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  rgbppReceivers,
  isMainnet,
  btcTestnetType
}) => {
  const xudtType = blockchain3.Script.unpack(xudtTypeBytes);
  if (!isUDTTypeSupported(xudtType, isMainnet)) {
    throw new TypeAssetNotSupportedError("The type script asset is not supported now");
  }
  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));
  let rgbppCells = [];
  for await (const rgbppLock of rgbppLocks) {
    const cells = await collector.getCells({ lock: rgbppLock, type: xudtType });
    if (!cells || cells.length === 0) {
      throw new NoRgbppLiveCellError("No rgbpp cells found with the xudt type script and the rgbpp lock args");
    }
    rgbppCells = [...rgbppCells, ...cells];
  }
  rgbppCells = rgbppCells.sort(compareInputs);
  const sumTransferAmount = rgbppReceivers.map((receiver) => receiver.transferAmount).reduce((prev, current) => prev + current, BigInt(0));
  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const outputs = rgbppReceivers.map((_, index) => ({
    // The Vouts[0] for OP_RETURN and Vouts[1], Vouts[2], ... for RGBPP assets
    lock: genRgbppLockScript(buildPreLockArgs(index + 1), isMainnet, btcTestnetType),
    type: xudtType,
    capacity: append0x(rpbppCellCapacity.toString(16))
  }));
  const outputsData = rgbppReceivers.map((receiver) => append0x(u128ToLe(receiver.transferAmount)));
  const { inputs, sumInputsCapacity, sumAmount } = collector.collectUdtInputs({
    liveCells: rgbppCells,
    needAmount: sumTransferAmount
  });
  throwErrorWhenTxInputsExceeded(inputs.length);
  let rgbppChangeOutIndex = -1;
  if (sumAmount > sumTransferAmount) {
    rgbppChangeOutIndex = rgbppReceivers.length + 1;
    outputs.push({
      // The Vouts[0] for OP_RETURN and Vouts[rgbppChangeOutIndex] for RGBPP change assets
      lock: genRgbppLockScript(buildPreLockArgs(rgbppChangeOutIndex), isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(rpbppCellCapacity.toString(16))
    });
    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));
  }
  const cellDeps = [
    ...await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true }, btcTestnetType),
    getSecp256k1CellDep(isMainnet)
  ];
  const witnesses = [];
  const lockArgsSet = /* @__PURE__ */ new Set();
  for (const cell of rgbppCells) {
    if (lockArgsSet.has(cell.output.lock.args)) {
      witnesses.push("0x");
    } else {
      lockArgsSet.add(cell.output.lock.args);
      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);
    }
  }
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    rgbppChangeOutIndex,
    needPaymasterCell: false,
    sumInputsCapacity: append0x(sumInputsCapacity.toString(16))
  };
};
var appendIssuerCellToBtcBatchTransfer = async ({
  secp256k1PrivateKey,
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  isMainnet,
  ckbFeeRate
}) => {
  const rawTx = ckbRawTx;
  const rgbppInputsLength = rawTx.inputs.length;
  const sumOutputsCapacity = rawTx.outputs.map((output) => BigInt(output.capacity)).reduce((prev, current) => prev + current, BigInt(0));
  const issuerLock = addressToScript2(issuerAddress);
  let emptyCells = await collector.getCells({ lock: issuerLock });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError("The issuer address has no empty cells");
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  let actualInputsCapacity = BigInt(sumInputsCapacity);
  const txFee = MAX_FEE;
  if (actualInputsCapacity <= sumOutputsCapacity) {
    const needCapacity = sumOutputsCapacity - actualInputsCapacity + MIN_CAPACITY;
    const { inputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee);
    rawTx.inputs = [...rawTx.inputs, ...inputs];
    actualInputsCapacity += sumEmptyCapacity;
  }
  let changeCapacity = actualInputsCapacity - sumOutputsCapacity;
  const changeOutput = {
    lock: issuerLock,
    capacity: append0x(changeCapacity.toString(16))
  };
  rawTx.outputs = [...rawTx.outputs, changeOutput];
  rawTx.outputsData = [...rawTx.outputsData, "0x"];
  const txSize = getTransactionSize2(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  const keyMap = /* @__PURE__ */ new Map();
  keyMap.set(scriptToHash(issuerLock), secp256k1PrivateKey);
  const issuerCellIndex = rgbppInputsLength;
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput,
    lock: index >= issuerCellIndex ? issuerLock : getRgbppLockScript(isMainnet)
  }));
  const emptyWitness = { lock: "", inputType: "", outputType: "" };
  const issuerWitnesses = rawTx.inputs.slice(rgbppInputsLength).map((_, index) => index === 0 ? emptyWitness : "0x");
  rawTx.witnesses = [...rawTx.witnesses, ...issuerWitnesses];
  const transactionHash = rawTransactionToHash(rawTx);
  const signedWitnesses = signWitnesses(keyMap)({
    transactionHash,
    witnesses: rawTx.witnesses,
    inputCells: cells,
    skipMissingKeys: true
  });
  const signedTx = {
    ...rawTx,
    witnesses: signedWitnesses.map(
      (witness) => typeof witness !== "string" ? serializeWitnessArgs(witness) : witness
    )
  };
  return signedTx;
};

// src/rgbpp/ckb-builder.ts
import signWitnesses2 from "@nervosnetwork/ckb-sdk-core/lib/signWitnesses";
import {
  bytesToHex as bytesToHex3,
  getTransactionSize as getTransactionSize3,
  rawTransactionToHash as rawTransactionToHash2,
  scriptToHash as scriptToHash2,
  serializeWitnessArgs as serializeWitnessArgs2
} from "@nervosnetwork/ckb-sdk-utils";
var buildRgbppUnlockWitness = (btcTxBytes, btcTxProof, inputsLen, outputsLen) => {
  const inputLen = append0x(u8ToHex(inputsLen));
  const outputLen = append0x(u8ToHex(outputsLen));
  const version = Uint16.pack([0, 0]);
  const rgbppUnlock = RGBPPUnlock.pack({
    version,
    extraData: { inputLen, outputLen },
    btcTx: append0x(btcTxBytes),
    btcTxProof: append0x(btcTxProof)
  });
  return append0x(bytesToHex3(rgbppUnlock));
};
var appendCkbTxWitnesses = async ({
  ckbRawTx,
  btcTxBytes,
  rgbppApiSpvProof
}) => {
  const rawTx = ckbRawTx;
  const { spvClient, proof } = transformSpvProof(rgbppApiSpvProof);
  rawTx.cellDeps.push(buildSpvClientCellDep(spvClient));
  const rgbppUnlock = buildRgbppUnlockWitness(btcTxBytes, proof, ckbRawTx.inputs.length, ckbRawTx.outputs.length);
  const rgbppWitness = append0x(serializeWitnessArgs2({ lock: rgbppUnlock, inputType: "", outputType: "" }));
  rawTx.witnesses = rawTx.witnesses.map((witness) => witness === RGBPP_WITNESS_PLACEHOLDER ? rgbppWitness : witness);
  return rawTx;
};
var appendPaymasterCellAndSignCkbTx = async ({
  secp256k1PrivateKey,
  ckbRawTx,
  sumInputsCapacity,
  paymasterCell,
  isMainnet,
  ckbFeeRate
}) => {
  const rawTx = ckbRawTx;
  const paymasterInput = { previousOutput: paymasterCell.outPoint, since: "0x0" };
  rawTx.inputs = [...rawTx.inputs, paymasterInput];
  const inputsCapacity = BigInt(sumInputsCapacity) + BigInt(paymasterCell.output.capacity);
  const sumOutputsCapacity = rawTx.outputs.map((output) => BigInt(output.capacity)).reduce((prev, current) => prev + current, BigInt(0));
  if (inputsCapacity <= sumOutputsCapacity + MIN_CAPACITY) {
    throw new InputsCapacityNotEnoughError("The sum of inputs capacity is not enough");
  }
  let changeCapacity = inputsCapacity - sumOutputsCapacity;
  const changeOutput = {
    lock: paymasterCell.output.lock,
    capacity: append0x(changeCapacity.toString(16))
  };
  rawTx.outputs = [...rawTx.outputs, changeOutput];
  rawTx.outputsData = [...rawTx.outputsData, "0x"];
  const txSize = getTransactionSize3(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  const keyMap = /* @__PURE__ */ new Map();
  keyMap.set(scriptToHash2(paymasterCell.output.lock), secp256k1PrivateKey);
  keyMap.set(scriptToHash2(getRgbppLockScript(isMainnet)), "");
  const paymasterCellIndex = rawTx.inputs.length - 1;
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput,
    lock: index === paymasterCellIndex ? paymasterCell.output.lock : getRgbppLockScript(isMainnet)
  }));
  const emptyWitness = { lock: "", inputType: "", outputType: "" };
  rawTx.witnesses = [...rawTx.witnesses, emptyWitness];
  const transactionHash = rawTransactionToHash2(rawTx);
  const signedWitnesses = signWitnesses2(keyMap)({
    transactionHash,
    witnesses: rawTx.witnesses,
    inputCells: cells,
    skipMissingKeys: true
  });
  const signedTx = {
    ...rawTx,
    witnesses: signedWitnesses.map(
      (witness) => typeof witness !== "string" ? serializeWitnessArgs2(witness) : witness
    )
  };
  return signedTx;
};
var sendCkbTx = async ({ collector, signedTx }) => {
  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, "passthrough");
  return txHash;
};
var updateCkbTxWithRealBtcTxId = ({
  ckbRawTx,
  btcTxId,
  isMainnet
}) => {
  const outputs = ckbRawTx.outputs.map((output) => {
    if (isRgbppLockOrBtcTimeLock(output.lock, isMainnet)) {
      return {
        ...output,
        lock: {
          ...output.lock,
          args: replaceLockArgsWithRealBtcTxId(output.lock.args, btcTxId)
        }
      };
    }
    return output;
  });
  const newRawTx = {
    ...ckbRawTx,
    outputs
  };
  return newRawTx;
};

// src/rgbpp/btc-jump-ckb.ts
import { blockchain as blockchain4 } from "@ckb-lumos/base";
import { addressToScript as addressToScript3, getTransactionSize as getTransactionSize4 } from "@nervosnetwork/ckb-sdk-utils";
var genBtcJumpCkbVirtualTx = async ({
  collector,
  xudtTypeBytes,
  rgbppLockArgsList,
  transferAmount,
  toCkbAddress,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType,
  btcConfirmationBlocks
}) => {
  const isMainnet = toCkbAddress.startsWith("ckb");
  const xudtType = blockchain4.Script.unpack(xudtTypeBytes);
  if (!isUDTTypeSupported(xudtType, isMainnet)) {
    throw new TypeAssetNotSupportedError("The type script asset is not supported now");
  }
  const deduplicatedLockArgsList = deduplicateList(rgbppLockArgsList);
  const rgbppLocks = deduplicatedLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));
  let rgbppTargetCells = [];
  let rgbppOtherTypeCells = [];
  for await (const rgbppLock of rgbppLocks) {
    const cells = await collector.getCells({ lock: rgbppLock, isDataMustBeEmpty: false });
    throwErrorWhenRgbppCellsInvalid(cells, xudtTypeBytes, isMainnet);
    const targetCells = cells.filter((cell) => isScriptEqual(cell.output.type, xudtTypeBytes));
    const otherTypeCells = cells.filter((cell) => !isScriptEqual(cell.output.type, xudtTypeBytes));
    rgbppTargetCells = [...rgbppTargetCells, ...targetCells];
    rgbppOtherTypeCells = [...rgbppOtherTypeCells, ...otherTypeCells];
  }
  rgbppTargetCells = rgbppTargetCells.sort(compareInputs);
  rgbppOtherTypeCells = rgbppOtherTypeCells.sort(compareInputs);
  const {
    inputs,
    sumInputsCapacity: sumUdtCapacity,
    sumAmount
  } = collector.collectUdtInputs({
    liveCells: rgbppTargetCells,
    needAmount: transferAmount
  });
  let sumInputsCapacity = sumUdtCapacity;
  throwErrorWhenTxInputsExceeded(inputs.length);
  const rgbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const toLock = addressToScript3(toCkbAddress);
  if (isLockArgsSizeExceeded(toLock.args)) {
    throw new Error("The lock script size of the to ckb address is too large");
  }
  let needPaymasterCell = false;
  const needRgbppChange = sumAmount > transferAmount;
  const receiverOutputCapacity = needRgbppChange ? BigInt(rgbppTargetCells[0].output.capacity) : sumInputsCapacity;
  const outputs = [
    {
      lock: genBtcTimeLockScript(toLock, isMainnet, btcTestnetType, btcConfirmationBlocks),
      type: xudtType,
      capacity: append0x(receiverOutputCapacity.toString(16))
    }
  ];
  const outputsData = [append0x(u128ToLe(transferAmount))];
  if (needRgbppChange) {
    const isCapacitySufficient = isRgbppCapacitySufficientForChange(sumInputsCapacity, receiverOutputCapacity);
    needPaymasterCell = !isCapacitySufficient;
    const udtChangeCapacity = isCapacitySufficient ? sumInputsCapacity - receiverOutputCapacity : rgbppCellCapacity;
    outputs.push({
      // The Vouts[0] for OP_RETURN and Vouts[1] for RGBPP assets, BTC time cells don't need btc tx out_index
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(udtChangeCapacity.toString(16))
    });
    outputsData.push(append0x(u128ToLe(sumAmount - transferAmount)));
  }
  const targetRgbppOutputLen = outputs.length;
  for (const [index, otherRgbppCell] of rgbppOtherTypeCells.entries()) {
    inputs.push({
      previousOutput: otherRgbppCell.outPoint,
      since: "0x0"
    });
    sumInputsCapacity += BigInt(otherRgbppCell.output.capacity);
    outputs.push({
      ...otherRgbppCell.output,
      // Vouts[targetRgbppOutputLen + 1], ..., Vouts[targetRgbppOutputLen + rgbppOtherTypeCells.length] for other RGBPP assets
      lock: genRgbppLockScript(buildPreLockArgs(targetRgbppOutputLen + index + 1), isMainnet, btcTestnetType)
    });
    outputsData.push(otherRgbppCell.outputData);
  }
  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true }, btcTestnetType);
  if (needPaymasterCell) {
    cellDeps.push(getSecp256k1CellDep(isMainnet));
  }
  const witnesses = [];
  const lockArgsSet = /* @__PURE__ */ new Set();
  const allRgbppCells = rgbppTargetCells.concat(rgbppOtherTypeCells);
  for (const cell of allRgbppCells) {
    if (lockArgsSet.has(cell.output.lock.args)) {
      witnesses.push("0x");
    } else {
      lockArgsSet.add(cell.output.lock.args);
      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);
    }
  }
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  if (!needPaymasterCell) {
    const txSize = getTransactionSize4(ckbRawTx) + (witnessLockPlaceholderSize ?? estimateWitnessSize(deduplicatedLockArgsList));
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const changeCapacity = BigInt(outputs[outputs.length - 1].capacity) - estimatedTxFee;
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  }
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    needPaymasterCell,
    sumInputsCapacity: append0x(sumInputsCapacity.toString(16))
  };
};

// src/rgbpp/btc-time.ts
import {
  addressToScript as addressToScript4,
  bytesToHex as bytesToHex4,
  getTransactionSize as getTransactionSize5,
  rawTransactionToHash as rawTransactionToHash3,
  scriptToHash as scriptToHash3,
  serializeOutPoint as serializeOutPoint2,
  serializeWitnessArgs as serializeWitnessArgs3
} from "@nervosnetwork/ckb-sdk-utils";
import signWitnesses3 from "@nervosnetwork/ckb-sdk-core/lib/signWitnesses";
var buildBtcTimeUnlockWitness = (btcTxProof) => {
  const btcTimeUnlock = BTCTimeUnlock.pack({ btcTxProof });
  return append0x(bytesToHex4(btcTimeUnlock));
};
var buildBtcTimeCellsSpentTx = async ({
  btcTimeCells,
  btcAssetsApi,
  isMainnet,
  btcTestnetType
}) => {
  const sortedBtcTimeCells = btcTimeCells.sort(compareInputs);
  const inputs = sortedBtcTimeCells.map((cell) => ({
    previousOutput: cell.outPoint,
    since: "0x0"
  }));
  const outputs = sortedBtcTimeCells.map((cell) => ({
    lock: lockScriptFromBtcTimeLockArgs(cell.output.lock.args),
    type: cell.output.type,
    capacity: cell.output.capacity
  }));
  const outputsData = sortedBtcTimeCells.map((cell) => cell.outputData);
  const cellDeps = await fetchTypeIdCellDeps(
    isMainnet,
    { btcTime: true, xudt: true },
    btcTestnetType
  );
  const witnesses = [];
  const lockArgsSet = /* @__PURE__ */ new Set();
  const cellDepsSet = /* @__PURE__ */ new Set();
  for await (const btcTimeCell of sortedBtcTimeCells) {
    if (lockArgsSet.has(btcTimeCell.output.lock.args)) {
      witnesses.push("0x");
      continue;
    }
    lockArgsSet.add(btcTimeCell.output.lock.args);
    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);
    const result = await btcAssetsApi.getRgbppSpvProof(btcTxId, after);
    const { spvClient, proof } = transformSpvProof(result);
    if (!cellDepsSet.has(serializeOutPoint2(spvClient))) {
      cellDeps.push(buildSpvClientCellDep(spvClient));
      cellDepsSet.add(serializeOutPoint2(spvClient));
    }
    const btcTimeWitness = append0x(
      serializeWitnessArgs3({ lock: buildBtcTimeUnlockWitness(proof), inputType: "", outputType: "" })
    );
    witnesses.push(btcTimeWitness);
  }
  const ckbTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  return ckbTx;
};
var signBtcTimeCellSpentTx = async ({
  secp256k1PrivateKey,
  ckbRawTx,
  collector,
  masterCkbAddress,
  isMainnet,
  outputCapacityRange,
  ckbFeeRate
}) => {
  const masterLock = addressToScript4(masterCkbAddress);
  let emptyCells = await collector.getCells({
    lock: masterLock,
    outputCapacityRange
  });
  if (!emptyCells || emptyCells.length === 0) {
    throw new Error("No empty cell found");
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  const emptyInput = {
    previousOutput: emptyCells[0].outPoint,
    since: "0x0"
  };
  const changeOutput = emptyCells[0].output;
  const rawTx = {
    ...ckbRawTx,
    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],
    inputs: [emptyInput, ...ckbRawTx.inputs],
    outputs: [changeOutput, ...ckbRawTx.outputs],
    outputsData: ["0x", ...ckbRawTx.outputsData],
    witnesses: [{ lock: "", inputType: "", outputType: "" }, ...ckbRawTx.witnesses]
  };
  const txSize = getTransactionSize5(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  const changeCapacity = BigInt(emptyCells[0].output.capacity) - estimatedTxFee;
  rawTx.outputs[0].capacity = append0x(changeCapacity.toString(16));
  const keyMap = /* @__PURE__ */ new Map();
  keyMap.set(scriptToHash3(masterLock), secp256k1PrivateKey);
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput,
    lock: index === 0 ? masterLock : getBtcTimeLockScript(isMainnet)
  }));
  const transactionHash = rawTransactionToHash3(rawTx);
  const signedWitnesses = signWitnesses3(keyMap)({
    transactionHash,
    witnesses: rawTx.witnesses,
    inputCells: cells,
    skipMissingKeys: true
  });
  const signedTx = {
    ...rawTx,
    witnesses: signedWitnesses.map(
      (witness) => typeof witness !== "string" ? serializeWitnessArgs3(witness) : witness
    )
  };
  return signedTx;
};
var isBtcTimeCellsSpent = async ({
  collector,
  ckbAddress,
  btcTxId,
  btcTestnetType
}) => {
  const isMainnet = ckbAddress.startsWith("ckb");
  const lock = addressToScript4(ckbAddress);
  const btcTimeLock = {
    ...getBtcTimeLockScript(isMainnet, btcTestnetType),
    args: genBtcTimeLockArgs(lock, btcTxId, BTC_JUMP_CONFIRMATION_BLOCKS)
  };
  const btcTimeCells = await collector.getCells({ lock: btcTimeLock, isDataMustBeEmpty: false });
  const isSpent = !btcTimeCells || btcTimeCells.length === 0;
  return isSpent;
};

// src/rgbpp/ckb-jump-btc.ts
import { blockchain as blockchain5 } from "@ckb-lumos/base";
import { addressToScript as addressToScript5, getTransactionSize as getTransactionSize6 } from "@nervosnetwork/ckb-sdk-utils";
var genCkbJumpBtcVirtualTx = async ({
  collector,
  xudtTypeBytes,
  fromCkbAddress,
  toRgbppLockArgs,
  transferAmount,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const isMainnet = fromCkbAddress.startsWith("ckb");
  const xudtType = blockchain5.Script.unpack(xudtTypeBytes);
  if (!isTypeAssetSupported(xudtType, isMainnet)) {
    throw new TypeAssetNotSupportedError("The type script asset is not supported now");
  }
  const fromLock = addressToScript5(fromCkbAddress);
  const xudtCells = await collector.getCells({ lock: fromLock, type: xudtType });
  if (!xudtCells || xudtCells.length === 0) {
    throw new NoXudtLiveCellError("No rgbpp cells found with the xudt type script and the rgbpp lock args");
  }
  const collected = collector.collectUdtInputs({
    liveCells: xudtCells,
    needAmount: transferAmount
  });
  let { inputs, sumInputsCapacity } = collected;
  const { sumAmount } = collected;
  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const outputsData = [append0x(u128ToLe(transferAmount))];
  const outputs = [
    {
      lock: genRgbppLockScript(toRgbppLockArgs, isMainnet, btcTestnetType),
      type: xudtType,
      capacity: append0x(rpbppCellCapacity.toString(16))
    }
  ];
  const txFee = MAX_FEE;
  const xudtCellCapacity = calculateUdtCellCapacity(fromLock, xudtType);
  if (sumInputsCapacity < xudtCellCapacity + rpbppCellCapacity + MIN_CAPACITY + txFee) {
    let emptyCells = await collector.getCells({ lock: fromLock });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError("The address has no empty cells");
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);
    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
      emptyCells,
      rpbppCellCapacity,
      txFee
    );
    inputs = [...emptyInputs, ...inputs];
    sumInputsCapacity += sumEmptyCapacity;
  }
  let changeCapacity = sumInputsCapacity - rpbppCellCapacity - txFee;
  if (sumAmount > transferAmount) {
    outputs.push({
      lock: fromLock,
      type: xudtType,
      capacity: append0x(xudtCellCapacity.toString(16))
    });
    outputsData.push(append0x(u128ToLe(sumAmount - transferAmount)));
    changeCapacity -= xudtCellCapacity;
  }
  outputs.push({
    lock: fromLock,
    capacity: append0x(changeCapacity.toString(16))
  });
  outputsData.push("0x");
  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { xudt: true });
  const witnesses = inputs.map(() => "0x");
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize6(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));
  }
  return ckbRawTx;
};
var genCkbBatchJumpBtcVirtualTx = async ({
  collector,
  xudtTypeBytes,
  fromCkbAddress,
  rgbppReceivers,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const isMainnet = fromCkbAddress.startsWith("ckb");
  const xudtType = blockchain5.Script.unpack(xudtTypeBytes);
  if (!isTypeAssetSupported(xudtType, isMainnet)) {
    throw new TypeAssetNotSupportedError("The type script asset is not supported now");
  }
  const fromLock = addressToScript5(fromCkbAddress);
  const xudtCells = await collector.getCells({ lock: fromLock, type: xudtType });
  if (!xudtCells || xudtCells.length === 0) {
    throw new NoXudtLiveCellError("No rgbpp cells found with the xudt type script and the rgbpp lock args");
  }
  const sumTransferAmount = rgbppReceivers.map((receiver) => receiver.transferAmount).reduce((prev, current) => prev + current, BigInt(0));
  const collected = collector.collectUdtInputs({
    liveCells: xudtCells,
    needAmount: sumTransferAmount
  });
  let { inputs, sumInputsCapacity } = collected;
  const { sumAmount } = collected;
  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);
  const sumRgbppCellCapacity = rpbppCellCapacity * BigInt(rgbppReceivers.length);
  const outputs = rgbppReceivers.map((receiver) => ({
    lock: genRgbppLockScript(receiver.toRgbppLockArgs, isMainnet, btcTestnetType),
    type: xudtType,
    capacity: append0x(rpbppCellCapacity.toString(16))
  }));
  const outputsData = rgbppReceivers.map((receiver) => append0x(u128ToLe(receiver.transferAmount)));
  const txFee = MAX_FEE;
  const xudtCellCapacity = calculateUdtCellCapacity(fromLock, xudtType);
  if (sumInputsCapacity < xudtCellCapacity + sumRgbppCellCapacity + MIN_CAPACITY + txFee) {
    let emptyCells = await collector.getCells({ lock: fromLock });
    if (!emptyCells || emptyCells.length === 0) {
      throw new NoLiveCellError("The address has no empty cells");
    }
    emptyCells = emptyCells.filter((cell) => !cell.output.type);
    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(
      emptyCells,
      rpbppCellCapacity,
      txFee
    );
    inputs = [...emptyInputs, ...inputs];
    sumInputsCapacity += sumEmptyCapacity;
  }
  let changeCapacity = sumInputsCapacity - sumRgbppCellCapacity - txFee;
  if (sumAmount > sumTransferAmount) {
    outputs.push({
      lock: fromLock,
      type: xudtType,
      capacity: append0x(xudtCellCapacity.toString(16))
    });
    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));
    changeCapacity -= xudtCellCapacity;
  }
  outputs.push({
    lock: fromLock,
    capacity: append0x(changeCapacity.toString(16))
  });
  outputsData.push("0x");
  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { xudt: true });
  const witnesses = inputs.map(() => "0x");
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  if (txFee === MAX_FEE) {
    const txSize = getTransactionSize6(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);
    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));
  }
  return ckbRawTx;
};

// src/rgbpp/launch.ts
import { getTransactionSize as getTransactionSize7, scriptToHash as scriptToHash4 } from "@nervosnetwork/ckb-sdk-utils";
var genRgbppLaunchCkbVirtualTx = async ({
  collector,
  ownerRgbppLockArgs,
  launchAmount,
  rgbppTokenInfo,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  isMainnet,
  btcTestnetType
}) => {
  const ownerLock = genRgbppLockScript(ownerRgbppLockArgs, isMainnet, btcTestnetType);
  let emptyCells = await collector.getCells({ lock: ownerLock });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError("The owner address has no empty cells");
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  const infoCellCapacity = calculateRgbppTokenInfoCellCapacity(rgbppTokenInfo, isMainnet);
  const txFee = MAX_FEE;
  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, infoCellCapacity, txFee);
  let rgbppCellCapacity = sumInputsCapacity - infoCellCapacity;
  const outputs = [
    {
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: {
        ...getXudtTypeScript(isMainnet),
        args: append0x(scriptToHash4(ownerLock))
      },
      capacity: append0x(rgbppCellCapacity.toString(16))
    },
    {
      lock: genBtcTimeLockScript(UNLOCKABLE_LOCK_SCRIPT, isMainnet, btcTestnetType),
      type: {
        ...getUniqueTypeScript(isMainnet),
        args: generateUniqueTypeArgs(inputs[0], 1)
      },
      capacity: append0x(infoCellCapacity.toString(16))
    }
  ];
  const outputsData = [append0x(u128ToLe(launchAmount)), encodeRgbppTokenInfo(rgbppTokenInfo)];
  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true, unique: true }, btcTestnetType);
  const witnesses = inputs.map((_, index) => index === 0 ? RGBPP_WITNESS_PLACEHOLDER : "0x");
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  const txSize = getTransactionSize7(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  rgbppCellCapacity -= estimatedTxFee;
  ckbRawTx.outputs[0].capacity = append0x(rgbppCellCapacity.toString(16));
  const virtualTx = {
    ...ckbRawTx,
    outputs: ckbRawTx.outputs
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    needPaymasterCell: false
  };
};

// src/spore/cluster.ts
import { packRawClusterData as packRawClusterData2 } from "@spore-sdk/core";
import { bytesToHex as bytesToHex5, getTransactionSize as getTransactionSize8 } from "@nervosnetwork/ckb-sdk-utils";
var genCreateClusterCkbVirtualTx = async ({
  collector,
  rgbppLockArgs,
  clusterData,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const rgbppLock = genRgbppLockScript(rgbppLockArgs, isMainnet, btcTestnetType);
  const rgbppCells = await collector.getCells({ lock: rgbppLock });
  if (!rgbppCells || rgbppCells.length === 0) {
    throw new NoRgbppLiveCellError("No rgbpp cells found with the rgbpp lock args");
  }
  const rgbppCell = rgbppCells[0];
  const inputs = [
    {
      previousOutput: rgbppCell.outPoint,
      since: "0x0"
    }
  ];
  const clusterId = generateClusterId(inputs[0], 0);
  const outputs = [
    {
      ...rgbppCell.output,
      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),
      type: {
        ...getClusterTypeScript(isMainnet),
        args: clusterId
      }
    }
  ];
  const outputsData = [bytesToHex5(packRawClusterData2(clusterData))];
  const cellDeps = [
    ...await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType),
    getClusterTypeDep(isMainnet)
  ];
  const sporeCoBuild = generateClusterCreateCoBuild(outputs[0], outputsData[0]);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  let changeCapacity = BigInt(rgbppCell.output.capacity);
  const txSize = getTransactionSize8(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    clusterId,
    needPaymasterCell: false
  };
};

// src/spore/spore.ts
import { packRawSporeData as packRawSporeData2 } from "@spore-sdk/core";
import signWitnesses4 from "@nervosnetwork/ckb-sdk-core/lib/signWitnesses";
import {
  addressToScript as addressToScript6,
  bytesToHex as bytesToHex6,
  getTransactionSize as getTransactionSize9,
  rawTransactionToHash as rawTransactionToHash4,
  scriptToHash as scriptToHash5,
  serializeWitnessArgs as serializeWitnessArgs4
} from "@nervosnetwork/ckb-sdk-utils";
var genCreateSporeCkbVirtualTx = async ({
  collector,
  clusterRgbppLockArgs,
  sporeDataList,
  isMainnet,
  btcTestnetType
}) => {
  const clusterRgbppLock = genRgbppLockScript(clusterRgbppLockArgs, isMainnet, btcTestnetType);
  const clusterCells = await collector.getCells({ lock: clusterRgbppLock, isDataMustBeEmpty: false });
  if (!clusterCells || clusterCells.length === 0) {
    throw new NoRgbppLiveCellError("No cluster rgbpp cells found with the cluster rgbpp lock args");
  }
  if (clusterCells.length > 1) {
    throw new RgbppUtxoBindMultiTypeAssetsError("The BTC UTXO must not be bound to multiple CKB cells");
  }
  const clusterCell = clusterCells[0];
  if (!clusterCell.output.type || !isClusterSporeTypeSupported(clusterCell.output.type, isMainnet)) {
    throw new TypeAssetNotSupportedError("The type script asset is not supported now");
  }
  const sumInputsCapacity = clusterCell.output.capacity;
  const inputs = [
    {
      previousOutput: clusterCell.outPoint,
      since: "0x0"
    }
  ];
  const clusterCellDep = {
    outPoint: clusterCell.outPoint,
    depType: "code"
  };
  const sporeOutputs = sporeDataList.map((data, index) => ({
    // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster and Vouts[2]... for spore
    lock: genRgbppLockScript(buildPreLockArgs(index + 2), isMainnet, btcTestnetType),
    type: {
      ...getSporeTypeScript(isMainnet),
      // The CKB transaction outputs[0] fro cluster and outputs[1]... for spore
      args: generateSporeId(inputs[0], index + 1)
    },
    capacity: append0x(calculateRgbppSporeCellCapacity(data).toString(16))
  }));
  const sporeOutputsData = sporeDataList.map((data) => bytesToHex6(packRawSporeData2(data)));
  const outputs = [
    {
      ...clusterCell.output,
      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType)
    },
    ...sporeOutputs
  ];
  const outputsData = [clusterCell.outputData, ...sporeOutputsData];
  const cellDeps = [
    ...await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType),
    getClusterTypeDep(isMainnet),
    getSporeTypeDep(isMainnet),
    clusterCellDep
  ];
  const sporeCoBuild = generateSporeCreateCoBuild({
    sporeOutputs,
    sporeOutputsData,
    clusterCell,
    clusterOutputCell: outputs[0]
  });
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    sumInputsCapacity,
    clusterCell,
    needPaymasterCell: false
  };
};
var CELL_DEP_SIZE = 32 + 4 + 1;
var buildAppendingIssuerCellToSporesCreateTx = async ({
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  witnessLockPlaceholderSize = SECP256K1_WITNESS_LOCK_SIZE,
  ckbFeeRate
}) => {
  const rawTx = ckbRawTx;
  const sumOutputsCapacity = rawTx.outputs.map((output) => BigInt(output.capacity)).reduce((prev, current) => prev + current, BigInt(0));
  const issuerLock = addressToScript6(issuerAddress);
  let emptyCells = await collector.getCells({ lock: issuerLock });
  if (!emptyCells || emptyCells.length === 0) {
    throw new NoLiveCellError("The issuer address has no empty cells");
  }
  emptyCells = emptyCells.filter((cell) => !cell.output.type);
  let actualInputsCapacity = BigInt(sumInputsCapacity);
  const txFee = MAX_FEE;
  if (actualInputsCapacity <= sumOutputsCapacity) {
    const needCapacity = sumOutputsCapacity - actualInputsCapacity + MIN_CAPACITY;
    const { inputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee);
    rawTx.inputs = [...rawTx.inputs, ...inputs];
    actualInputsCapacity += sumEmptyCapacity;
  }
  let changeCapacity = actualInputsCapacity - sumOutputsCapacity;
  const changeOutput = {
    lock: issuerLock,
    capacity: append0x(changeCapacity.toString(16))
  };
  rawTx.outputs = [...rawTx.outputs, changeOutput];
  rawTx.outputsData = [...rawTx.outputsData, "0x"];
  const txSize = getTransactionSize9(rawTx) + witnessLockPlaceholderSize + CELL_DEP_SIZE;
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  return rawTx;
};
var appendIssuerCellToSporesCreate = async ({
  secp256k1PrivateKey,
  issuerAddress,
  collector,
  ckbRawTx,
  sumInputsCapacity,
  isMainnet,
  ckbFeeRate
}) => {
  const rgbppInputsLength = ckbRawTx.inputs.length;
  const rawTx = await buildAppendingIssuerCellToSporesCreateTx({
    issuerAddress,
    collector,
    ckbRawTx,
    sumInputsCapacity,
    ckbFeeRate
  });
  rawTx.cellDeps = [...rawTx.cellDeps, getSecp256k1CellDep(isMainnet)];
  const issuerLock = addressToScript6(issuerAddress);
  const keyMap = /* @__PURE__ */ new Map();
  keyMap.set(scriptToHash5(issuerLock), secp256k1PrivateKey);
  const issuerCellIndex = rgbppInputsLength;
  const cells = rawTx.inputs.map((input, index) => ({
    outPoint: input.previousOutput,
    lock: index >= issuerCellIndex ? issuerLock : getRgbppLockScript(isMainnet)
  }));
  const emptyWitness = { lock: "", inputType: "", outputType: "" };
  const issuerWitnesses = rawTx.inputs.slice(rgbppInputsLength).map((_, index) => index === 0 ? emptyWitness : "0x");
  const lastRawTxWitnessIndex = rawTx.witnesses.length - 1;
  rawTx.witnesses = [
    ...rawTx.witnesses.slice(0, lastRawTxWitnessIndex),
    ...issuerWitnesses,
    // The cobuild witness will be placed to the tail of the witnesses
    rawTx.witnesses[lastRawTxWitnessIndex]
  ];
  const transactionHash = rawTransactionToHash4(rawTx);
  const signedWitnesses = signWitnesses4(keyMap)({
    transactionHash,
    witnesses: rawTx.witnesses,
    inputCells: cells,
    skipMissingKeys: true
  });
  const signedTx = {
    ...rawTx,
    witnesses: signedWitnesses.map(
      (witness) => typeof witness !== "string" ? serializeWitnessArgs4(witness) : witness
    )
  };
  return signedTx;
};
var genTransferSporeCkbVirtualTx = async ({
  collector,
  sporeRgbppLockArgs,
  sporeTypeBytes,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const sporeRgbppLock = genRgbppLockScript(sporeRgbppLockArgs, isMainnet, btcTestnetType);
  const sporeCells = await collector.getCells({ lock: sporeRgbppLock, isDataMustBeEmpty: false });
  throwErrorWhenSporeCellsInvalid(sporeCells, sporeTypeBytes, isMainnet);
  const sporeCell = sporeCells[0];
  const inputs = [
    {
      previousOutput: sporeCell.outPoint,
      since: "0x0"
    }
  ];
  const outputs = [
    {
      ...sporeCell.output,
      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for spore
      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType)
    }
  ];
  const outputsData = [sporeCell.outputData];
  const cellDeps = [
    ...await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType),
    getSporeTypeDep(isMainnet)
  ];
  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  let changeCapacity = BigInt(sporeCell.output.capacity);
  const txSize = getTransactionSize9(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    sporeCell,
    needPaymasterCell: false,
    sumInputsCapacity: sporeCell.output.capacity
  };
};

// src/spore/leap.ts
import { blockchain as blockchain6 } from "@ckb-lumos/base";
import {
  addressToScript as addressToScript7,
  getTransactionSize as getTransactionSize10,
  serializeOutPoint as serializeOutPoint3,
  serializeWitnessArgs as serializeWitnessArgs5
} from "@nervosnetwork/ckb-sdk-utils";
var genLeapSporeFromBtcToCkbVirtualTx = async ({
  collector,
  sporeRgbppLockArgs,
  sporeTypeBytes,
  toCkbAddress,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const sporeRgbppLock = {
    ...getRgbppLockScript(isMainnet, btcTestnetType),
    args: append0x(sporeRgbppLockArgs)
  };
  const sporeCells = await collector.getCells({ lock: sporeRgbppLock, isDataMustBeEmpty: false });
  throwErrorWhenSporeCellsInvalid(sporeCells, sporeTypeBytes, isMainnet);
  const sporeCell = sporeCells[0];
  const inputs = [
    {
      previousOutput: sporeCell.outPoint,
      since: "0x0"
    }
  ];
  const toLock = addressToScript7(toCkbAddress);
  const outputs = [
    {
      ...sporeCell.output,
      lock: genBtcTimeLockScript(toLock, isMainnet, btcTestnetType)
    }
  ];
  const outputsData = [sporeCell.outputData];
  const cellDeps = [
    ...await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType),
    getSporeTypeDep(isMainnet)
  ];
  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  let changeCapacity = BigInt(sporeCell.output.capacity);
  const txSize = getTransactionSize10(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  const virtualTx = {
    ...ckbRawTx
  };
  const commitment = calculateCommitment(virtualTx);
  return {
    ckbRawTx,
    commitment,
    sporeCell,
    needPaymasterCell: false,
    sumInputsCapacity: sporeCell.output.capacity
  };
};
var buildSporeBtcTimeCellsSpentTx = async ({
  btcTimeCells,
  btcAssetsApi,
  isMainnet,
  btcTestnetType
}) => {
  const sortedBtcTimeCells = btcTimeCells.sort(compareInputs);
  const inputs = sortedBtcTimeCells.map((cell) => ({
    previousOutput: cell.outPoint,
    since: "0x0"
  }));
  const outputs = sortedBtcTimeCells.map((cell) => ({
    lock: lockScriptFromBtcTimeLockArgs(cell.output.lock.args),
    type: cell.output.type,
    capacity: cell.output.capacity
  }));
  const outputsData = sortedBtcTimeCells.map((cell) => cell.outputData);
  const cellDeps = [
    ...await fetchTypeIdCellDeps(isMainnet, { btcTime: true }, btcTestnetType),
    getSporeTypeDep(isMainnet)
  ];
  const witnesses = [];
  const lockArgsSet = /* @__PURE__ */ new Set();
  const cellDepsSet = /* @__PURE__ */ new Set();
  for await (const btcTimeCell of sortedBtcTimeCells) {
    if (lockArgsSet.has(btcTimeCell.output.lock.args)) {
      witnesses.push("0x");
      continue;
    }
    lockArgsSet.add(btcTimeCell.output.lock.args);
    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);
    const result = await btcAssetsApi.getRgbppSpvProof(btcTxId, after);
    const { spvClient, proof } = transformSpvProof(result);
    if (!cellDepsSet.has(serializeOutPoint3(spvClient))) {
      cellDeps.push(buildSpvClientCellDep(spvClient));
      cellDepsSet.add(serializeOutPoint3(spvClient));
    }
    const btcTimeWitness = append0x(
      serializeWitnessArgs5({ lock: buildBtcTimeUnlockWitness(proof), inputType: "", outputType: "" })
    );
    witnesses.push(btcTimeWitness);
  }
  const sporeCoBuild = generateSporeTransferCoBuild(sortedBtcTimeCells, outputs);
  witnesses.push(sporeCoBuild);
  const ckbTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  return ckbTx;
};
var genLeapSporeFromCkbToBtcRawTx = async ({
  collector,
  sporeTypeBytes,
  fromCkbAddress,
  toRgbppLockArgs,
  isMainnet,
  witnessLockPlaceholderSize,
  ckbFeeRate,
  btcTestnetType
}) => {
  const fromLock = addressToScript7(fromCkbAddress);
  const sporeType = blockchain6.Script.unpack(sporeTypeBytes);
  const sporeCells = await collector.getCells({ lock: fromLock, type: sporeType });
  if (!sporeCells || sporeCells.length === 0) {
    throw new NoRgbppLiveCellError("No spore rgbpp cells found with the spore rgbpp lock args and spore type script");
  }
  const sporeCell = sporeCells[0];
  const inputs = [
    {
      previousOutput: sporeCell.outPoint,
      since: "0x0"
    }
  ];
  const outputs = [
    {
      ...sporeCell.output,
      lock: {
        ...getRgbppLockScript(isMainnet, btcTestnetType),
        args: append0x(toRgbppLockArgs)
      }
    }
  ];
  const outputsData = [sporeCell.outputData];
  const cellDeps = [getSporeTypeDep(isMainnet)];
  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);
  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];
  const ckbRawTx = {
    version: "0x0",
    cellDeps,
    headerDeps: [],
    inputs,
    outputs,
    outputsData,
    witnesses
  };
  let changeCapacity = BigInt(sporeCell.output.capacity);
  const txSize = getTransactionSize10(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);
  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);
  changeCapacity -= estimatedTxFee;
  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));
  return ckbRawTx;
};
export {
  BTCTimeLock,
  BTCTimeLockConfig,
  BTCTimeUnlock,
  BTC_JUMP_CONFIRMATION_BLOCKS,
  Block,
  BlockV1,
  Byte32,
  Byte32Vec,
  Bytes,
  BytesOpt,
  BytesOptVec,
  BytesVec,
  CKB_UNIT,
  CapacityNotEnoughError,
  CellDep,
  CellDepVec,
  CellInput,
  CellInputVec,
  CellOutput,
  CellOutputVec,
  CellbaseWitness,
  Collector,
  ExtraCommitmentData,
  Header,
  IndexerError,
  InputsCapacityNotEnoughError,
  InputsOrOutputsLenError,
  InvalidCellIdError,
  MAX_FEE,
  MIN_CAPACITY,
  NoLiveCellError,
  NoRgbppLiveCellError,
  NoXudtLiveCellError,
  OutPoint,
  ProposalShortId,
  ProposalShortIdVec,
  RGBPPConfig,
  RGBPPLock,
  RGBPPUnlock,
  RGBPP_TX_ID_PLACEHOLDER,
  RGBPP_TX_INPUTS_MAX_LENGTH,
  RGBPP_TX_WITNESS_MAX_SIZE,
  RGBPP_WITNESS_PLACEHOLDER,
  RawHeader,
  RawTransaction,
  RgbppCkbTxInputsExceededError,
  RgbppSporeTypeMismatchError,
  RgbppUtxoBindMultiTypeAssetsError,
  SECP256K1_WITNESS_LOCK_SIZE,
  Script,
  ScriptOpt,
  Transaction,
  TransactionVec,
  TypeAssetNotSupportedError,
  UNLOCKABLE_LOCK_SCRIPT,
  UdtAmountNotEnoughError,
  Uint16,
  Uint256,
  UncleBlock,
  UncleBlockVec,
  WitnessArgs,
  append0x,
  appendCkbTxWitnesses,
  appendIssuerCellToBtcBatchTransfer,
  appendIssuerCellToSporesCreate,
  appendPaymasterCellAndSignCkbTx,
  btcTxIdAndAfterFromBtcTimeLockArgs,
  buildAppendingIssuerCellToSporesCreateTx,
  buildBtcTimeCellsSpentTx,
  buildBtcTimeUnlockWitness,
  buildPreLockArgs,
  buildRgbppLockArgs,
  buildRgbppUnlockWitness,
  buildSporeBtcTimeCellsSpentTx,
  buildSpvClientCellDep,
  calculateCellOccupiedCapacity,
  calculateCommitment,
  calculateRgbppCellCapacity,
  calculateRgbppClusterCellCapacity,
  calculateRgbppSporeCellCapacity,
  calculateRgbppTokenInfoCellCapacity,
  calculateRgbppTokenInfoSize,
  calculateTransactionFee,
  calculateUdtCellCapacity,
  calculateXudtTokenInfoCellCapacity,
  checkCkbTxInputsCapacitySufficient,
  compareInputs,
  decodeCellId,
  deduplicateList,
  encodeCellId,
  encodeRgbppTokenInfo,
  estimateWitnessSize,
  fetchTypeIdCellDeps,
  genBtcBatchTransferCkbVirtualTx,
  genBtcJumpCkbVirtualTx,
  genBtcTimeLockArgs,
  genBtcTimeLockScript,
  genBtcTransferCkbVirtualTx,
  genCkbBatchJumpBtcVirtualTx,
  genCkbJumpBtcVirtualTx,
  genCreateClusterCkbVirtualTx,
  genCreateSporeCkbVirtualTx,
  genLeapSporeFromBtcToCkbVirtualTx,
  genLeapSporeFromCkbToBtcRawTx,
  genRgbppLaunchCkbVirtualTx,
  genRgbppLockScript,
  genTransferSporeCkbVirtualTx,
  generateClusterCreateCoBuild,
  generateClusterId,
  generateSporeCreateCoBuild,
  generateSporeId,
  generateSporeTransferCoBuild,
  generateUniqueTypeArgs,
  getBtcTimeLockConfigDep,
  getBtcTimeLockDep,
  getBtcTimeLockScript,
  getClusterTypeDep,
  getClusterTypeScript,
  getRgbppLockConfigDep,
  getRgbppLockDep,
  getRgbppLockScript,
  getSecp256k1CellDep,
  getSporeTypeDep,
  getSporeTypeScript,
  getUniqueTypeDep,
  getUniqueTypeScript,
  getXudtDep,
  getXudtTypeScript,
  hexToUtf8,
  isBtcTimeCellsSpent,
  isBtcTimeLockCell,
  isClusterSporeTypeSupported,
  isLockArgsSizeExceeded,
  isRgbppCapacitySufficientForChange,
  isRgbppLockCell,
  isRgbppLockCellIgnoreChain,
  isRgbppLockOrBtcTimeLock,
  isScriptEqual,
  isSporeTypeSupported,
  isTypeAssetSupported,
  isUDTTypeSupported,
  leToU128,
  leToU32,
  lockScriptFromBtcTimeLockArgs,
  remove0x,
  replaceLockArgsWithRealBtcTxId,
  reverseHex,
  sendCkbTx,
  serializeScript2 as serializeScript,
  signBtcTimeCellSpentTx,
  splitMultiCellsWithSecp256k1,
  throwErrorWhenRgbppCellsInvalid,
  throwErrorWhenSporeCellsInvalid,
  throwErrorWhenTxInputsExceeded,
  toCamelcase,
  transformSpvProof,
  u128ToLe,
  u16ToLe,
  u32ToBe,
  u32ToLe,
  u32ToLeHex,
  u64ToLe,
  u8ToHex,
  unpackRgbppLockArgs,
  updateCkbTxWithRealBtcTxId,
  utf8ToHex
};
//# sourceMappingURL=index.mjs.map