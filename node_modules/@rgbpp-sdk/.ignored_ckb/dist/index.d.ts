import * as _ckb_lumos_codec_lib_number from '@ckb-lumos/codec/lib/number';
import * as _ckb_lumos_codec_lib_base from '@ckb-lumos/codec/lib/base';
import * as _ckb_lumos_codec from '@ckb-lumos/codec';
import { molecule, BytesLike } from '@ckb-lumos/codec';
import CKB from '@nervosnetwork/ckb-sdk-core';
import { RgbppApiSpvProof, BtcAssetsApi } from '@rgbpp-sdk/service';
import { RawClusterData, RawSporeData, SporeDataProps } from '@spore-sdk/core';
export { RawClusterData, RawSporeData } from '@spore-sdk/core';
import { Hash, HexNumber, OutPoint as OutPoint$1 } from '@ckb-lumos/base';
export { serializeScript } from '@nervosnetwork/ckb-sdk-utils';

declare const Byte32: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
declare const Uint256: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
declare const Bytes: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
declare const BytesOpt: molecule.OptionLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
declare const BytesOptVec: molecule.ArrayLayoutCodec<molecule.OptionLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>>;
declare const BytesVec: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
declare const Byte32Vec: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
declare const ProposalShortId: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
declare const ProposalShortIdVec: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
declare const Script: molecule.ObjectLayoutCodec<{
    codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>;
declare const OutPoint: molecule.ObjectLayoutCodec<{
    txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const CellInput: molecule.ObjectLayoutCodec<{
    since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    previousOutput: molecule.ObjectLayoutCodec<{
        txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const CellDep: molecule.ObjectLayoutCodec<{
    outPoint: molecule.ObjectLayoutCodec<{
        txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const RawHeader: molecule.ObjectLayoutCodec<{
    version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const Header: molecule.ObjectLayoutCodec<{
    raw: molecule.ObjectLayoutCodec<{
        version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
        compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
        timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const UncleBlock: molecule.ObjectLayoutCodec<{
    header: molecule.ObjectLayoutCodec<{
        raw: molecule.ObjectLayoutCodec<{
            version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    proposals: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>;
declare const CellbaseWitness: molecule.ObjectLayoutCodec<{
    lock: molecule.ObjectLayoutCodec<{
        codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }>;
    message: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>;
declare const WitnessArgs: molecule.ObjectLayoutCodec<{
    lock: molecule.OptionLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    inputType: molecule.OptionLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    outputType: molecule.OptionLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>;
declare const ScriptOpt: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
    codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>>;
declare const UncleBlockVec: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
    header: molecule.ObjectLayoutCodec<{
        raw: molecule.ObjectLayoutCodec<{
            version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    proposals: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>>;
declare const CellDepVec: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
    outPoint: molecule.ObjectLayoutCodec<{
        txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed>;
declare const CellInputVec: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
    since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    previousOutput: molecule.ObjectLayoutCodec<{
        txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
}> & _ckb_lumos_codec_lib_base.Fixed>;
declare const CellOutput: molecule.ObjectLayoutCodec<{
    capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    lock: molecule.ObjectLayoutCodec<{
        codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }>;
    type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
        codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }>>;
}>;
declare const CellOutputVec: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
    capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    lock: molecule.ObjectLayoutCodec<{
        codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }>;
    type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
        codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }>>;
}>>;
declare const RawTransaction: molecule.ObjectLayoutCodec<{
    version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    cellDeps: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        outPoint: molecule.ObjectLayoutCodec<{
            txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }> & _ckb_lumos_codec_lib_base.Fixed>;
    headerDeps: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    inputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        previousOutput: molecule.ObjectLayoutCodec<{
            txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
    }> & _ckb_lumos_codec_lib_base.Fixed>;
    outputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        lock: molecule.ObjectLayoutCodec<{
            codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }>;
        type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
            codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }>>;
    }>>;
    outputsData: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>;
declare const Transaction: molecule.ObjectLayoutCodec<{
    raw: molecule.ObjectLayoutCodec<{
        version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
        cellDeps: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
            outPoint: molecule.ObjectLayoutCodec<{
                txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            }> & _ckb_lumos_codec_lib_base.Fixed;
            depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }> & _ckb_lumos_codec_lib_base.Fixed>;
        headerDeps: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
        inputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
            since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            previousOutput: molecule.ObjectLayoutCodec<{
                txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            }> & _ckb_lumos_codec_lib_base.Fixed;
        }> & _ckb_lumos_codec_lib_base.Fixed>;
        outputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
            capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            lock: molecule.ObjectLayoutCodec<{
                codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }>;
            type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
                codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }>>;
        }>>;
        outputsData: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    }>;
    witnesses: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>;
declare const TransactionVec: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
    raw: molecule.ObjectLayoutCodec<{
        version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
        cellDeps: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
            outPoint: molecule.ObjectLayoutCodec<{
                txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            }> & _ckb_lumos_codec_lib_base.Fixed;
            depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }> & _ckb_lumos_codec_lib_base.Fixed>;
        headerDeps: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
        inputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
            since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            previousOutput: molecule.ObjectLayoutCodec<{
                txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            }> & _ckb_lumos_codec_lib_base.Fixed;
        }> & _ckb_lumos_codec_lib_base.Fixed>;
        outputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
            capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            lock: molecule.ObjectLayoutCodec<{
                codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }>;
            type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
                codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }>>;
        }>>;
        outputsData: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    }>;
    witnesses: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>>;
declare const Block: molecule.ObjectLayoutCodec<{
    header: molecule.ObjectLayoutCodec<{
        raw: molecule.ObjectLayoutCodec<{
            version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    uncles: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        header: molecule.ObjectLayoutCodec<{
            raw: molecule.ObjectLayoutCodec<{
                version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }> & _ckb_lumos_codec_lib_base.Fixed;
            nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        proposals: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    }>>;
    transactions: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        raw: molecule.ObjectLayoutCodec<{
            version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            cellDeps: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
                outPoint: molecule.ObjectLayoutCodec<{
                    txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                }> & _ckb_lumos_codec_lib_base.Fixed;
                depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }> & _ckb_lumos_codec_lib_base.Fixed>;
            headerDeps: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
            inputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
                since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                previousOutput: molecule.ObjectLayoutCodec<{
                    txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                }> & _ckb_lumos_codec_lib_base.Fixed;
            }> & _ckb_lumos_codec_lib_base.Fixed>;
            outputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
                capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                lock: molecule.ObjectLayoutCodec<{
                    codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
                }>;
                type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
                    codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
                }>>;
            }>>;
            outputsData: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
        }>;
        witnesses: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    }>>;
    proposals: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
}>;
declare const BlockV1: molecule.ObjectLayoutCodec<{
    header: molecule.ObjectLayoutCodec<{
        raw: molecule.ObjectLayoutCodec<{
            version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
            parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    uncles: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        header: molecule.ObjectLayoutCodec<{
            raw: molecule.ObjectLayoutCodec<{
                version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                compactTarget: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                timestamp: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                number: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                epoch: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                parentHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                transactionsRoot: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                proposalsHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                extraHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                dao: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }> & _ckb_lumos_codec_lib_base.Fixed;
            nonce: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
        }> & _ckb_lumos_codec_lib_base.Fixed;
        proposals: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    }>>;
    transactions: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
        raw: molecule.ObjectLayoutCodec<{
            version: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
            cellDeps: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
                outPoint: molecule.ObjectLayoutCodec<{
                    txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                }> & _ckb_lumos_codec_lib_base.Fixed;
                depType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
            }> & _ckb_lumos_codec_lib_base.Fixed>;
            headerDeps: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
            inputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
                since: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                previousOutput: molecule.ObjectLayoutCodec<{
                    txHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    index: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
                }> & _ckb_lumos_codec_lib_base.Fixed;
            }> & _ckb_lumos_codec_lib_base.Fixed>;
            outputs: molecule.ArrayLayoutCodec<molecule.ObjectLayoutCodec<{
                capacity: _ckb_lumos_codec_lib_base.FixedBytesCodec<_ckb_lumos_codec_lib_number.BI, _ckb_lumos_codec_lib_number.BIish>;
                lock: molecule.ObjectLayoutCodec<{
                    codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
                }>;
                type_: molecule.OptionLayoutCodec<molecule.ObjectLayoutCodec<{
                    codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
                    args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
                }>>;
            }>>;
            outputsData: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
        }>;
        witnesses: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    }>>;
    proposals: molecule.ArrayLayoutCodec<_ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>>;
    extension: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>;

declare const RGBPPConfig: molecule.ObjectLayoutCodec<{
    btcLcTypeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    btcTimeLockTypeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const RGBPPLock: molecule.ObjectLayoutCodec<{
    outIndex: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    btcTxid: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const ExtraCommitmentData: molecule.ObjectLayoutCodec<{
    inputLen: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    outputLen: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const Uint16: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
declare const RGBPPUnlock: molecule.ObjectLayoutCodec<{
    version: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    extraData: molecule.ObjectLayoutCodec<{
        inputLen: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        outputLen: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }> & _ckb_lumos_codec_lib_base.Fixed;
    btcTx: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    btcTxProof: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>;
declare const BTCTimeLock: molecule.ObjectLayoutCodec<{
    lockScript: molecule.ObjectLayoutCodec<{
        codeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        hashType: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
        args: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
    }>;
    after: _ckb_lumos_codec_lib_base.FixedBytesCodec<number, _ckb_lumos_codec_lib_number.BIish>;
    btcTxid: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>;
declare const BTCTimeLockConfig: molecule.ObjectLayoutCodec<{
    btcLcTypeHash: _ckb_lumos_codec_lib_base.FixedBytesCodec<string, _ckb_lumos_codec.BytesLike>;
}> & _ckb_lumos_codec_lib_base.Fixed;
declare const BTCTimeUnlock: molecule.ObjectLayoutCodec<{
    btcTxProof: _ckb_lumos_codec_lib_base.BytesCodec<string, _ckb_lumos_codec.BytesLike>;
}>;

type Hex = string;
type U32 = bigint;
type Address = string;
type Capacity = bigint;
type BTCTestnetType = 'Testnet3' | 'Signet';

interface IndexerCell {
    blockNumber: CKBComponents.BlockNumber;
    outPoint: CKBComponents.OutPoint;
    output: CKBComponents.CellOutput;
    outputData: Hex;
    txIndex: Hex;
}
interface IndexerCapacity {
    blockNumber: CKBComponents.BlockNumber;
    blockHash: CKBComponents.Hash;
    capacity: Hex;
}
interface CollectResult {
    inputs: CKBComponents.CellInput[];
    sumInputsCapacity: Capacity;
}
interface CollectUdtResult extends CollectResult {
    sumAmount: bigint;
}
interface CollectConfig {
    minCapacity?: bigint;
    errMsg?: string;
}

interface ConstructPaymasterParams {
    collector: Collector;
    masterPrivateKey: Hex;
    receiverAddress: Address;
    capacityWithCKB: number;
    cellAmount: number;
}
interface BtcTransferVirtualTxParams {
    collector: Collector;
    xudtTypeBytes: Hex;
    rgbppLockArgsList: Hex[];
    transferAmount: bigint;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    noMergeOutputCells?: boolean;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}
interface RgbppBtcAddressReceiver {
    toBtcAddress: string;
    transferAmount: bigint;
}
interface BtcBatchTransferVirtualTxParams {
    collector: Collector;
    xudtTypeBytes: Hex;
    rgbppLockArgsList: Hex[];
    rgbppReceivers: RgbppBtcAddressReceiver[];
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
}
interface RgbppCkbVirtualTx {
    inputs: CKBComponents.CellInput[];
    outputs: CKBComponents.CellOutput[];
    outputsData: Hex[];
}
interface BaseCkbVirtualTxResult {
    ckbRawTx: CKBComponents.RawTransaction;
    commitment: Hex;
    needPaymasterCell: boolean;
    sumInputsCapacity: Hex;
}
interface BtcTransferVirtualTxResult extends BaseCkbVirtualTxResult {
}
interface BtcBatchTransferVirtualTxResult extends BaseCkbVirtualTxResult {
    rgbppChangeOutIndex: number;
}
interface RgbppLaunchVirtualTxResult {
    ckbRawTx: CKBComponents.RawTransaction;
    commitment: Hex;
    needPaymasterCell: boolean;
}
interface AppendWitnessesParams {
    ckbRawTx: CKBComponents.RawTransaction;
    rgbppApiSpvProof: RgbppApiSpvProof;
    btcTxBytes: Hex;
}
interface AppendPaymasterCellAndSignTxParams {
    secp256k1PrivateKey: Hex;
    ckbRawTx: CKBComponents.RawTransaction;
    sumInputsCapacity: Hex;
    paymasterCell: IndexerCell;
    isMainnet: boolean;
    ckbFeeRate?: bigint;
}
interface SendCkbTxParams {
    collector: Collector;
    signedTx: CKBComponents.RawTransaction;
}
interface BtcJumpCkbVirtualTxParams extends BtcTransferVirtualTxParams {
    toCkbAddress: Address;
    btcConfirmationBlocks?: number;
}
interface BtcJumpCkbVirtualTxResult extends BaseCkbVirtualTxResult {
}
interface BtcTimeCellsParams {
    btcTimeCells: IndexerCell[];
    btcAssetsApi: BtcAssetsApi;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
}
interface SignBtcTimeCellsTxParams {
    secp256k1PrivateKey: Hex;
    ckbRawTx: CKBComponents.RawTransaction;
    collector: Collector;
    masterCkbAddress: Address;
    isMainnet: boolean;
    outputCapacityRange?: Hex[];
    ckbFeeRate?: bigint;
}
interface CkbJumpBtcVirtualTxParams {
    collector: Collector;
    xudtTypeBytes: Hex;
    fromCkbAddress: Address;
    toRgbppLockArgs: Hex;
    transferAmount: bigint;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
    btcTestnetType?: BTCTestnetType;
}
interface UpdateCkbTxWithRealBtcTxIdParams {
    ckbRawTx: CKBComponents.RawTransaction;
    btcTxId: Hex;
    isMainnet: boolean;
}
interface BtcTimeCellStatusParams {
    collector: Collector;
    ckbAddress: Address;
    btcTxId: Hex;
    btcTestnetType?: BTCTestnetType;
}
interface RgbppLockArgsReceiver {
    toRgbppLockArgs: Hex;
    transferAmount: bigint;
}
interface CkbBatchJumpBtcVirtualTxParams {
    collector: Collector;
    xudtTypeBytes: Hex;
    fromCkbAddress: Address;
    rgbppReceivers: RgbppLockArgsReceiver[];
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
    btcTestnetType?: BTCTestnetType;
}
interface AppendIssuerCellToBtcBatchTransfer {
    secp256k1PrivateKey: Hex;
    issuerAddress: Address;
    collector: Collector;
    ckbRawTx: CKBComponents.RawTransaction;
    sumInputsCapacity: Hex;
    isMainnet: boolean;
    ckbFeeRate?: bigint;
}
/**
 * @see {@link https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#xudt-information} for the definition of xUDT information
 */
interface RgbppTokenInfo {
    decimal: number;
    name: string;
    symbol: string;
}
interface RgbppLaunchCkbVirtualTxParams {
    collector: Collector;
    ownerRgbppLockArgs: Address;
    launchAmount: bigint;
    rgbppTokenInfo: RgbppTokenInfo;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}

interface SpvClientCellTxProof {
    spvClient: CKBComponents.OutPoint;
    proof: Hex;
}

interface CreateClusterCkbVirtualTxParams {
    collector: Collector;
    rgbppLockArgs: Hex;
    clusterData: RawClusterData;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}
interface SporeVirtualTxResult {
    ckbRawTx: CKBComponents.RawTransaction;
    commitment: Hex;
    needPaymasterCell: boolean;
    clusterId?: Hex;
}
interface CreateSporeCkbVirtualTxParams {
    collector: Collector;
    clusterRgbppLockArgs: Hex;
    sporeDataList: RawSporeData[];
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}
interface SporeCreateVirtualTxResult {
    ckbRawTx: CKBComponents.RawTransaction;
    commitment: Hex;
    sumInputsCapacity: Hex;
    clusterCell: IndexerCell;
    needPaymasterCell: boolean;
}
interface BuildAppendingIssuerCellTxParams {
    issuerAddress: Address;
    collector: Collector;
    ckbRawTx: CKBComponents.RawTransaction;
    sumInputsCapacity: Hex;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}
interface AppendIssuerCellToSporeCreate {
    secp256k1PrivateKey: Hex;
    issuerAddress: Address;
    collector: Collector;
    ckbRawTx: CKBComponents.RawTransaction;
    sumInputsCapacity: Hex;
    isMainnet: boolean;
    ckbFeeRate?: bigint;
}
interface SporesCreateCobuildParams {
    sporeOutputs: CKBComponents.CellOutput[];
    sporeOutputsData: Hex[];
    clusterCell: IndexerCell;
    clusterOutputCell: CKBComponents.CellOutput;
}
interface TransferSporeCkbVirtualTxParams {
    collector: Collector;
    sporeRgbppLockArgs: Hex;
    sporeTypeBytes: Hex;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}
interface SporeTransferVirtualTxResult {
    ckbRawTx: CKBComponents.RawTransaction;
    commitment: Hex;
    sporeCell: IndexerCell;
    needPaymasterCell: boolean;
    sumInputsCapacity: Hex;
}
interface SporeLeapVirtualTxResult extends SporeTransferVirtualTxResult {
}
interface LeapSporeFromBtcToCkbVirtualTxParams {
    collector: Collector;
    sporeRgbppLockArgs: Hex;
    sporeTypeBytes: Hex;
    toCkbAddress: Address;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}
interface LeapSporeFromCkbToBtcVirtualTxParams {
    collector: Collector;
    fromCkbAddress: Address;
    toRgbppLockArgs: Hex;
    sporeTypeBytes: Hex;
    isMainnet: boolean;
    btcTestnetType?: BTCTestnetType;
    witnessLockPlaceholderSize?: number;
    ckbFeeRate?: bigint;
}

declare class Collector {
    private ckbNodeUrl;
    private ckbIndexerUrl;
    constructor({ ckbNodeUrl, ckbIndexerUrl }: {
        ckbNodeUrl: string;
        ckbIndexerUrl: string;
    });
    getCkb(): CKB;
    getCells({ lock, type, isDataMustBeEmpty, outputCapacityRange, }: {
        lock?: CKBComponents.Script;
        type?: CKBComponents.Script;
        isDataMustBeEmpty?: boolean;
        outputCapacityRange?: Hex[];
    }): Promise<IndexerCell[]>;
    collectInputs(liveCells: IndexerCell[], needCapacity: bigint, fee: bigint, config?: CollectConfig): CollectResult;
    collectUdtInputs({ liveCells, needAmount }: {
        liveCells: IndexerCell[];
        needAmount: bigint;
    }): CollectUdtResult;
    getLiveCell(outPoint: CKBComponents.OutPoint, withData?: boolean): Promise<CKBComponents.LiveCell>;
    getLiveCells(outPoints: CKBComponents.OutPoint[], withData?: boolean): Promise<CKBComponents.LiveCell[]>;
}

declare enum ErrorCode {
    CapacityNotEnough = 100,
    IndexerRpcError = 101,
    NoLiveCell = 102,
    NoXudtLiveCell = 103,
    NoRgbppLiveCell = 104,
    UdtAmountNotEnough = 105,
    InputsCapacityNotEnough = 106,
    TypeAssetNotSupported = 107,
    InputsOrOutputsLenInvalid = 108,
    RgbppCkbTxInputsExceeded = 109,
    RgbppUtxoBindMultiTypeAssets = 110,
    RgbppSporeTypeMismatch = 111,
    InvalidCellId = 112
}
declare class CapacityNotEnoughError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class IndexerError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class NoLiveCellError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class NoXudtLiveCellError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class NoRgbppLiveCellError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class UdtAmountNotEnoughError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class InputsCapacityNotEnoughError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class TypeAssetNotSupportedError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class InputsOrOutputsLenError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class RgbppCkbTxInputsExceededError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class RgbppUtxoBindMultiTypeAssetsError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class RgbppSporeTypeMismatchError extends Error {
    code: ErrorCode;
    constructor(message: string);
}
declare class InvalidCellIdError extends Error {
    code: ErrorCode;
    constructor(message: string);
}

declare const splitMultiCellsWithSecp256k1: ({ masterPrivateKey, collector, receiverAddress, capacityWithCKB, cellAmount, }: ConstructPaymasterParams) => Promise<void>;

/**
 * Generate the virtual ckb transaction for the btc transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param noMergeOutputCells(Optional) The noMergeOutputCells indicates whether the CKB outputs need to be merged. By default, the outputs will be merged.
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genBtcTransferCkbVirtualTx: ({ collector, xudtTypeBytes, rgbppLockArgsList, transferAmount, isMainnet, noMergeOutputCells, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: BtcTransferVirtualTxParams) => Promise<BtcTransferVirtualTxResult>;
/**
 * Generate the virtual ckb transaction for the btc batch transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param rgbppReceivers The rgbpp receiver list which include toBtcAddress and transferAmount
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genBtcBatchTransferCkbVirtualTx: ({ collector, xudtTypeBytes, rgbppLockArgsList, rgbppReceivers, isMainnet, btcTestnetType, }: BtcBatchTransferVirtualTxParams) => Promise<BtcBatchTransferVirtualTxResult>;
/**
 * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer
 * @param issuerAddress The issuer ckb address
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 * @param ckbFeeRate The CKB transaction fee rate, default value is 1100
 */
declare const appendIssuerCellToBtcBatchTransfer: ({ secp256k1PrivateKey, issuerAddress, collector, ckbRawTx, sumInputsCapacity, isMainnet, ckbFeeRate, }: AppendIssuerCellToBtcBatchTransfer) => Promise<CKBComponents.RawTransaction>;

declare const buildRgbppUnlockWitness: (btcTxBytes: Hex, btcTxProof: Hex, inputsLen: number, outputsLen: number) => Hex;
/**
 * Append RGBPP unlock witnesses to ckb tx and the tx can be sent to blockchain if the needPaymasterCell is false.
 * And if the needPaymasterCell is true, appending paymaster cell to inputs and signing ckb tx are required.
 * @param collector The collector that collects CKB live cells and transactions
 * @param spvService SPV RPC service
 * @param btcTxBytes The hex string of btc transaction, refer to https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts#L609
 * @param rgbppApiSpvProof The SPV client cell and tx proof which is from BTCAssetsApi
 */
declare const appendCkbTxWitnesses: ({ ckbRawTx, btcTxBytes, rgbppApiSpvProof, }: AppendWitnessesParams) => Promise<CKBComponents.RawTransaction>;
/**
 * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param paymasterCell The paymaster cell whose type is IndexerCell is used to pay the extra output cell
 * @param ckbFeeRate The CKB transaction fee rate, default value is 1100
 */
declare const appendPaymasterCellAndSignCkbTx: ({ secp256k1PrivateKey, ckbRawTx, sumInputsCapacity, paymasterCell, isMainnet, ckbFeeRate, }: AppendPaymasterCellAndSignTxParams) => Promise<CKBComponents.RawTransaction>;
declare const sendCkbTx: ({ collector, signedTx }: SendCkbTxParams) => Promise<string>;
/**
 * Replace the RGBPP_TX_ID_PLACEHOLDER with the real btc tx id of the rgbpp lock args and BTC time lock args
 * @param ckbRawTx CKB raw transaction
 * @param btcTxId The BTC transaction id
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 */
declare const updateCkbTxWithRealBtcTxId: ({ ckbRawTx, btcTxId, isMainnet, }: UpdateCkbTxWithRealBtcTxIdParams) => CKBComponents.RawTransaction;

/**
 * Generate the virtual ckb transaction for the jumping tx from BTC to CKB
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred
 * @param toCkbAddress The receiver ckb address
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 * @param btcConfirmationBlocks(Optional) The BTC confirmation blocks for BTC Time lock args
 */
declare const genBtcJumpCkbVirtualTx: ({ collector, xudtTypeBytes, rgbppLockArgsList, transferAmount, toCkbAddress, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, btcConfirmationBlocks, }: BtcJumpCkbVirtualTxParams) => Promise<BtcJumpCkbVirtualTxResult>;

declare const buildBtcTimeUnlockWitness: (btcTxProof: Hex) => Hex;
/**
 * Collect btc time cells and spend them to create xUDT cells for the specific lock scripts in the btc time lock args
 * The btc time lock args data structure is: lock_script | after | new_bitcoin_tx_id
 * @param btcTimeCells The BTC time cells of xUDT
 * @param btcAssetsApi BTC Assets Api
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const buildBtcTimeCellsSpentTx: ({ btcTimeCells, btcAssetsApi, isMainnet, btcTestnetType, }: BtcTimeCellsParams) => Promise<CKBComponents.RawTransaction>;
/**
 * Sign the BTC time cells spent transaction with Secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the master address
 * @param ckbRawTx The CKB raw transaction to be signed
 * @param collector The collector that collects CKB live cells and transactions
 * @param masterCkbAddress The master CKB address
 * @param outputCapacityRange(Optional) [u64; 2], filter cells by output capacity range, [inclusive, exclusive]
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 */
declare const signBtcTimeCellSpentTx: ({ secp256k1PrivateKey, ckbRawTx, collector, masterCkbAddress, isMainnet, outputCapacityRange, ckbFeeRate, }: SignBtcTimeCellsTxParams) => Promise<CKBComponents.RawTransaction>;
/**
 * Check if the BTC time cells have been spent. If so, it means the RGB++ asset jumping(from BTC to CKB) has been successful.
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbAddress The CKB address
 * @param btcTxId The BTC transaction id
 */
declare const isBtcTimeCellsSpent: ({ collector, ckbAddress, btcTxId, btcTestnetType, }: BtcTimeCellStatusParams) => Promise<boolean>;

/**
 * Generate the virtual ckb transaction for the jumping tx from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx
 * @param toRgbppLockArgs The receiver rgbpp lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param transferAmount The XUDT amount to be transferred
 * @param witnessLockPlaceholderSize(Optional)  The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional)  The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional)  The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genCkbJumpBtcVirtualTx: ({ collector, xudtTypeBytes, fromCkbAddress, toRgbppLockArgs, transferAmount, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: CkbJumpBtcVirtualTxParams) => Promise<CKBComponents.RawTransaction>;
/**
 * Generate a virtual ckb transaction to realize a batch jump of assets from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param xudtTypeBytes The serialized hex string of the XUDT type script
 * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx
 * @param rgbppReceivers The rgbpp receiver list which include toRgbppLockArgs and transferAmount
 * @param witnessLockPlaceholderSize(Optional)  The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional)  The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genCkbBatchJumpBtcVirtualTx: ({ collector, xudtTypeBytes, fromCkbAddress, rgbppReceivers, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: CkbBatchJumpBtcVirtualTxParams) => Promise<CKBComponents.RawTransaction>;

/**
 * Generate the virtual ckb transaction for the btc transfer tx
 * @param collector The collector that collects CKB live cells and transactions
 * @param ownerRgbppLockArgs The owner RGBPP lock args whose data structure is: out_index | bitcoin_tx_id
 * @param launchAmount The total amount of RGBPP assets issued
 * @param rgbppTokenInfo The RGBPP token info https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#xudt-information
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genRgbppLaunchCkbVirtualTx: ({ collector, ownerRgbppLockArgs, launchAmount, rgbppTokenInfo, witnessLockPlaceholderSize, ckbFeeRate, isMainnet, btcTestnetType, }: RgbppLaunchCkbVirtualTxParams) => Promise<RgbppLaunchVirtualTxResult>;

declare const toCamelcase: <T>(obj: object) => T | null;

declare const remove0x: (hex: string) => string;
declare const append0x: (hex?: string) => string;
declare const u8ToHex: (u8: number) => string;
declare const u16ToLe: (u16: number) => string;
declare const u32ToBe: (u32: string | number) => string;
declare const u32ToLe: (u32: string | number) => string;
declare const u32ToLeHex: (u32: string | number) => string;
declare const leToU32: (leHex: string) => number;
declare const u64ToLe: (u64: bigint) => string;
declare const u128ToLe: (u128: bigint) => string;
declare const leToU128: (leHex: string) => bigint;
declare const utf8ToHex: (text: string) => string;
declare const hexToUtf8: (hex: string) => string;
declare const reverseHex: (str: Hex) => string;

declare const calculateTransactionFee: (txSize: number, feeRate?: bigint) => bigint;
declare const isUDTTypeSupported: (type: CKBComponents.Script, isMainnet: boolean) => boolean;
declare const isSporeTypeSupported: (type: CKBComponents.Script, isMainnet: boolean) => boolean;
declare const isClusterSporeTypeSupported: (type: CKBComponents.Script, isMainnet: boolean) => boolean;
declare const isTypeAssetSupported: (type: CKBComponents.Script, isMainnet: boolean) => boolean;
declare const isLockArgsSizeExceeded: (args: Hex) => boolean;
declare const calculateRgbppCellCapacity: (xudtType?: CKBComponents.Script) => bigint;
declare const calculateUdtCellCapacity: (lock: CKBComponents.Script, udtType?: CKBComponents.Script) => bigint;
declare const calculateXudtTokenInfoCellCapacity: (tokenInfo: RgbppTokenInfo, lock: CKBComponents.Script) => bigint;
declare const calculateRgbppTokenInfoCellCapacity: (tokenInfo: RgbppTokenInfo, isMainnet: boolean) => bigint;
declare const generateUniqueTypeArgs: (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => string;
declare const calculateRgbppClusterCellCapacity: (clusterData: RawClusterData) => bigint;
/**
 * rgbpp_spore_cell:
    lock: rgbpp_lock
    type: spore_type
    data: sporeData
 */
declare const calculateRgbppSporeCellCapacity: (sporeData: SporeDataProps) => bigint;
declare const calculateCellOccupiedCapacity: (cell: IndexerCell) => bigint;
declare const deduplicateList: (rgbppLockArgsList: Hex[]) => Hex[];
declare const isScriptEqual: (s1: Hex | CKBComponents.Script, s2: Hex | CKBComponents.Script) => boolean;
/**
 * Check whether the capacity of inputs is sufficient for outputs
 * @param ckbTx CKB raw transaction
 * @param collector The collector that collects CKB live cells and transactions
 * @returns When the capacity of inputs is sufficient for outputs, return true, otherwise return false
 */
declare const checkCkbTxInputsCapacitySufficient: (ckbTx: CKBComponents.RawTransaction, collector: Collector) => Promise<boolean>;

declare const genRgbppLockScript: (rgbppLockArgs: Hex, isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.Script;
declare const genBtcTimeLockArgs: (lock: CKBComponents.Script, btcTxId: Hex, after: number) => Hex;
/**
 * btcTimeLockArgs:
 * table BTCTimeLock {
    lock_script: Script,
    after: Uint32,
    btc_txid: Byte32,
  }
 */
declare const genBtcTimeLockScript: (toLock: CKBComponents.Script, isMainnet: boolean, btcTestnetType?: BTCTestnetType, btcConfirmationBlocks?: number) => CKBComponents.Script;
declare const calculateCommitment: (rgbppVirtualTx: RgbppCkbVirtualTx | CKBComponents.RawTransaction) => Hex;
/**
 * table BTCTimeLock {
    lock_script: Script,
    after: Uint32,
    btc_txid: Byte32,
  }
 */
declare const lockScriptFromBtcTimeLockArgs: (args: Hex) => CKBComponents.Script;
interface BTCTimeLockArgs {
    btcTxId: Hex;
    after: number;
}
declare const btcTxIdAndAfterFromBtcTimeLockArgs: (args: Hex) => BTCTimeLockArgs;
/**
 * https://learnmeabitcoin.com/technical/general/byte-order/
 * Whenever you're working with transaction/block hashes internally (e.g. inside raw bitcoin data), you use the natural byte order.
 * Whenever you're displaying or searching for transaction/block hashes, you use the reverse byte order.
 */
declare const buildRgbppLockArgs: (outIndex: number, btcTxId: Hex) => Hex;
declare const buildPreLockArgs: (outIndex: number) => string;
interface RgbppLockArgs {
    btcTxId: Hex;
    outIndex: number;
}
declare const unpackRgbppLockArgs: (source: BytesLike) => RgbppLockArgs;
declare const compareInputs: (a: IndexerCell, b: IndexerCell) => 1 | 0 | -1;
declare const replaceLockArgsWithRealBtcTxId: (lockArgs: Hex, txId: Hex) => Hex;
declare const isRgbppLockCell: (cell: CKBComponents.CellOutput, isMainnet: boolean) => boolean;
declare const isRgbppLockCellIgnoreChain: (cell: CKBComponents.CellOutput) => boolean;
declare const isBtcTimeLockCell: (cell: CKBComponents.CellOutput, isMainnet: boolean) => boolean;
declare const isRgbppLockOrBtcTimeLock: (lock: CKBComponents.Script, isMainnet: boolean) => boolean;
declare const transformSpvProof: (spvProof: RgbppApiSpvProof) => SpvClientCellTxProof;
declare const buildSpvClientCellDep: (spvClient: CKBComponents.OutPoint) => CKBComponents.CellDep;
/**
 * Estimate the size of the witness based on the number of groups of lock args
 * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id
 */
declare const estimateWitnessSize: (rgbppLockArgsList: Hex[]) => number;
/**
 * Encode RGBPP token information into hex format
 * @param tokenInfo RGBPP token information
 * @returns hex string for cell data
 */
declare const encodeRgbppTokenInfo: (tokenInfo: RgbppTokenInfo) => string;
declare const calculateRgbppTokenInfoSize: (tokenInfo: RgbppTokenInfo) => bigint;
declare const throwErrorWhenTxInputsExceeded: (inputLen: number) => void;
declare const throwErrorWhenRgbppCellsInvalid: (cells: IndexerCell[] | undefined, xudtTypeBytes: Hex, isMainnet: boolean) => void;
/**
 * Check if the tx's unoccupied capacity is enough to create a new rgbpp-cell as a UDT change cell
 */
declare const isRgbppCapacitySufficientForChange: (sumUdtInputsCapacity: bigint, receiverOutputCapacity: bigint) => boolean;

declare const generateClusterId: (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => string;
declare const generateSporeId: (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => string;
declare const generateClusterCreateCoBuild: (clusterOutput: CKBComponents.CellOutput, clusterOutputData: Hex) => string;
declare const generateSporeCreateCoBuild: ({ sporeOutputs, sporeOutputsData, clusterCell, clusterOutputCell, }: SporesCreateCobuildParams) => string;
declare const generateSporeTransferCoBuild: (sporeCells: IndexerCell[] | CKBComponents.LiveCell[], outputCells: CKBComponents.CellOutput[]) => string;
declare const throwErrorWhenSporeCellsInvalid: (sporeCells: IndexerCell[] | undefined, sporeTypeBytes: Hex, isMainnet: boolean) => void;

interface CellDepsSelected {
    rgbpp?: boolean;
    btcTime?: boolean;
    xudt?: boolean;
    unique?: boolean;
}
declare const fetchTypeIdCellDeps: (isMainnet: boolean, selected: CellDepsSelected, btcTestnetType?: BTCTestnetType) => Promise<CKBComponents.CellDep[]>;

declare const encodeCellId: (txHash: Hash, index: HexNumber) => string;
declare const decodeCellId: (cellId: string) => OutPoint$1;

declare const CKB_UNIT: bigint;
declare const MAX_FEE: bigint;
declare const MIN_CAPACITY: bigint;
declare const SECP256K1_WITNESS_LOCK_SIZE = 65;
declare const BTC_JUMP_CONFIRMATION_BLOCKS = 6;
declare const RGBPP_TX_WITNESS_MAX_SIZE = 5000;
declare const RGBPP_TX_INPUTS_MAX_LENGTH = 40;
declare const RGBPP_WITNESS_PLACEHOLDER = "0xFF";
declare const RGBPP_TX_ID_PLACEHOLDER = "0000000000000000000000000000000000000000000000000000000000000000";
declare const UNLOCKABLE_LOCK_SCRIPT: CKBComponents.Script;
declare const getSecp256k1CellDep: (isMainnet: boolean) => CKBComponents.CellDep;
declare const getXudtTypeScript: (isMainnet: boolean) => CKBComponents.Script;
declare const getXudtDep: (isMainnet: boolean) => CKBComponents.CellDep;
declare const getRgbppLockScript: (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.Script;
declare const getRgbppLockDep: (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.CellDep;
declare const getRgbppLockConfigDep: (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.CellDep;
declare const getBtcTimeLockScript: (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.Script;
declare const getBtcTimeLockDep: (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.CellDep;
declare const getBtcTimeLockConfigDep: (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => CKBComponents.CellDep;
declare const getUniqueTypeScript: (isMainnet: boolean) => CKBComponents.Script;
declare const getUniqueTypeDep: (isMainnet: boolean) => CKBComponents.CellDep;
declare const getClusterTypeScript: (isMainnet: boolean) => CKBComponents.Script;
declare const getClusterTypeDep: (isMainnet: boolean) => CKBComponents.CellDep;
declare const getSporeTypeScript: (isMainnet: boolean) => CKBComponents.Script;
declare const getSporeTypeDep: (isMainnet: boolean) => CKBComponents.CellDep;

/**
 * Generate the virtual ckb transaction for creating cluster
 * @param collector The collector that collects CKB live cells and transactions
 * @param rgbppLockArgs The rgbpp assets cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param clusterData The cluster's data, including name and description.
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genCreateClusterCkbVirtualTx: ({ collector, rgbppLockArgs, clusterData, isMainnet, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: CreateClusterCkbVirtualTxParams) => Promise<SporeVirtualTxResult>;

/**
 * Generate the virtual ckb transaction for creating spores
 * @param collector The collector that collects CKB live cells and transactions
 * @param clusterRgbppLockArgs The cluster rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeDataList The spore's data list, including name and description.
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genCreateSporeCkbVirtualTx: ({ collector, clusterRgbppLockArgs, sporeDataList, isMainnet, btcTestnetType, }: CreateSporeCkbVirtualTxParams) => Promise<SporeCreateVirtualTxResult>;
/**
 * Append paymaster cell to the ckb transaction inputs and build the raw tx to be signed for spores creation
 * @param issuerAddress The issuer ckb address
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 65
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 */
declare const buildAppendingIssuerCellToSporesCreateTx: ({ issuerAddress, collector, ckbRawTx, sumInputsCapacity, witnessLockPlaceholderSize, ckbFeeRate, }: BuildAppendingIssuerCellTxParams) => Promise<CKBComponents.RawTransactionToSign>;
/**
 * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key
 * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer
 * @param issuerAddress The issuer ckb address
 * @param collector The collector that collects CKB live cells and transactions
 * @param ckbRawTx CKB raw transaction
 * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 */
declare const appendIssuerCellToSporesCreate: ({ secp256k1PrivateKey, issuerAddress, collector, ckbRawTx, sumInputsCapacity, isMainnet, ckbFeeRate, }: AppendIssuerCellToSporeCreate) => Promise<CKBComponents.RawTransaction>;
/**
 * Generate the virtual ckb transaction for transferring spore
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genTransferSporeCkbVirtualTx: ({ collector, sporeRgbppLockArgs, sporeTypeBytes, isMainnet, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: TransferSporeCkbVirtualTxParams) => Promise<SporeTransferVirtualTxResult>;

/**
 * Generate the virtual ckb transaction for leaping spore from BTC to CKB
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param toCkbAddress The receiver ckb address
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const genLeapSporeFromBtcToCkbVirtualTx: ({ collector, sporeRgbppLockArgs, sporeTypeBytes, toCkbAddress, isMainnet, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: LeapSporeFromBtcToCkbVirtualTxParams) => Promise<SporeLeapVirtualTxResult>;
/**
 * Collect btc time cells and spend them to create spore cells for the specific lock scripts in the btc time lock args
 * The btc time lock args data structure is: lock_script | after | new_bitcoin_tx_id
 * @param btcTimeCells The BTC time cells of spore
 * @param btcAssetsApi BTC Assets Api
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)
 * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3
 */
declare const buildSporeBtcTimeCellsSpentTx: ({ btcTimeCells, btcAssetsApi, isMainnet, btcTestnetType, }: BtcTimeCellsParams) => Promise<CKBComponents.RawTransaction>;
/**
 * Generate the virtual ckb transaction for leaping spore from CKB to BTC
 * @param collector The collector that collects CKB live cells and transactions
 * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id
 * @param sporeTypeBytes The spore type script serialized bytes
 * @param toCkbAddress The receiver ckb address
 * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet
 * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000
 * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100
 */
declare const genLeapSporeFromCkbToBtcRawTx: ({ collector, sporeTypeBytes, fromCkbAddress, toRgbppLockArgs, isMainnet, witnessLockPlaceholderSize, ckbFeeRate, btcTestnetType, }: LeapSporeFromCkbToBtcVirtualTxParams) => Promise<CKBComponents.RawTransaction>;

export { type Address, type AppendIssuerCellToBtcBatchTransfer, type AppendIssuerCellToSporeCreate, type AppendPaymasterCellAndSignTxParams, type AppendWitnessesParams, type BTCTestnetType, BTCTimeLock, type BTCTimeLockArgs, BTCTimeLockConfig, BTCTimeUnlock, BTC_JUMP_CONFIRMATION_BLOCKS, type BaseCkbVirtualTxResult, Block, BlockV1, type BtcBatchTransferVirtualTxParams, type BtcBatchTransferVirtualTxResult, type BtcJumpCkbVirtualTxParams, type BtcJumpCkbVirtualTxResult, type BtcTimeCellStatusParams, type BtcTimeCellsParams, type BtcTransferVirtualTxParams, type BtcTransferVirtualTxResult, type BuildAppendingIssuerCellTxParams, Byte32, Byte32Vec, Bytes, BytesOpt, BytesOptVec, BytesVec, CKB_UNIT, type Capacity, CapacityNotEnoughError, CellDep, CellDepVec, type CellDepsSelected, CellInput, CellInputVec, CellOutput, CellOutputVec, CellbaseWitness, type CkbBatchJumpBtcVirtualTxParams, type CkbJumpBtcVirtualTxParams, type CollectConfig, type CollectResult, type CollectUdtResult, Collector, type ConstructPaymasterParams, type CreateClusterCkbVirtualTxParams, type CreateSporeCkbVirtualTxParams, ExtraCommitmentData, Header, type Hex, type IndexerCapacity, type IndexerCell, IndexerError, InputsCapacityNotEnoughError, InputsOrOutputsLenError, InvalidCellIdError, type LeapSporeFromBtcToCkbVirtualTxParams, type LeapSporeFromCkbToBtcVirtualTxParams, MAX_FEE, MIN_CAPACITY, NoLiveCellError, NoRgbppLiveCellError, NoXudtLiveCellError, OutPoint, ProposalShortId, ProposalShortIdVec, RGBPPConfig, RGBPPLock, RGBPPUnlock, RGBPP_TX_ID_PLACEHOLDER, RGBPP_TX_INPUTS_MAX_LENGTH, RGBPP_TX_WITNESS_MAX_SIZE, RGBPP_WITNESS_PLACEHOLDER, RawHeader, RawTransaction, type RgbppBtcAddressReceiver, RgbppCkbTxInputsExceededError, type RgbppCkbVirtualTx, type RgbppLaunchCkbVirtualTxParams, type RgbppLaunchVirtualTxResult, type RgbppLockArgs, type RgbppLockArgsReceiver, RgbppSporeTypeMismatchError, type RgbppTokenInfo, RgbppUtxoBindMultiTypeAssetsError, SECP256K1_WITNESS_LOCK_SIZE, Script, ScriptOpt, type SendCkbTxParams, type SignBtcTimeCellsTxParams, type SporeCreateVirtualTxResult, type SporeLeapVirtualTxResult, type SporeTransferVirtualTxResult, type SporeVirtualTxResult, type SporesCreateCobuildParams, type SpvClientCellTxProof, Transaction, TransactionVec, type TransferSporeCkbVirtualTxParams, TypeAssetNotSupportedError, type U32, UNLOCKABLE_LOCK_SCRIPT, UdtAmountNotEnoughError, Uint16, Uint256, UncleBlock, UncleBlockVec, type UpdateCkbTxWithRealBtcTxIdParams, WitnessArgs, append0x, appendCkbTxWitnesses, appendIssuerCellToBtcBatchTransfer, appendIssuerCellToSporesCreate, appendPaymasterCellAndSignCkbTx, btcTxIdAndAfterFromBtcTimeLockArgs, buildAppendingIssuerCellToSporesCreateTx, buildBtcTimeCellsSpentTx, buildBtcTimeUnlockWitness, buildPreLockArgs, buildRgbppLockArgs, buildRgbppUnlockWitness, buildSporeBtcTimeCellsSpentTx, buildSpvClientCellDep, calculateCellOccupiedCapacity, calculateCommitment, calculateRgbppCellCapacity, calculateRgbppClusterCellCapacity, calculateRgbppSporeCellCapacity, calculateRgbppTokenInfoCellCapacity, calculateRgbppTokenInfoSize, calculateTransactionFee, calculateUdtCellCapacity, calculateXudtTokenInfoCellCapacity, checkCkbTxInputsCapacitySufficient, compareInputs, decodeCellId, deduplicateList, encodeCellId, encodeRgbppTokenInfo, estimateWitnessSize, fetchTypeIdCellDeps, genBtcBatchTransferCkbVirtualTx, genBtcJumpCkbVirtualTx, genBtcTimeLockArgs, genBtcTimeLockScript, genBtcTransferCkbVirtualTx, genCkbBatchJumpBtcVirtualTx, genCkbJumpBtcVirtualTx, genCreateClusterCkbVirtualTx, genCreateSporeCkbVirtualTx, genLeapSporeFromBtcToCkbVirtualTx, genLeapSporeFromCkbToBtcRawTx, genRgbppLaunchCkbVirtualTx, genRgbppLockScript, genTransferSporeCkbVirtualTx, generateClusterCreateCoBuild, generateClusterId, generateSporeCreateCoBuild, generateSporeId, generateSporeTransferCoBuild, generateUniqueTypeArgs, getBtcTimeLockConfigDep, getBtcTimeLockDep, getBtcTimeLockScript, getClusterTypeDep, getClusterTypeScript, getRgbppLockConfigDep, getRgbppLockDep, getRgbppLockScript, getSecp256k1CellDep, getSporeTypeDep, getSporeTypeScript, getUniqueTypeDep, getUniqueTypeScript, getXudtDep, getXudtTypeScript, hexToUtf8, isBtcTimeCellsSpent, isBtcTimeLockCell, isClusterSporeTypeSupported, isLockArgsSizeExceeded, isRgbppCapacitySufficientForChange, isRgbppLockCell, isRgbppLockCellIgnoreChain, isRgbppLockOrBtcTimeLock, isScriptEqual, isSporeTypeSupported, isTypeAssetSupported, isUDTTypeSupported, leToU128, leToU32, lockScriptFromBtcTimeLockArgs, remove0x, replaceLockArgsWithRealBtcTxId, reverseHex, sendCkbTx, signBtcTimeCellSpentTx, splitMultiCellsWithSecp256k1, throwErrorWhenRgbppCellsInvalid, throwErrorWhenSporeCellsInvalid, throwErrorWhenTxInputsExceeded, toCamelcase, transformSpvProof, u128ToLe, u16ToLe, u32ToBe, u32ToLe, u32ToLeHex, u64ToLe, u8ToHex, unpackRgbppLockArgs, updateCkbTxWithRealBtcTxId, utf8ToHex };
