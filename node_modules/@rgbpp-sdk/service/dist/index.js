"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BtcAssetsApi: () => BtcAssetsApi,
  BtcAssetsApiBase: () => BtcAssetsApiBase,
  BtcAssetsApiError: () => BtcAssetsApiError,
  ErrorCodes: () => ErrorCodes,
  ErrorMessages: () => ErrorMessages,
  isDomain: () => isDomain
});
module.exports = __toCommonJS(src_exports);

// src/error.ts
var ErrorCodes = /* @__PURE__ */ ((ErrorCodes2) => {
  ErrorCodes2[ErrorCodes2["UNKNOWN"] = 0] = "UNKNOWN";
  ErrorCodes2[ErrorCodes2["ASSETS_API_RESPONSE_ERROR"] = 1] = "ASSETS_API_RESPONSE_ERROR";
  ErrorCodes2[ErrorCodes2["ASSETS_API_UNAUTHORIZED"] = 2] = "ASSETS_API_UNAUTHORIZED";
  ErrorCodes2[ErrorCodes2["ASSETS_API_INVALID_PARAM"] = 3] = "ASSETS_API_INVALID_PARAM";
  ErrorCodes2[ErrorCodes2["ASSETS_API_RESOURCE_NOT_FOUND"] = 4] = "ASSETS_API_RESOURCE_NOT_FOUND";
  ErrorCodes2[ErrorCodes2["ASSETS_API_RESPONSE_DECODE_ERROR"] = 5] = "ASSETS_API_RESPONSE_DECODE_ERROR";
  return ErrorCodes2;
})(ErrorCodes || {});
var ErrorMessages = {
  [0 /* UNKNOWN */]: "Unknown error",
  [2 /* ASSETS_API_UNAUTHORIZED */]: "BtcAssetsAPI unauthorized, please check your token/origin",
  [3 /* ASSETS_API_INVALID_PARAM */]: "Invalid param(s) was provided to the BtcAssetsAPI",
  [1 /* ASSETS_API_RESPONSE_ERROR */]: "BtcAssetsAPI returned an error",
  [4 /* ASSETS_API_RESOURCE_NOT_FOUND */]: "Resource not found on the BtcAssetsAPI",
  [5 /* ASSETS_API_RESPONSE_DECODE_ERROR */]: "Failed to decode the response of BtcAssetsAPI"
};
var BtcAssetsApiError = class _BtcAssetsApiError extends Error {
  code = 0 /* UNKNOWN */;
  message;
  context;
  constructor(payload) {
    const message = payload.message ?? ErrorMessages[payload.code] ?? ErrorMessages[0 /* UNKNOWN */];
    super(message);
    this.message = message;
    this.code = payload.code;
    this.context = payload.context;
    Object.setPrototypeOf(this, _BtcAssetsApiError.prototype);
  }
  static withComment(code, comment, context) {
    const prefixMessage = ErrorMessages[code] ?? ErrorMessages[0 /* UNKNOWN */];
    const message = comment ? `${prefixMessage}: ${comment}` : void 0;
    return new _BtcAssetsApiError({ code, message, context });
  }
};

// src/utils.ts
function isDomain(domain, allowLocalhost) {
  if (allowLocalhost && domain === "localhost") {
    return true;
  }
  const regex = /^(?:[-A-Za-z0-9]+\.)+[A-Za-z]{2,}$/;
  return regex.test(domain);
}

// src/service/base.ts
var import_pickBy = __toESM(require("lodash/pickBy.js"));
var BtcAssetsApiBase = class {
  url;
  app;
  domain;
  origin;
  token;
  constructor(props) {
    this.url = props.url;
    this.app = props.app;
    this.domain = props.domain;
    this.origin = props.origin;
    this.token = props.token;
    if (this.domain && !isDomain(this.domain, true)) {
      throw BtcAssetsApiError.withComment(3 /* ASSETS_API_INVALID_PARAM */, "domain");
    }
  }
  async request(route, options) {
    const { requireToken = true, allow404 = false, method = "GET", headers, params, ...otherOptions } = options ?? {};
    if (requireToken && !this.token && !(this.app && this.domain)) {
      throw BtcAssetsApiError.withComment(3 /* ASSETS_API_INVALID_PARAM */, "app, domain");
    }
    if (requireToken && !this.token) {
      await this.init();
    }
    const pickedParams = (0, import_pickBy.default)(params, (val) => val !== void 0);
    const packedParams = params ? "?" + new URLSearchParams(pickedParams).toString() : "";
    const url = `${this.url}${route}${packedParams}`;
    const res = await fetch(url, {
      method,
      headers: {
        authorization: this.token ? `Bearer ${this.token}` : void 0,
        origin: this.origin,
        ...headers
      },
      ...otherOptions
    });
    let text;
    let json;
    let ok = false;
    try {
      text = await res.text();
      json = JSON.parse(text);
      ok = json?.ok ?? res.ok ?? false;
    } catch {
    }
    let comment;
    const status = res.status;
    const context = {
      request: {
        url,
        params,
        body: tryParseBody(otherOptions.body)
      },
      response: {
        status,
        data: json ?? text
      }
    };
    if (!json) {
      comment = text ? `(${status}) ${text}` : `${status}`;
    }
    if (json && !ok) {
      const code = json.code ?? json.statusCode ?? json.error?.error?.code ?? res.status;
      const message = json.message ?? (typeof json.error === "string" ? json.error : json.error?.error?.message);
      if (message) {
        comment = code ? `(${code}) ${message}` : message;
      } else {
        comment = JSON.stringify(json);
      }
    }
    if (status === 200 && !json) {
      throw BtcAssetsApiError.withComment(5 /* ASSETS_API_RESPONSE_DECODE_ERROR */, comment, context);
    }
    if (status === 401) {
      throw BtcAssetsApiError.withComment(2 /* ASSETS_API_UNAUTHORIZED */, comment, context);
    }
    if (status === 404 && !allow404) {
      throw BtcAssetsApiError.withComment(4 /* ASSETS_API_RESOURCE_NOT_FOUND */, comment, context);
    }
    if (status !== 200 && status !== 404 && !allow404) {
      throw BtcAssetsApiError.withComment(1 /* ASSETS_API_RESPONSE_ERROR */, comment, context);
    }
    if (status === 404 && allow404) {
      return void 0;
    }
    return json;
  }
  async post(route, options) {
    return this.request(route, {
      method: "POST",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  async generateToken() {
    if (!this.app || !this.domain) {
      throw BtcAssetsApiError.withComment(3 /* ASSETS_API_INVALID_PARAM */, "app, domain");
    }
    return this.post("/token/generate", {
      requireToken: false,
      body: JSON.stringify({
        app: this.app,
        domain: this.domain
      })
    });
  }
  async init(force) {
    if (this.token && !force) {
      return;
    }
    const token = await this.generateToken();
    this.token = token.token;
  }
};
function tryParseBody(body) {
  try {
    return typeof body === "string" ? JSON.parse(body) : void 0;
  } catch {
    return void 0;
  }
}

// src/service/service.ts
var BtcAssetsApi = class _BtcAssetsApi extends BtcAssetsApiBase {
  /**
   * Base
   */
  static fromToken(url, token, origin) {
    return new _BtcAssetsApi({ url, token, origin });
  }
  /**
   * Bitcoin APIs, under the /bitcoin/v1 prefix.
   */
  getBtcBlockchainInfo() {
    return this.request("/bitcoin/v1/info");
  }
  getBtcBlockByHash(blockHash) {
    return this.request(`/bitcoin/v1/block/${blockHash}`);
  }
  getBtcBlockHeaderByHash(blockHash) {
    return this.request(`/bitcoin/v1/block/${blockHash}/header`);
  }
  getBtcBlockHashByHeight(height) {
    return this.request(`/bitcoin/v1/block/height/${height}`);
  }
  getBtcBlockTransactionIdsByHash(blockHash) {
    return this.request(`/bitcoin/v1/block/${blockHash}/txids`);
  }
  getBtcRecommendedFeeRates() {
    return this.request(`/bitcoin/v1/fees/recommended`);
  }
  getBtcBalance(address, params) {
    return this.request(`/bitcoin/v1/address/${address}/balance`, {
      params
    });
  }
  getBtcUtxos(address, params) {
    return this.request(`/bitcoin/v1/address/${address}/unspent`, {
      params
    });
  }
  getBtcTransactions(address, params) {
    return this.request(`/bitcoin/v1/address/${address}/txs`, {
      params
    });
  }
  getBtcTransaction(txId) {
    return this.request(`/bitcoin/v1/transaction/${txId}`);
  }
  sendBtcTransaction(txHex) {
    return this.post("/bitcoin/v1/transaction", {
      body: JSON.stringify({
        txhex: txHex
      })
    });
  }
  /**
   * RGBPP APIs, under the /rgbpp/v1 prefix.
   */
  getRgbppPaymasterInfo() {
    return this.request("/rgbpp/v1/paymaster/info");
  }
  getRgbppTransactionHash(btcTxId) {
    return this.request(`/rgbpp/v1/transaction/${btcTxId}`);
  }
  getRgbppTransactionState(btcTxId, params) {
    return this.request(`/rgbpp/v1/transaction/${btcTxId}/job`, {
      params
    });
  }
  getRgbppAssetsByBtcTxId(btcTxId) {
    return this.request(`/rgbpp/v1/assets/${btcTxId}`);
  }
  getRgbppAssetsByBtcUtxo(btcTxId, vout) {
    return this.request(`/rgbpp/v1/assets/${btcTxId}/${vout}`);
  }
  getRgbppAssetsByBtcAddress(btcAddress, params) {
    return this.request(`/rgbpp/v1/address/${btcAddress}/assets`, {
      params
    });
  }
  getRgbppBalanceByBtcAddress(btcAddress, params) {
    return this.request(`/rgbpp/v1/address/${btcAddress}/balance`, {
      params
    });
  }
  getRgbppSpvProof(btcTxId, confirmations) {
    return this.request("/rgbpp/v1/btc-spv/proof", {
      params: {
        btc_txid: btcTxId,
        confirmations
      }
    });
  }
  sendRgbppCkbTransaction(payload) {
    return this.post("/rgbpp/v1/transaction/ckb-tx", {
      body: JSON.stringify(payload)
    });
  }
  retryRgbppCkbTransaction(payload) {
    return this.post("/rgbpp/v1/transaction/retry", {
      body: JSON.stringify(payload)
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BtcAssetsApi,
  BtcAssetsApiBase,
  BtcAssetsApiError,
  ErrorCodes,
  ErrorMessages,
  isDomain
});
//# sourceMappingURL=index.js.map