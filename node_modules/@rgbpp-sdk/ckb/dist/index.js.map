{"version":3,"sources":["../src/index.ts","../src/schemas/generated/blockchain.ts","../src/schemas/customized.ts","../src/schemas/generated/rgbpp.ts","../src/collector/index.ts","../src/constants/index.ts","../src/error/index.ts","../src/utils/case-parser.ts","../src/utils/hex.ts","../src/utils/ckb-tx.ts","../src/utils/rgbpp.ts","../src/utils/spore.ts","../src/utils/cell-dep.ts","../src/utils/id.ts","../src/paymaster/index.ts","../src/rgbpp/btc-transfer.ts","../src/rgbpp/ckb-builder.ts","../src/rgbpp/btc-jump-ckb.ts","../src/rgbpp/btc-time.ts","../src/rgbpp/ckb-jump-btc.ts","../src/rgbpp/launch.ts","../src/spore/cluster.ts","../src/spore/spore.ts","../src/spore/leap.ts"],"sourcesContent":["export * from './schemas/generated/blockchain';\nexport * from './schemas/generated/rgbpp';\nexport * from './collector';\nexport * from './error';\nexport * from './paymaster';\nexport * from './types';\nexport * from './rgbpp';\nexport * from './utils';\nexport * from './constants';\nexport * from './spore';\n","// This file is generated by @ckb-lumos/molecule, please do not modify it manually.\n/* eslint-disable */\nimport { bytes, createBytesCodec, createFixedBytesCodec, molecule } from '@ckb-lumos/codec';\nimport { Uint32, Uint64, Uint128, DepType, HashType } from '../customized';\n\nconst { array, vector, union, option, struct, table, byteVecOf } = molecule;\n\nconst fallbackBytesCodec = byteVecOf({ pack: bytes.bytify, unpack: bytes.hexify });\n\nfunction createFallbackFixedBytesCodec(byteLength: number) {\n  return createFixedBytesCodec({\n    pack: bytes.bytify,\n    unpack: bytes.hexify,\n    byteLength,\n  });\n}\n\nconst byte = createFallbackFixedBytesCodec(1);\n\nexport const Byte32 = createFallbackFixedBytesCodec(32);\n\nexport const Uint256 = createFallbackFixedBytesCodec(32);\n\nexport const Bytes = fallbackBytesCodec;\n\nexport const BytesOpt = option(Bytes);\n\nexport const BytesOptVec = vector(BytesOpt);\n\nexport const BytesVec = vector(Bytes);\n\nexport const Byte32Vec = vector(Byte32);\n\nexport const ProposalShortId = createFallbackFixedBytesCodec(10);\n\nexport const ProposalShortIdVec = vector(ProposalShortId);\n\nexport const Script = table(\n  {\n    codeHash: Byte32,\n    hashType: byte,\n    args: Bytes,\n  },\n  ['codeHash', 'hashType', 'args'],\n);\n\nexport const OutPoint = struct(\n  {\n    txHash: Byte32,\n    index: Uint32,\n  },\n  ['txHash', 'index'],\n);\n\nexport const CellInput = struct(\n  {\n    since: Uint64,\n    previousOutput: OutPoint,\n  },\n  ['since', 'previousOutput'],\n);\n\nexport const CellDep = struct(\n  {\n    outPoint: OutPoint,\n    depType: byte,\n  },\n  ['outPoint', 'depType'],\n);\n\nexport const RawHeader = struct(\n  {\n    version: Uint32,\n    compactTarget: Uint32,\n    timestamp: Uint64,\n    number: Uint64,\n    epoch: Uint64,\n    parentHash: Byte32,\n    transactionsRoot: Byte32,\n    proposalsHash: Byte32,\n    extraHash: Byte32,\n    dao: Byte32,\n  },\n  [\n    'version',\n    'compactTarget',\n    'timestamp',\n    'number',\n    'epoch',\n    'parentHash',\n    'transactionsRoot',\n    'proposalsHash',\n    'extraHash',\n    'dao',\n  ],\n);\n\nexport const Header = struct(\n  {\n    raw: RawHeader,\n    nonce: Uint128,\n  },\n  ['raw', 'nonce'],\n);\n\nexport const UncleBlock = table(\n  {\n    header: Header,\n    proposals: ProposalShortIdVec,\n  },\n  ['header', 'proposals'],\n);\n\nexport const CellbaseWitness = table(\n  {\n    lock: Script,\n    message: Bytes,\n  },\n  ['lock', 'message'],\n);\n\nexport const WitnessArgs = table(\n  {\n    lock: BytesOpt,\n    inputType: BytesOpt,\n    outputType: BytesOpt,\n  },\n  ['lock', 'inputType', 'outputType'],\n);\n\nexport const ScriptOpt = option(Script);\n\nexport const UncleBlockVec = vector(UncleBlock);\n\nexport const CellDepVec = vector(CellDep);\n\nexport const CellInputVec = vector(CellInput);\n\nexport const CellOutput = table(\n  {\n    capacity: Uint64,\n    lock: Script,\n    type_: ScriptOpt,\n  },\n  ['capacity', 'lock', 'type_'],\n);\n\nexport const CellOutputVec = vector(CellOutput);\n\nexport const RawTransaction = table(\n  {\n    version: Uint32,\n    cellDeps: CellDepVec,\n    headerDeps: Byte32Vec,\n    inputs: CellInputVec,\n    outputs: CellOutputVec,\n    outputsData: BytesVec,\n  },\n  ['version', 'cellDeps', 'headerDeps', 'inputs', 'outputs', 'outputsData'],\n);\n\nexport const Transaction = table(\n  {\n    raw: RawTransaction,\n    witnesses: BytesVec,\n  },\n  ['raw', 'witnesses'],\n);\n\nexport const TransactionVec = vector(Transaction);\n\nexport const Block = table(\n  {\n    header: Header,\n    uncles: UncleBlockVec,\n    transactions: TransactionVec,\n    proposals: ProposalShortIdVec,\n  },\n  ['header', 'uncles', 'transactions', 'proposals'],\n);\n\nexport const BlockV1 = table(\n  {\n    header: Header,\n    uncles: UncleBlockVec,\n    transactions: TransactionVec,\n    proposals: ProposalShortIdVec,\n    extension: Bytes,\n  },\n  ['header', 'uncles', 'transactions', 'proposals', 'extension'],\n);\n","import { createFixedBytesCodec, number } from '@ckb-lumos/codec';\n\nconst { Uint32, Uint64, Uint128 } = number;\n\n/**\n * <pre>\n *  0b0000000 0\n *    ───┬─── │\n *       │    ▼\n *       │   type - the last bit indicates locating contract(script) via type hash and runs in the latest version of the CKB-VM\n *       │\n *       ▼\n * data* - the first 7 bits indicate locating contract(script) via code hash and runs in the specified version of the CKB-VM\n * </pre>\n *\n */\nconst HashType = createFixedBytesCodec<'data' | 'type' | 'data1' | 'data2'>({\n  byteLength: 1,\n  // prettier-ignore\n  pack: (hashType) => {\n    if (hashType === \"type\")  return new Uint8Array([0b0000000_1]);\n    if (hashType === \"data\")  return new Uint8Array([0b0000000_0]);\n    if (hashType === \"data1\") return new Uint8Array([0b0000001_0]);\n    if (hashType === \"data2\") return new Uint8Array([0b0000010_0]);\n\n    throw new Error('Unknown hash type')\n  },\n  unpack: (byte) => {\n    if (byte[0] === 0b0000000_1) return 'type';\n    if (byte[0] === 0b0000000_0) return 'data';\n    if (byte[0] === 0b0000001_0) return 'data1';\n    if (byte[0] === 0b0000010_0) return 'data2';\n\n    throw new Error('Unknown hash type');\n  },\n});\n\nconst DepType = createFixedBytesCodec<'code' | 'depGroup'>({\n  byteLength: 1,\n  // prettier-ignore\n  pack: (depType) => {\n    if (depType === \"code\")     return new Uint8Array([0]);\n    if (depType === \"depGroup\") return new Uint8Array([1]);\n\n    throw new Error(\"Unknown dep type\");\n  },\n  unpack: (byte) => {\n    if (byte[0] === 0) return 'code';\n    if (byte[0] === 1) return 'depGroup';\n\n    throw new Error('Unknown dep type');\n  },\n});\n\nexport { Uint32, Uint64, Uint128, DepType, HashType };\n","// This file is generated by @ckb-lumos/molecule, please do not modify it manually.\n/* eslint-disable */\nimport { bytes, createBytesCodec, createFixedBytesCodec, molecule } from '@ckb-lumos/codec';\nimport { Uint32, Uint64, Uint128, DepType, HashType } from '../customized';\nimport {\n  Byte32,\n  Uint256,\n  Bytes,\n  BytesOpt,\n  BytesOptVec,\n  BytesVec,\n  Byte32Vec,\n  ProposalShortId,\n  ProposalShortIdVec,\n  Script,\n  OutPoint,\n  CellInput,\n  CellDep,\n  RawHeader,\n  Header,\n  UncleBlock,\n  CellbaseWitness,\n  WitnessArgs,\n  ScriptOpt,\n  UncleBlockVec,\n  CellDepVec,\n  CellInputVec,\n  CellOutput,\n  CellOutputVec,\n  RawTransaction,\n  Transaction,\n  TransactionVec,\n  Block,\n  BlockV1,\n} from './blockchain';\n\nconst { array, vector, union, option, struct, table, byteVecOf } = molecule;\n\nconst fallbackBytesCodec = byteVecOf({ pack: bytes.bytify, unpack: bytes.hexify });\n\nfunction createFallbackFixedBytesCodec(byteLength: number) {\n  return createFixedBytesCodec({\n    pack: bytes.bytify,\n    unpack: bytes.hexify,\n    byteLength,\n  });\n}\n\nconst byte = createFallbackFixedBytesCodec(1);\n\nexport const RGBPPConfig = struct(\n  {\n    btcLcTypeHash: Byte32,\n    btcTimeLockTypeHash: Byte32,\n  },\n  ['btcLcTypeHash', 'btcTimeLockTypeHash'],\n);\n\nexport const RGBPPLock = struct(\n  {\n    outIndex: Uint32,\n    btcTxid: Byte32,\n  },\n  ['outIndex', 'btcTxid'],\n);\n\nexport const ExtraCommitmentData = struct(\n  {\n    inputLen: byte,\n    outputLen: byte,\n  },\n  ['inputLen', 'outputLen'],\n);\n\nexport const Uint16 = createFallbackFixedBytesCodec(2);\n\nexport const RGBPPUnlock = table(\n  {\n    version: Uint16,\n    extraData: ExtraCommitmentData,\n    btcTx: Bytes,\n    btcTxProof: Bytes,\n  },\n  ['version', 'extraData', 'btcTx', 'btcTxProof'],\n);\n\nexport const BTCTimeLock = table(\n  {\n    lockScript: Script,\n    after: Uint32,\n    btcTxid: Byte32,\n  },\n  ['lockScript', 'after', 'btcTxid'],\n);\n\nexport const BTCTimeLockConfig = struct(\n  {\n    btcLcTypeHash: Byte32,\n  },\n  ['btcLcTypeHash'],\n);\n\nexport const BTCTimeUnlock = table(\n  {\n    btcTxProof: Bytes,\n  },\n  ['btcTxProof'],\n);\n","import axios from 'axios';\nimport CKB from '@nervosnetwork/ckb-sdk-core';\nimport { CollectConfig, CollectResult, CollectUdtResult, IndexerCell } from '../types/collector';\nimport { MIN_CAPACITY } from '../constants';\nimport { CapacityNotEnoughError, IndexerError, UdtAmountNotEnoughError } from '../error';\nimport { isRgbppLockCellIgnoreChain, leToU128, remove0x, toCamelcase } from '../utils';\nimport { Hex } from '../types';\n\ninterface IndexerScript {\n  code_hash: Hex;\n  hash_type: Hex;\n  args: Hex;\n}\n\ninterface IndexerSearchKey {\n  script?: IndexerScript;\n  script_type?: 'lock' | 'type';\n  script_search_mode?: 'prefix' | 'exact';\n  filter?: {\n    script?: IndexerScript;\n    script_len_range?: Hex[];\n    output_data_len_range?: Hex[];\n    output_capacity_range?: Hex[];\n    block_range?: Hex[];\n  };\n  with_data?: boolean;\n}\n\nconst parseScript = (script: CKBComponents.Script): IndexerScript => ({\n  code_hash: script.codeHash,\n  hash_type: script.hashType,\n  args: script.args,\n});\n\nexport class Collector {\n  private ckbNodeUrl: string;\n  private ckbIndexerUrl: string;\n\n  constructor({ ckbNodeUrl, ckbIndexerUrl }: { ckbNodeUrl: string; ckbIndexerUrl: string }) {\n    this.ckbNodeUrl = ckbNodeUrl;\n    this.ckbIndexerUrl = ckbIndexerUrl;\n  }\n\n  getCkb() {\n    return new CKB(this.ckbNodeUrl);\n  }\n\n  async getCells({\n    lock,\n    type,\n    isDataMustBeEmpty = true,\n    outputCapacityRange,\n  }: {\n    lock?: CKBComponents.Script;\n    type?: CKBComponents.Script;\n    isDataMustBeEmpty?: boolean;\n    outputCapacityRange?: Hex[];\n  }): Promise<IndexerCell[]> {\n    let searchKey: IndexerSearchKey = {};\n    if (lock) {\n      searchKey = {\n        script_search_mode: 'exact',\n        script: parseScript(lock),\n        script_type: 'lock',\n        filter: {\n          script: type ? parseScript(type) : undefined,\n          output_data_len_range: isDataMustBeEmpty && !type ? ['0x0', '0x1'] : undefined,\n          output_capacity_range: outputCapacityRange,\n        },\n      };\n    } else if (type) {\n      searchKey = {\n        script_search_mode: 'exact',\n        script: parseScript(type),\n        script_type: 'type',\n      };\n    }\n    const payload = {\n      id: Math.floor(Math.random() * 100000),\n      jsonrpc: '2.0',\n      method: 'get_cells',\n      params: [searchKey, 'asc', '0x3E8'],\n    };\n    const body = JSON.stringify(payload, null, '  ');\n    const response = (\n      await axios({\n        method: 'post',\n        url: this.ckbIndexerUrl,\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        timeout: 20000,\n        data: body,\n      })\n    ).data;\n    if (response.error) {\n      console.error(response.error);\n      throw new IndexerError('Get cells from indexer error');\n    } else {\n      const res = toCamelcase<IndexerCell[]>(response.result.objects);\n      if (res === null) {\n        throw new IndexerError('The response of indexer RPC get_cells is invalid');\n      }\n      return res;\n    }\n  }\n\n  collectInputs(liveCells: IndexerCell[], needCapacity: bigint, fee: bigint, config?: CollectConfig): CollectResult {\n    const changeCapacity = config?.minCapacity ?? MIN_CAPACITY;\n    const inputs: CKBComponents.CellInput[] = [];\n    let sumInputsCapacity = BigInt(0);\n    const isRgbppLock = liveCells.length > 0 && isRgbppLockCellIgnoreChain(liveCells[0].output);\n    for (const cell of liveCells) {\n      inputs.push({\n        previousOutput: {\n          txHash: cell.outPoint.txHash,\n          index: cell.outPoint.index,\n        },\n        since: '0x0',\n      });\n      sumInputsCapacity += BigInt(cell.output.capacity);\n      if (sumInputsCapacity >= needCapacity + changeCapacity + fee && !isRgbppLock) {\n        break;\n      }\n    }\n    if (sumInputsCapacity < needCapacity + changeCapacity + fee) {\n      const message = config?.errMsg ?? 'Insufficient free CKB balance';\n      throw new CapacityNotEnoughError(message);\n    }\n    return { inputs, sumInputsCapacity };\n  }\n\n  collectUdtInputs({ liveCells, needAmount }: { liveCells: IndexerCell[]; needAmount: bigint }): CollectUdtResult {\n    const inputs: CKBComponents.CellInput[] = [];\n    let sumInputsCapacity = BigInt(0);\n    let sumAmount = BigInt(0);\n    const isRgbppLock = liveCells.length > 0 && isRgbppLockCellIgnoreChain(liveCells[0].output);\n    for (const cell of liveCells) {\n      if (cell.outputData === '0x') {\n        continue;\n      }\n      inputs.push({\n        previousOutput: {\n          txHash: cell.outPoint.txHash,\n          index: cell.outPoint.index,\n        },\n        since: '0x0',\n      });\n      sumInputsCapacity = sumInputsCapacity + BigInt(cell.output.capacity);\n      // XUDT cell.data = <amount: uint128> <xudt data (optional)>\n      // Ref: https://blog.cryptape.com/enhance-sudts-programmability-with-xudt#heading-xudt-cell\n      sumAmount += leToU128(remove0x(cell.outputData).slice(0, 32));\n      if (sumAmount >= needAmount && !isRgbppLock) {\n        break;\n      }\n    }\n    if (sumAmount < needAmount) {\n      throw new UdtAmountNotEnoughError('Insufficient UDT balance');\n    }\n    return { inputs, sumInputsCapacity, sumAmount };\n  }\n\n  async getLiveCell(outPoint: CKBComponents.OutPoint, withData = true): Promise<CKBComponents.LiveCell> {\n    const ckb = new CKB(this.ckbNodeUrl);\n    const { cell } = await ckb.rpc.getLiveCell(outPoint, withData);\n    return cell;\n  }\n\n  async getLiveCells(outPoints: CKBComponents.OutPoint[], withData = false): Promise<CKBComponents.LiveCell[]> {\n    const ckb = new CKB(this.ckbNodeUrl);\n    const batch = ckb.rpc.createBatchRequest(outPoints.map((outPoint) => ['getLiveCell', outPoint, withData]));\n    return batch.exec().then((liveCells) => liveCells.map((liveCell) => liveCell.cell));\n  }\n}\n","import { BTCTestnetType } from '../types';\n\nexport const CKB_UNIT = BigInt(10000_0000);\nexport const MAX_FEE = BigInt(2000_0000);\nexport const MIN_CAPACITY = BigInt(61) * BigInt(10000_0000);\nexport const SECP256K1_WITNESS_LOCK_SIZE = 65;\nexport const BTC_JUMP_CONFIRMATION_BLOCKS = 6;\nexport const RGBPP_TX_WITNESS_MAX_SIZE = 5000;\nexport const RGBPP_TX_INPUTS_MAX_LENGTH = 40;\n\nexport const RGBPP_WITNESS_PLACEHOLDER = '0xFF';\nexport const RGBPP_TX_ID_PLACEHOLDER = '0000000000000000000000000000000000000000000000000000000000000000';\n\nconst TestnetInfo = {\n  Secp256k1LockDep: {\n    outPoint: {\n      txHash: '0xf8de3bb47d055cdf460d93a2a6e1b05f7432f9777c8c474abf4eec1d4aee5d37',\n      index: '0x0',\n    },\n    depType: 'depGroup',\n  } as CKBComponents.CellDep,\n\n  RgbppLockScript: {\n    codeHash: '0x61ca7a4796a4eb19ca4f0d065cb9b10ddcf002f10f7cbb810c706cb6bb5c3248',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  RgbppLockDep: {\n    outPoint: { txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00', index: '0x0' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  RgbppLockConfigDep: {\n    outPoint: { txHash: '0xf1de59e973b85791ec32debbba08dff80c63197e895eb95d67fc1e9f6b413e00', index: '0x1' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  BtcTimeLockScript: {\n    codeHash: '0x00cdf8fab0f8ac638758ebf5ea5e4052b1d71e8a77b9f43139718621f6849326',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  BtcTimeLockDep: {\n    outPoint: { txHash: '0xde0f87878a97500f549418e5d46d2f7704c565a262aa17036c9c1c13ad638529', index: '0x0' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  BtcTimeLockConfigDep: {\n    outPoint: { txHash: '0xde0f87878a97500f549418e5d46d2f7704c565a262aa17036c9c1c13ad638529', index: '0x1' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  XUDTTypeScript: {\n    codeHash: '0x25c29dc317811a6f6f3985a7a9ebc4838bd388d19d0feeecf0bcd60f6c0975bb',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  XUDTTypeDep: {\n    outPoint: {\n      txHash: '0xbf6fb538763efec2a70a6a3dcb7242787087e1030c4e7d86585bc63a9d337f5f',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  UniqueTypeScript: {\n    codeHash: '0x8e341bcfec6393dcd41e635733ff2dca00a6af546949f70c57a706c0f344df8b',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  UniqueTypeDep: {\n    outPoint: {\n      txHash: '0xff91b063c78ed06f10a1ed436122bd7d671f9a72ef5f5fa28d05252c17cf4cef',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  ClusterTypeScript: {\n    codeHash: '0x0bbe768b519d8ea7b96d58f1182eb7e6ef96c541fbd9526975077ee09f049058',\n    hashType: 'data1',\n    args: '',\n  } as CKBComponents.Script,\n\n  ClusterTypeDep: {\n    outPoint: {\n      txHash: '0xcebb174d6e300e26074aea2f5dbd7f694bb4fe3de52b6dfe205e54f90164510a',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  SporeTypeScript: {\n    codeHash: '0x685a60219309029d01310311dba953d67029170ca4848a4ff638e57002130a0d',\n    hashType: 'data1',\n    args: '',\n  } as CKBComponents.Script,\n\n  SporeTypeDep: {\n    outPoint: {\n      txHash: '0x5e8d2a517d50fd4bb4d01737a7952a1f1d35c8afc77240695bb569cd7d9d5a1f',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  // The CKB testnet RGB++ deployment information for the BTC Signet network\n  RgbppSignetLockScript: {\n    codeHash: '0xd07598deec7ce7b5665310386b4abd06a6d48843e953c5cc2112ad0d5a220364',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  RgbppSignetLockDep: {\n    outPoint: { txHash: '0x61efdeddbaa0bb4132c0eb174b3e8002ff5ec430f61ba46f30768d683c516eec', index: '0x0' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  RgbppSignetLockConfigDep: {\n    outPoint: { txHash: '0x61efdeddbaa0bb4132c0eb174b3e8002ff5ec430f61ba46f30768d683c516eec', index: '0x1' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  BtcTimeSignetLockScript: {\n    codeHash: '0x80a09eca26d77cea1f5a69471c59481be7404febf40ee90f886c36a948385b55',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  BtcTimeSignetLockDep: {\n    outPoint: { txHash: '0x5364b3535965e9eac9a35dd7af8e9e45a61d30a16e115923c032f80b28783e21', index: '0x0' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  BtcTimeSignetLockConfigDep: {\n    outPoint: { txHash: '0x5364b3535965e9eac9a35dd7af8e9e45a61d30a16e115923c032f80b28783e21', index: '0x1' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n};\n\nconst MainnetInfo = {\n  Secp256k1LockDep: {\n    outPoint: {\n      txHash: '0x71a7ba8fc96349fea0ed3a5c47992e3b4084b031a42264a018e0072e8172e46c',\n      index: '0x0',\n    },\n    depType: 'depGroup',\n  } as CKBComponents.CellDep,\n\n  RgbppLockScript: {\n    codeHash: '0xbc6c568a1a0d0a09f6844dc9d74ddb4343c32143ff25f727c59edf4fb72d6936',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  RgbppLockDep: {\n    outPoint: { txHash: '0x04c5c3e69f1aa6ee27fb9de3d15a81704e387ab3b453965adbe0b6ca343c6f41', index: '0x0' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  RgbppLockConfigDep: {\n    outPoint: { txHash: '0x04c5c3e69f1aa6ee27fb9de3d15a81704e387ab3b453965adbe0b6ca343c6f41', index: '0x1' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  BtcTimeLockScript: {\n    codeHash: '0x70d64497a075bd651e98ac030455ea200637ee325a12ad08aff03f1a117e5a62',\n    hashType: 'type',\n    args: '',\n  } as CKBComponents.Script,\n\n  BtcTimeLockDep: {\n    outPoint: { txHash: '0x6257bf4297ee75fcebe2654d8c5f8d93bc9fc1b3dc62b8cef54ffe166162e996', index: '0x0' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  BtcTimeLockConfigDep: {\n    outPoint: { txHash: '0x6257bf4297ee75fcebe2654d8c5f8d93bc9fc1b3dc62b8cef54ffe166162e996', index: '0x1' },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  XUDTTypeScript: {\n    codeHash: '0x50bd8d6680b8b9cf98b73f3c08faf8b2a21914311954118ad6609be6e78a1b95',\n    hashType: 'data1',\n    args: '',\n  } as CKBComponents.Script,\n\n  XUDTTypeDep: {\n    outPoint: {\n      txHash: '0xc07844ce21b38e4b071dd0e1ee3b0e27afd8d7532491327f39b786343f558ab7',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  UniqueTypeScript: {\n    codeHash: '0x2c8c11c985da60b0a330c61a85507416d6382c130ba67f0c47ab071e00aec628',\n    hashType: 'data1',\n    args: '',\n  } as CKBComponents.Script,\n\n  UniqueTypeDep: {\n    outPoint: {\n      txHash: '0x67524c01c0cb5492e499c7c7e406f2f9d823e162d6b0cf432eacde0c9808c2ad',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  ClusterTypeScript: {\n    codeHash: '0x7366a61534fa7c7e6225ecc0d828ea3b5366adec2b58206f2ee84995fe030075',\n    hashType: 'data1',\n    args: '',\n  } as CKBComponents.Script,\n\n  ClusterTypeDep: {\n    outPoint: {\n      txHash: '0xe464b7fb9311c5e2820e61c99afc615d6b98bdefbe318c34868c010cbd0dc938',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n\n  SporeTypeScript: {\n    codeHash: '0x4a4dce1df3dffff7f8b2cd7dff7303df3b6150c9788cb75dcf6747247132b9f5',\n    hashType: 'data1',\n    args: '',\n  } as CKBComponents.Script,\n\n  SporeTypeDep: {\n    outPoint: {\n      txHash: '0x96b198fb5ddbd1eed57ed667068f1f1e55d07907b4c0dbd38675a69ea1b69824',\n      index: '0x0',\n    },\n    depType: 'code',\n  } as CKBComponents.CellDep,\n};\n\nexport const UNLOCKABLE_LOCK_SCRIPT = {\n  codeHash: '0x0000000000000000000000000000000000000000000000000000000000000000',\n  hashType: 'data',\n  args: '0x',\n} as CKBComponents.Script;\n\nexport const getSecp256k1CellDep = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.Secp256k1LockDep : TestnetInfo.Secp256k1LockDep;\n\nexport const getXudtTypeScript = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.XUDTTypeScript : TestnetInfo.XUDTTypeScript;\nexport const getXudtDep = (isMainnet: boolean) => (isMainnet ? MainnetInfo.XUDTTypeDep : TestnetInfo.XUDTTypeDep);\n\nexport const getRgbppLockScript = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  if (isMainnet) {\n    return MainnetInfo.RgbppLockScript;\n  }\n  return btcTestnetType === 'Signet' ? TestnetInfo.RgbppSignetLockScript : TestnetInfo.RgbppLockScript;\n};\n\nexport const getRgbppLockDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  if (isMainnet) {\n    return MainnetInfo.RgbppLockDep;\n  }\n  return btcTestnetType === 'Signet' ? TestnetInfo.RgbppSignetLockDep : TestnetInfo.RgbppLockDep;\n};\n\nexport const getRgbppLockConfigDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  if (isMainnet) {\n    return MainnetInfo.RgbppLockConfigDep;\n  }\n  return btcTestnetType === 'Signet' ? TestnetInfo.RgbppSignetLockConfigDep : TestnetInfo.RgbppLockConfigDep;\n};\n\nexport const getBtcTimeLockScript = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  if (isMainnet) {\n    return MainnetInfo.BtcTimeLockScript;\n  }\n  return btcTestnetType === 'Signet' ? TestnetInfo.BtcTimeSignetLockScript : TestnetInfo.BtcTimeLockScript;\n};\nexport const getBtcTimeLockDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  if (isMainnet) {\n    return MainnetInfo.BtcTimeLockDep;\n  }\n  return btcTestnetType === 'Signet' ? TestnetInfo.BtcTimeSignetLockDep : TestnetInfo.BtcTimeLockDep;\n};\n\nexport const getBtcTimeLockConfigDep = (isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  if (isMainnet) {\n    return MainnetInfo.BtcTimeLockConfigDep;\n  }\n  return btcTestnetType === 'Signet' ? TestnetInfo.BtcTimeSignetLockConfigDep : TestnetInfo.BtcTimeLockConfigDep;\n};\n\nexport const getUniqueTypeScript = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.UniqueTypeScript : TestnetInfo.UniqueTypeScript;\nexport const getUniqueTypeDep = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.UniqueTypeDep : TestnetInfo.UniqueTypeDep;\n\nexport const getClusterTypeScript = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.ClusterTypeScript : TestnetInfo.ClusterTypeScript;\nexport const getClusterTypeDep = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.ClusterTypeDep : TestnetInfo.ClusterTypeDep;\n\nexport const getSporeTypeScript = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.SporeTypeScript : TestnetInfo.SporeTypeScript;\nexport const getSporeTypeDep = (isMainnet: boolean) =>\n  isMainnet ? MainnetInfo.SporeTypeDep : TestnetInfo.SporeTypeDep;\n","enum ErrorCode {\n  CapacityNotEnough = 100,\n  IndexerRpcError = 101,\n  NoLiveCell = 102,\n  NoXudtLiveCell = 103,\n  NoRgbppLiveCell = 104,\n  UdtAmountNotEnough = 105,\n  InputsCapacityNotEnough = 106,\n  TypeAssetNotSupported = 107,\n  InputsOrOutputsLenInvalid = 108,\n  RgbppCkbTxInputsExceeded = 109,\n  RgbppUtxoBindMultiTypeAssets = 110,\n  RgbppSporeTypeMismatch = 111,\n  InvalidCellId = 112,\n}\n\nexport class CapacityNotEnoughError extends Error {\n  code = ErrorCode.CapacityNotEnough;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class IndexerError extends Error {\n  code = ErrorCode.IndexerRpcError;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class NoLiveCellError extends Error {\n  code = ErrorCode.NoLiveCell;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class NoXudtLiveCellError extends Error {\n  code = ErrorCode.NoXudtLiveCell;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class NoRgbppLiveCellError extends Error {\n  code = ErrorCode.NoRgbppLiveCell;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class UdtAmountNotEnoughError extends Error {\n  code = ErrorCode.UdtAmountNotEnough;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class InputsCapacityNotEnoughError extends Error {\n  code = ErrorCode.InputsCapacityNotEnough;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class TypeAssetNotSupportedError extends Error {\n  code = ErrorCode.TypeAssetNotSupported;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class InputsOrOutputsLenError extends Error {\n  code = ErrorCode.InputsOrOutputsLenInvalid;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class RgbppCkbTxInputsExceededError extends Error {\n  code = ErrorCode.RgbppCkbTxInputsExceeded;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class RgbppUtxoBindMultiTypeAssetsError extends Error {\n  code = ErrorCode.RgbppUtxoBindMultiTypeAssets;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class RgbppSporeTypeMismatchError extends Error {\n  code = ErrorCode.RgbppSporeTypeMismatch;\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport class InvalidCellIdError extends Error {\n  code = ErrorCode.InvalidCellId;\n  constructor(message: string) {\n    super(message);\n  }\n}\n","import camelcaseKeys from 'camelcase-keys';\n\nexport const toCamelcase = <T>(obj: object): T | null => {\n  try {\n    return camelcaseKeys(obj, {\n      deep: true,\n    }) as T;\n  } catch (error) {\n    console.error(error);\n  }\n  return null;\n};\n","import { hexToBytes, bytesToHex } from '@nervosnetwork/ckb-sdk-utils';\nimport { Hex } from '../types';\n\nexport const remove0x = (hex: string): string => {\n  if (hex.startsWith('0x')) {\n    return hex.substring(2);\n  }\n  return hex;\n};\n\nexport const append0x = (hex?: string): string => {\n  return hex?.startsWith('0x') ? hex : `0x${hex}`;\n};\n\nconst ArrayBufferToHex = (arrayBuffer: ArrayBuffer): string => {\n  return Array.prototype.map.call(new Uint8Array(arrayBuffer), (x) => ('00' + x.toString(16)).slice(-2)).join('');\n};\n\nexport const u8ToHex = (u8: number): string => {\n  const buffer = new ArrayBuffer(1);\n  const view = new DataView(buffer);\n  view.setUint8(0, u8);\n  return ArrayBufferToHex(buffer);\n};\n\nexport const u16ToLe = (u16: number): string => {\n  const buffer = new ArrayBuffer(2);\n  const view = new DataView(buffer);\n  view.setUint16(0, u16, true);\n  return ArrayBufferToHex(buffer);\n};\n\nconst u32ToHex = (u32: string | number, littleEndian?: boolean): string => {\n  const buffer = new ArrayBuffer(4);\n  const view = new DataView(buffer);\n  view.setUint32(0, Number(u32), littleEndian);\n  return ArrayBufferToHex(buffer);\n};\n\nexport const u32ToBe = (u32: string | number): string => {\n  return u32ToHex(u32, false);\n};\n\nexport const u32ToLe = (u32: string | number): string => {\n  return u32ToHex(u32, true);\n};\n\nexport const u32ToLeHex = (u32: string | number): string => {\n  const hex = u32ToBe(u32);\n  const le = reverseHex(parseInt(hex, 16).toString(16));\n  return append0x(parseInt(le, 16).toString(16));\n};\n\nexport const leToU32 = (leHex: string): number => {\n  const bytes = hexToBytes(append0x(leHex));\n  const beHex = `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, '0'), '')}`;\n  return parseInt(beHex, 16);\n};\n\nexport const u64ToLe = (u64: bigint): string => {\n  const val = u64.toString(16).padStart(16, '0');\n  const viewLeft = u32ToLe(`0x${val.slice(8)}`);\n  const viewRight = u32ToLe(`0x${val.slice(0, 8)}`);\n  return `${viewLeft}${viewRight}`;\n};\n\nexport const u128ToLe = (u128: bigint): string => {\n  const val = u128.toString(16).padStart(32, '0');\n  const viewLeft = u64ToLe(BigInt(`0x${val.slice(16)}`));\n  const viewRight = u64ToLe(BigInt(`0x${val.slice(0, 16)}`));\n  return `${viewLeft}${viewRight}`;\n};\n\nexport const leToU128 = (leHex: string): bigint => {\n  const bytes = hexToBytes(append0x(leHex));\n  const beHex = `0x${bytes.reduceRight((pre, cur) => pre + cur.toString(16).padStart(2, '0'), '')}`;\n  return BigInt(beHex);\n};\n\nexport const utf8ToHex = (text: string) => {\n  let result = text.trim();\n  if (result.startsWith('0x')) {\n    return result;\n  }\n  result = bytesToHex(new TextEncoder().encode(result));\n  return result;\n};\n\nexport const hexToUtf8 = (hex: string) => {\n  let result = hex.trim();\n  try {\n    result = new TextDecoder().decode(hexToBytes(result));\n  } catch (error) {\n    console.error('hexToUtf8 error:', error);\n  }\n  return result;\n};\n\nexport const reverseHex = (str: Hex) => {\n  return bytesToHex(hexToBytes(append0x(str)).reverse());\n};\n","import { PERSONAL, blake2b, hexToBytes, serializeInput, serializeScript } from '@nervosnetwork/ckb-sdk-utils';\nimport { RawClusterData, packRawClusterData, SporeDataProps, packRawSporeData } from '@spore-sdk/core';\nimport { remove0x, u64ToLe } from './hex';\nimport {\n  CKB_UNIT,\n  UNLOCKABLE_LOCK_SCRIPT,\n  getClusterTypeScript,\n  getSporeTypeScript,\n  getXudtTypeScript,\n} from '../constants';\nimport { Hex, IndexerCell, RgbppTokenInfo } from '../types';\nimport { encodeRgbppTokenInfo, genBtcTimeLockScript } from './rgbpp';\nimport { Collector } from '../collector';\nimport { NoLiveCellError } from '../error';\n\nexport { serializeScript };\n\nexport const calculateTransactionFee = (txSize: number, feeRate?: bigint): bigint => {\n  const rate = feeRate ?? BigInt(1100);\n  const ratio = BigInt(1000);\n  const base = BigInt(txSize) * rate;\n  const fee = base / ratio;\n  return fee * ratio < base ? fee + BigInt(1) : fee;\n};\n\nexport const isUDTTypeSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {\n  const xudtType = serializeScript(getXudtTypeScript(isMainnet));\n  const typeAsset = serializeScript({\n    ...type,\n    args: '',\n  });\n  return xudtType === typeAsset;\n};\n\nexport const isSporeTypeSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {\n  const sporeType = serializeScript(getSporeTypeScript(isMainnet));\n  const typeAsset = serializeScript({\n    ...type,\n    args: '',\n  });\n  return sporeType === typeAsset;\n};\n\nexport const isClusterSporeTypeSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {\n  const typeAsset = serializeScript({\n    ...type,\n    args: '',\n  });\n  const clusterType = serializeScript(getClusterTypeScript(isMainnet));\n  return isSporeTypeSupported(type, isMainnet) || clusterType === typeAsset;\n};\n\nexport const isTypeAssetSupported = (type: CKBComponents.Script, isMainnet: boolean): boolean => {\n  return isUDTTypeSupported(type, isMainnet) || isClusterSporeTypeSupported(type, isMainnet);\n};\n\nconst CELL_CAPACITY_SIZE = 8;\nconst UDT_CELL_DATA_SIZE = 16;\n\n// Assume the length of the lock script args cannot exceed 26 bytes. If it exceeds, an error will be thrown.\nconst LOCK_ARGS_HEX_MAX_SIZE = 26;\nexport const isLockArgsSizeExceeded = (args: Hex) => remove0x(args).length > LOCK_ARGS_HEX_MAX_SIZE * 2;\n\n// The BTC_TIME_CELL_INCREASED_SIZE depends on the receiver lock script args whose length cannot exceed LOCK_ARGS_HEX_MAX_SIZE bytes\nconst BTC_TIME_CELL_INCREASED_SIZE = 95;\n\n// For simplicity, we keep the capacity of the RGBPP cell the same as the BTC time cell\n// minimum occupied capacity and assume UDT cell data size is 16bytes\n/**\n * RGB_lock:\n    code_hash: \n      RGB_lock\n    args:\n      out_index | bitcoin_tx_id\n */\nconst RGBPP_LOCK_SIZE = 32 + 1 + 36;\nexport const calculateRgbppCellCapacity = (xudtType?: CKBComponents.Script): bigint => {\n  const typeArgsSize = xudtType ? remove0x(xudtType.args).length / 2 : 32;\n  const udtTypeSize = 33 + typeArgsSize;\n  const cellSize =\n    RGBPP_LOCK_SIZE + udtTypeSize + CELL_CAPACITY_SIZE + UDT_CELL_DATA_SIZE + BTC_TIME_CELL_INCREASED_SIZE;\n  return BigInt(cellSize) * CKB_UNIT;\n};\n\n// Minimum occupied capacity and 1 ckb for transaction fee\n// Assume UDT cell data size is 16bytes\n// The default length of xut type args is 32 bytes\nconst DEFAULT_UDT_ARGS_SIZE = 32;\nexport const calculateUdtCellCapacity = (lock: CKBComponents.Script, udtType?: CKBComponents.Script): bigint => {\n  const lockArgsSize = remove0x(lock.args).length / 2;\n  const typeArgsSize = udtType ? remove0x(udtType.args).length / 2 : DEFAULT_UDT_ARGS_SIZE;\n  const lockSize = 33 + lockArgsSize;\n  const typeSize = 33 + typeArgsSize;\n  const cellSize = lockSize + typeSize + CELL_CAPACITY_SIZE + UDT_CELL_DATA_SIZE;\n  return BigInt(cellSize + 1) * CKB_UNIT;\n};\n\n// Unique Type Script: https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#unique-type-script\nexport const calculateXudtTokenInfoCellCapacity = (tokenInfo: RgbppTokenInfo, lock: CKBComponents.Script): bigint => {\n  const lockSize = remove0x(lock.args).length / 2 + 33;\n  const cellDataSize = remove0x(encodeRgbppTokenInfo(tokenInfo)).length / 2;\n  const uniqueTypeSize = 32 + 1 + 20;\n  const cellSize = lockSize + uniqueTypeSize + CELL_CAPACITY_SIZE + cellDataSize;\n  return BigInt(cellSize) * CKB_UNIT;\n};\n\n// Unique Type Script: https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#unique-type-script\nexport const calculateRgbppTokenInfoCellCapacity = (tokenInfo: RgbppTokenInfo, isMainnet: boolean): bigint => {\n  const btcTimeLock = genBtcTimeLockScript(UNLOCKABLE_LOCK_SCRIPT, isMainnet);\n  const lockSize = remove0x(btcTimeLock.args).length / 2 + 33;\n  const cellDataSize = remove0x(encodeRgbppTokenInfo(tokenInfo)).length / 2;\n  const typeSize = 32 + 1 + 20;\n  const cellSize = lockSize + typeSize + CELL_CAPACITY_SIZE + cellDataSize;\n  return BigInt(cellSize) * CKB_UNIT;\n};\n\n// Generate type id for Unique type script args\nexport const generateUniqueTypeArgs = (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => {\n  const input = hexToBytes(serializeInput(firstInput));\n  const s = blake2b(32, null, null, PERSONAL);\n  s.update(input);\n  s.update(hexToBytes(`0x${u64ToLe(BigInt(firstOutputIndex))}`));\n  return `0x${s.digest('hex').slice(0, 40)}`;\n};\n\n// https://docs.spore.pro/recipes/Create/create-private-cluster\n// Minimum occupied capacity and 1 ckb for transaction fee\nexport const calculateRgbppClusterCellCapacity = (clusterData: RawClusterData): bigint => {\n  const clusterDataSize = packRawClusterData(clusterData).length;\n  const clusterTypeSize = 32 + 1 + 32;\n  const cellSize = RGBPP_LOCK_SIZE + clusterTypeSize + CELL_CAPACITY_SIZE + clusterDataSize;\n  return BigInt(cellSize + 1) * CKB_UNIT;\n};\n\n// https://docs.spore.pro/recipes/Create/create-clustered-spore\n// For simplicity, we keep the capacity of the RGBPP cell the same as the BTC time cell\n// minimum occupied capacity and 1 ckb for transaction fee\n/**\n * rgbpp_spore_cell:\n    lock: rgbpp_lock\n    type: spore_type\n    data: sporeData\n */\nexport const calculateRgbppSporeCellCapacity = (sporeData: SporeDataProps): bigint => {\n  const sporeDataSize = packRawSporeData(sporeData).length;\n  const sporeTypeSize = 32 + 1 + 32;\n  const cellSize = RGBPP_LOCK_SIZE + sporeTypeSize + CELL_CAPACITY_SIZE + sporeDataSize + BTC_TIME_CELL_INCREASED_SIZE;\n  return BigInt(cellSize + 1) * CKB_UNIT;\n};\n\n// Calculate the occupied capacity of the CKB cell\nexport const calculateCellOccupiedCapacity = (cell: IndexerCell): bigint => {\n  const cellDataSize = remove0x(cell.outputData).length / 2;\n  const lockSize = remove0x(cell.output.lock.args).length / 2 + 1 + 32;\n  const typeSize = cell.output.type ? remove0x(cell.output.type.args).length / 2 + 1 + 32 : 0;\n  const cellSize = cellDataSize + lockSize + typeSize + CELL_CAPACITY_SIZE;\n  return BigInt(cellSize) * CKB_UNIT;\n};\n\nexport const deduplicateList = (rgbppLockArgsList: Hex[]): Hex[] => {\n  return Array.from(new Set(rgbppLockArgsList));\n};\n\n// Compare the whole script\nexport const isScriptEqual = (s1: Hex | CKBComponents.Script, s2: Hex | CKBComponents.Script) => {\n  const temp1 = typeof s1 === 'string' ? remove0x(s1) : remove0x(serializeScript(s1));\n  const temp2 = typeof s2 === 'string' ? remove0x(s2) : remove0x(serializeScript(s2));\n  return temp1 === temp2;\n};\n\n/**\n * Check whether the capacity of inputs is sufficient for outputs\n * @param ckbTx CKB raw transaction\n * @param collector The collector that collects CKB live cells and transactions\n * @returns When the capacity of inputs is sufficient for outputs, return true, otherwise return false\n */\nexport const checkCkbTxInputsCapacitySufficient = async (\n  ckbTx: CKBComponents.RawTransaction,\n  collector: Collector,\n): Promise<boolean> => {\n  let sumInputsCapacity = BigInt(0);\n  for await (const input of ckbTx.inputs) {\n    const liveCell = await collector.getLiveCell(input.previousOutput!);\n    if (!liveCell) {\n      throw new NoLiveCellError('The cell with the specific out point is dead');\n    }\n    sumInputsCapacity += BigInt(liveCell.output.capacity);\n  }\n  const sumOutputsCapacity = ckbTx.outputs\n    .map((output) => BigInt(output.capacity))\n    .reduce((prev, current) => prev + current, BigInt(0));\n  return sumInputsCapacity > sumOutputsCapacity;\n};\n","import { sha256 } from 'js-sha256';\nimport { RgbppApiSpvProof } from '@rgbpp-sdk/service';\nimport { BTCTestnetType, Hex, IndexerCell, RgbppCkbVirtualTx, RgbppTokenInfo, SpvClientCellTxProof } from '../types';\nimport { append0x, remove0x, reverseHex, u32ToLe, u8ToHex, utf8ToHex } from './hex';\nimport {\n  BTC_JUMP_CONFIRMATION_BLOCKS,\n  RGBPP_TX_ID_PLACEHOLDER,\n  RGBPP_TX_INPUTS_MAX_LENGTH,\n  RGBPP_TX_WITNESS_MAX_SIZE,\n  getBtcTimeLockScript,\n  getRgbppLockScript,\n} from '../constants';\nimport { RGBPPLock } from '../schemas/generated/rgbpp';\nimport { BTCTimeLock } from '../schemas/generated/rgbpp';\nimport { Script } from '../schemas/generated/blockchain';\nimport { BytesLike } from '@ckb-lumos/codec';\nimport { toCamelcase } from './case-parser';\nimport {\n  InputsOrOutputsLenError,\n  NoRgbppLiveCellError,\n  RgbppCkbTxInputsExceededError,\n  RgbppUtxoBindMultiTypeAssetsError,\n} from '../error';\nimport { calculateRgbppCellCapacity, isScriptEqual, isUDTTypeSupported } from './ckb-tx';\nimport { blockchain } from '@ckb-lumos/base';\nimport {\n  bytesToHex,\n  hexToBytes,\n  serializeOutPoint,\n  serializeOutput,\n  serializeScript,\n} from '@nervosnetwork/ckb-sdk-utils';\nimport { HashType } from '../schemas/customized';\n\nexport const genRgbppLockScript = (rgbppLockArgs: Hex, isMainnet: boolean, btcTestnetType?: BTCTestnetType) => {\n  return {\n    ...getRgbppLockScript(isMainnet, btcTestnetType),\n    args: append0x(rgbppLockArgs),\n  } as CKBComponents.Script;\n};\n\nexport const genBtcTimeLockArgs = (lock: CKBComponents.Script, btcTxId: Hex, after: number): Hex => {\n  const btcTxid = blockchain.Byte32.pack(reverseHex(btcTxId));\n  const lockScript = Script.unpack(serializeScript(lock));\n  return bytesToHex(BTCTimeLock.pack({ lockScript, after, btcTxid }));\n};\n\n/**\n * btcTimeLockArgs: \n * table BTCTimeLock {\n    lock_script: Script,\n    after: Uint32,\n    btc_txid: Byte32,\n  }\n */\nexport const genBtcTimeLockScript = (\n  toLock: CKBComponents.Script,\n  isMainnet: boolean,\n  btcTestnetType?: BTCTestnetType,\n  btcConfirmationBlocks?: number,\n) => {\n  const args = genBtcTimeLockArgs(\n    toLock,\n    RGBPP_TX_ID_PLACEHOLDER,\n    btcConfirmationBlocks ?? BTC_JUMP_CONFIRMATION_BLOCKS,\n  );\n  return {\n    ...getBtcTimeLockScript(isMainnet, btcTestnetType),\n    args,\n  } as CKBComponents.Script;\n};\n\n// The maximum length of inputs and outputs is 255, and the field type representing the length in the RGB++ protocol is Uint8\nconst MAX_RGBPP_CELL_NUM = 255;\n// refer to https://github.com/ckb-cell/rgbpp/blob/0c090b039e8d026aad4336395b908af283a70ebf/contracts/rgbpp-lock/src/main.rs#L173-L211\nexport const calculateCommitment = (rgbppVirtualTx: RgbppCkbVirtualTx | CKBComponents.RawTransaction): Hex => {\n  const hash = sha256.create();\n  hash.update(hexToBytes(utf8ToHex('RGB++')));\n  const version = [0, 0];\n  hash.update(version);\n\n  const { inputs, outputs, outputsData } = rgbppVirtualTx;\n\n  if (inputs.length > MAX_RGBPP_CELL_NUM || outputs.length > MAX_RGBPP_CELL_NUM) {\n    throw new InputsOrOutputsLenError(\n      'The inputs or outputs length of RGB++ CKB virtual tx cannot be greater than 255',\n    );\n  }\n  hash.update([inputs.length, outputs.length]);\n\n  for (const input of inputs) {\n    hash.update(hexToBytes(serializeOutPoint(input.previousOutput)));\n  }\n  for (let index = 0; index < outputs.length; index++) {\n    const output = outputs[index];\n    const outputData = outputsData[index];\n    hash.update(hexToBytes(serializeOutput(output)));\n\n    const outputDataLen = u32ToLe(remove0x(outputData).length / 2);\n    hash.update(hexToBytes(append0x(outputDataLen)));\n    hash.update(hexToBytes(outputData));\n  }\n  // double sha256\n  return sha256(hash.array());\n};\n\n/**\n * table BTCTimeLock {\n    lock_script: Script,\n    after: Uint32,\n    btc_txid: Byte32,\n  }\n */\nexport const lockScriptFromBtcTimeLockArgs = (args: Hex): CKBComponents.Script => {\n  const { lockScript } = BTCTimeLock.unpack(append0x(args));\n  return {\n    ...lockScript,\n    hashType: HashType.unpack(lockScript.hashType),\n  };\n};\n\nexport interface BTCTimeLockArgs {\n  btcTxId: Hex;\n  after: number;\n}\nexport const btcTxIdAndAfterFromBtcTimeLockArgs = (args: Hex): BTCTimeLockArgs => {\n  const { btcTxid, after } = BTCTimeLock.unpack(append0x(args));\n  console.log(btcTxid);\n  console.log(after);\n  return {\n    btcTxId: reverseHex(append0x(btcTxid)),\n    after,\n  };\n};\n\n/**\n * https://learnmeabitcoin.com/technical/general/byte-order/\n * Whenever you're working with transaction/block hashes internally (e.g. inside raw bitcoin data), you use the natural byte order.\n * Whenever you're displaying or searching for transaction/block hashes, you use the reverse byte order.\n */\nexport const buildRgbppLockArgs = (outIndex: number, btcTxId: Hex): Hex => {\n  return `0x${u32ToLe(outIndex)}${remove0x(reverseHex(btcTxId))}`;\n};\n\nexport const buildPreLockArgs = (outIndex: number) => {\n  return buildRgbppLockArgs(outIndex, RGBPP_TX_ID_PLACEHOLDER);\n};\n\nexport interface RgbppLockArgs {\n  btcTxId: Hex;\n  outIndex: number;\n}\nexport const unpackRgbppLockArgs = (source: BytesLike): RgbppLockArgs => {\n  const unpacked = RGBPPLock.unpack(source);\n  return {\n    btcTxId: reverseHex(unpacked.btcTxid),\n    outIndex: unpacked.outIndex,\n  };\n};\n\nexport const compareInputs = (a: IndexerCell, b: IndexerCell) => {\n  if (a.output.lock.args < b.output.lock.args) {\n    return -1;\n  }\n  if (a.output.lock.args > b.output.lock.args) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * RGBPP lock args: out_index | bitcoin_tx_id\n * BTC time lock args: lock_script | after | bitcoin_tx_id\n *\n * https://learnmeabitcoin.com/technical/general/byte-order/\n * Whenever you're working with transaction/block hashes internally (e.g. inside raw bitcoin data), you use the natural byte order.\n * Whenever you're displaying or searching for transaction/block hashes, you use the reverse byte order.\n */\nconst RGBPP_MIN_LOCK_ARGS_SIZE = 36 * 2;\nconst BTC_TX_ID_SIZE = 32 * 2;\nexport const replaceLockArgsWithRealBtcTxId = (lockArgs: Hex, txId: Hex): Hex => {\n  const argsLength = remove0x(lockArgs).length;\n  if (argsLength < RGBPP_MIN_LOCK_ARGS_SIZE) {\n    throw new Error('Rgbpp lock args or BTC time lock args length is invalid');\n  }\n  return `0x${remove0x(lockArgs).substring(0, argsLength - BTC_TX_ID_SIZE)}${remove0x(reverseHex(txId))}`;\n};\n\nconst BTC_TESTNETS: BTCTestnetType[] = ['Testnet3', 'Signet'];\nconst isLockEqual = (lock1: CKBComponents.Script, lock2: CKBComponents.Script) =>\n  lock1.codeHash === lock2.codeHash && lock1.hashType === lock2.hashType;\n\nexport const isRgbppLockCell = (cell: CKBComponents.CellOutput, isMainnet: boolean): boolean => {\n  if (isMainnet) {\n    return isLockEqual(cell.lock, getRgbppLockScript(isMainnet));\n  }\n  return BTC_TESTNETS.some((network) => isLockEqual(cell.lock, getRgbppLockScript(isMainnet, network)));\n};\n\nexport const isRgbppLockCellIgnoreChain = (cell: CKBComponents.CellOutput): boolean => {\n  return isRgbppLockCell(cell, true) || isRgbppLockCell(cell, false);\n};\n\nexport const isBtcTimeLockCell = (cell: CKBComponents.CellOutput, isMainnet: boolean): boolean => {\n  if (isMainnet) {\n    return isLockEqual(cell.lock, getBtcTimeLockScript(isMainnet));\n  }\n  return BTC_TESTNETS.some((network) => isLockEqual(cell.lock, getBtcTimeLockScript(isMainnet, network)));\n};\n\nexport const isRgbppLockOrBtcTimeLock = (lock: CKBComponents.Script, isMainnet: boolean) => {\n  if (isMainnet) {\n    return isLockEqual(lock, getRgbppLockScript(isMainnet)) || isLockEqual(lock, getBtcTimeLockScript(isMainnet));\n  }\n  return BTC_TESTNETS.flatMap((network) => [\n    getRgbppLockScript(isMainnet, network),\n    getBtcTimeLockScript(isMainnet, network),\n  ]).some((script) => isLockEqual(script, lock));\n};\n\nexport const transformSpvProof = (spvProof: RgbppApiSpvProof): SpvClientCellTxProof => {\n  return toCamelcase(spvProof) as SpvClientCellTxProof;\n};\n\nexport const buildSpvClientCellDep = (spvClient: CKBComponents.OutPoint) => {\n  const cellDep: CKBComponents.CellDep = {\n    outPoint: spvClient,\n    depType: 'code',\n  };\n  return cellDep;\n};\n\n/**\n * Estimate the size of the witness based on the number of groups of lock args\n * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id\n */\nexport const estimateWitnessSize = (rgbppLockArgsList: Hex[]): number => {\n  const rgbppLockArgsSet = new Set(rgbppLockArgsList);\n  const inputsGroupSize = rgbppLockArgsSet.size;\n  return RGBPP_TX_WITNESS_MAX_SIZE * inputsGroupSize;\n};\n\n/**\n * Encode RGBPP token information into hex format\n * @param tokenInfo RGBPP token information\n * @returns hex string for cell data\n */\nexport const encodeRgbppTokenInfo = (tokenInfo: RgbppTokenInfo) => {\n  const decimal = u8ToHex(tokenInfo.decimal);\n  const name = remove0x(utf8ToHex(tokenInfo.name));\n  const nameSize = u8ToHex(name.length / 2);\n  const symbol = remove0x(utf8ToHex(tokenInfo.symbol));\n  const symbolSize = u8ToHex(symbol.length / 2);\n  return `0x${decimal}${nameSize}${name}${symbolSize}${symbol}`;\n};\n\nexport const calculateRgbppTokenInfoSize = (tokenInfo: RgbppTokenInfo): bigint => {\n  const encodedTokenInfo = encodeRgbppTokenInfo(tokenInfo);\n  return BigInt(remove0x(encodedTokenInfo).length / 2);\n};\n\nexport const throwErrorWhenTxInputsExceeded = (inputLen: number) => {\n  if (inputLen > RGBPP_TX_INPUTS_MAX_LENGTH) {\n    throw new RgbppCkbTxInputsExceededError(`Please ensure the tx inputs do not exceed ${RGBPP_TX_INPUTS_MAX_LENGTH}`);\n  }\n};\n\n// Check the validity of RGB++ cells and throw an exception if the conditions are not met to avoid building invalid CKB TX\nexport const throwErrorWhenRgbppCellsInvalid = (\n  cells: IndexerCell[] | undefined,\n  xudtTypeBytes: Hex,\n  isMainnet: boolean,\n) => {\n  if (!cells || cells.length === 0) {\n    throw new NoRgbppLiveCellError('No rgbpp cells found with the rgbpp lock args');\n  }\n  const typeCells = cells.filter((cell) => !!cell.output.type);\n  if (typeCells.length === 0) {\n    throw new NoRgbppLiveCellError('No rgbpp cells found with the rgbpp lock args');\n  }\n\n  const isUDTTypeNotSupported = typeCells.some(\n    (cell) => cell.output.type && !isUDTTypeSupported(cell.output.type, isMainnet),\n  );\n  if (isUDTTypeNotSupported) {\n    throw new RgbppUtxoBindMultiTypeAssetsError(\n      'The BTC UTXO must not be bound to xUDT and other type cells at the same time',\n    );\n  }\n\n  const isTargetExist = typeCells.some((cell) => isScriptEqual(cell.output.type!, xudtTypeBytes));\n  if (!isTargetExist) {\n    throw new NoRgbppLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');\n  }\n};\n\n/**\n * Check if the tx's unoccupied capacity is enough to create a new rgbpp-cell as a UDT change cell\n */\nexport const isRgbppCapacitySufficientForChange = (\n  sumUdtInputsCapacity: bigint,\n  receiverOutputCapacity: bigint,\n): boolean => {\n  const rgbppOccupiedCapacity = calculateRgbppCellCapacity();\n  return sumUdtInputsCapacity > receiverOutputCapacity + rgbppOccupiedCapacity;\n};\n","import { Cell as LumosCell } from '@ckb-lumos/base';\nimport { UnpackResult } from '@ckb-lumos/codec';\nimport {\n  Action,\n  assembleTransferSporeAction,\n  assembleCobuildWitnessLayout,\n  assembleCreateClusterAction,\n  assembleCreateSporeAction,\n  assembleTransferClusterAction,\n} from '@spore-sdk/core/lib/cobuild/index.js';\nimport { u64ToLe } from './hex';\nimport { Hex, IndexerCell, SporesCreateCobuildParams } from '../types';\nimport { NoRgbppLiveCellError, RgbppSporeTypeMismatchError, RgbppUtxoBindMultiTypeAssetsError } from '../error';\nimport { isScriptEqual, isSporeTypeSupported } from './ckb-tx';\nimport { blake2b, hexToBytes, PERSONAL, serializeInput } from '@nervosnetwork/ckb-sdk-utils';\n\n// Generate type id for cluster id\nexport const generateClusterId = (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => {\n  const input = hexToBytes(serializeInput(firstInput));\n  const s = blake2b(32, null, null, PERSONAL);\n  s.update(input);\n  s.update(hexToBytes(`0x${u64ToLe(BigInt(firstOutputIndex))}`));\n  return `0x${s.digest('hex')}`;\n};\n\n// Generate type id for spore id\nexport const generateSporeId = (firstInput: CKBComponents.CellInput, firstOutputIndex: number) => {\n  return generateClusterId(firstInput, firstOutputIndex);\n};\n\nexport const generateClusterCreateCoBuild = (\n  clusterOutput: CKBComponents.CellOutput,\n  clusterOutputData: Hex,\n): string => {\n  const output = {\n    cellOutput: clusterOutput,\n    data: clusterOutputData,\n  } as LumosCell;\n  const { actions } = assembleCreateClusterAction(output);\n  return assembleCobuildWitnessLayout(actions);\n};\n\nexport const generateSporeCreateCoBuild = ({\n  sporeOutputs,\n  sporeOutputsData,\n  clusterCell,\n  clusterOutputCell,\n}: SporesCreateCobuildParams): string => {\n  if (sporeOutputs.length !== sporeOutputsData.length) {\n    throw new Error('The length of spore outputs and spore cell data are not same');\n  }\n  let sporeActions: UnpackResult<typeof Action>[] = [];\n\n  // cluster transfer actions\n  const clusterInput = {\n    cellOutput: clusterCell.output,\n    data: clusterCell.outputData,\n  } as LumosCell;\n  const clusterOutput = {\n    cellOutput: clusterOutputCell,\n    data: clusterCell.outputData,\n  } as LumosCell;\n  const { actions } = assembleTransferClusterAction(clusterInput, clusterOutput);\n  sporeActions = sporeActions.concat(actions);\n\n  // spores create actions\n  for (let index = 0; index < sporeOutputs.length; index++) {\n    const sporeOutput = {\n      cellOutput: sporeOutputs[index],\n      data: sporeOutputsData[index],\n    } as LumosCell;\n    const { actions } = assembleCreateSporeAction(sporeOutput);\n    sporeActions = sporeActions.concat(actions);\n  }\n  return assembleCobuildWitnessLayout(sporeActions);\n};\n\nexport const generateSporeTransferCoBuild = (\n  sporeCells: IndexerCell[] | CKBComponents.LiveCell[],\n  outputCells: CKBComponents.CellOutput[],\n): string => {\n  if (sporeCells.length !== outputCells.length) {\n    throw new Error('The length of spore input cells and spore output cells are not same');\n  }\n  let sporeActions: UnpackResult<typeof Action>[] = [];\n  for (let index = 0; index < sporeCells.length; index++) {\n    const sporeCell = sporeCells[index];\n    const outputData = 'outputData' in sporeCell ? sporeCell.outputData : sporeCell.data!.content!;\n    const sporeInput = {\n      cellOutput: sporeCells[index].output,\n      data: outputData,\n    } as LumosCell;\n    const sporeOutput = {\n      cellOutput: outputCells[index],\n      data: outputData,\n    } as LumosCell;\n    const { actions } = assembleTransferSporeAction(sporeInput, sporeOutput);\n    sporeActions = sporeActions.concat(actions);\n  }\n  return assembleCobuildWitnessLayout(sporeActions);\n};\n\n// Check the validity of RGB++ spore cells and throw an exception if the conditions are not met to avoid building invalid CKB TX\nexport const throwErrorWhenSporeCellsInvalid = (\n  sporeCells: IndexerCell[] | undefined,\n  sporeTypeBytes: Hex,\n  isMainnet: boolean,\n) => {\n  if (!sporeCells || sporeCells.length === 0) {\n    throw new NoRgbppLiveCellError('No spore rgbpp cells found with the spore rgbpp lock args');\n  }\n  if (sporeCells.length > 1) {\n    throw new RgbppUtxoBindMultiTypeAssetsError('The BTC UTXO must not be bound to multiple CKB cells');\n  }\n  const sporeCell = sporeCells[0];\n\n  if (!sporeCell.output.type) {\n    throw new RgbppSporeTypeMismatchError('The cell with the rgbpp lock args has no spore asset');\n  }\n\n  if (!isSporeTypeSupported(sporeCell.output.type, isMainnet)) {\n    throw new RgbppSporeTypeMismatchError('The cell type is not the supported spore type script');\n  }\n\n  if (!isScriptEqual(sporeCell.output.type, sporeTypeBytes)) {\n    throw new RgbppSporeTypeMismatchError('The spore cell type with the rgbpp lock args does not match');\n  }\n};\n","import axios from 'axios';\nimport { getBtcTimeLockDep, getRgbppLockDep, getUniqueTypeDep, getXudtDep } from '../constants';\nimport { BTCTestnetType } from '../types';\n\ninterface CellDepsObject {\n  rgbpp: {\n    mainnet: CKBComponents.CellDep;\n    testnet: CKBComponents.CellDep;\n    signet: CKBComponents.CellDep;\n  };\n  btcTime: {\n    mainnet: CKBComponents.CellDep;\n    testnet: CKBComponents.CellDep;\n    signet: CKBComponents.CellDep;\n  };\n  xudt: {\n    testnet: CKBComponents.CellDep;\n  };\n  unique: {\n    testnet: CKBComponents.CellDep;\n  };\n}\nconst GITHUB_CELL_DEPS_JSON_URL =\n  'https://raw.githubusercontent.com/ckb-cell/typeid-contract-cell-deps/main/deployment/cell-deps.json';\n\nconst CDN_GITHUB_CELL_DEPS_JSON_URL =\n  'https://cdn.jsdelivr.net/gh/ckb-cell/typeid-contract-cell-deps@main/deployment/cell-deps.json';\n\nconst request = (url: string) => axios.get(url, { timeout: 2000 });\n\nconst fetchCellDepsJson = async () => {\n  try {\n    const response = await Promise.any([request(GITHUB_CELL_DEPS_JSON_URL), request(CDN_GITHUB_CELL_DEPS_JSON_URL)]);\n    return response.data as CellDepsObject;\n  } catch (error) {\n    // console.error('Error fetching cell deps:', error);\n  }\n};\n\nexport interface CellDepsSelected {\n  rgbpp?: boolean;\n  btcTime?: boolean;\n  xudt?: boolean;\n  unique?: boolean;\n}\n\nexport const fetchTypeIdCellDeps = async (\n  isMainnet: boolean,\n  selected: CellDepsSelected,\n  btcTestnetType?: BTCTestnetType,\n): Promise<CKBComponents.CellDep[]> => {\n  let rgbppLockDep = getRgbppLockDep(isMainnet, btcTestnetType);\n  let btcTimeDep = getBtcTimeLockDep(isMainnet, btcTestnetType);\n  let xudtDep = getXudtDep(isMainnet);\n  let uniqueDep = getUniqueTypeDep(isMainnet);\n\n  const cellDepsObj = await fetchCellDepsJson();\n  if (cellDepsObj) {\n    if (btcTestnetType === 'Signet') {\n      rgbppLockDep = cellDepsObj.rgbpp.signet;\n      btcTimeDep = cellDepsObj.btcTime.signet;\n    } else {\n      rgbppLockDep = isMainnet ? cellDepsObj.rgbpp.mainnet : cellDepsObj.rgbpp.testnet;\n      btcTimeDep = isMainnet ? cellDepsObj.btcTime.mainnet : cellDepsObj.btcTime.testnet;\n    }\n    if (!isMainnet) {\n      xudtDep = cellDepsObj.xudt.testnet;\n      uniqueDep = cellDepsObj.unique.testnet;\n    }\n  }\n  let cellDeps: CKBComponents.CellDep[] = [];\n  if (selected.rgbpp) {\n    // RGB++ config cell is deployed together with the RGB++ lock contract\n    //\n    // contract_deployment_transaction:\n    //   - output(index=0, data=rgbpp_code)\n    //   - output(index=1, data=rgbpp_config)\n    //\n    cellDeps = [\n      ...cellDeps,\n      rgbppLockDep,\n      {\n        ...rgbppLockDep,\n        outPoint: {\n          ...rgbppLockDep.outPoint,\n          index: '0x1',\n        },\n      },\n    ] as CKBComponents.CellDep[];\n  }\n\n  if (selected.btcTime) {\n    // BTC Time config cell is deployed together with the BTC Time lock contract\n    //\n    // contract_deployment_transaction:\n    //   - output(index=0, data=rgbpp_code)\n    //   - output(index=1, data=rgbpp_config)\n    //\n    cellDeps = [\n      ...cellDeps,\n      btcTimeDep,\n      {\n        ...btcTimeDep,\n        outPoint: {\n          ...btcTimeDep.outPoint,\n          index: '0x1',\n        },\n      },\n    ] as CKBComponents.CellDep[];\n  }\n\n  if (selected.xudt) {\n    cellDeps = [...cellDeps, xudtDep] as CKBComponents.CellDep[];\n  }\n\n  if (selected.unique) {\n    cellDeps = [...cellDeps, uniqueDep] as CKBComponents.CellDep[];\n  }\n\n  return cellDeps;\n};\n","import { Hash, HexNumber, OutPoint, blockchain } from '@ckb-lumos/base';\nimport { InvalidCellIdError } from '../error';\nimport { append0x } from './hex';\n\nexport const encodeCellId = (txHash: Hash, index: HexNumber): string => {\n  if (!txHash.startsWith('0x') || !index.startsWith('0x')) {\n    throw new InvalidCellIdError(`Cannot encode CellId due to valid format: txHash=${txHash}, index=${index}`);\n  }\n  try {\n    blockchain.OutPoint.pack({\n      txHash,\n      index,\n    });\n    return `${txHash}:${index}`;\n  } catch {\n    throw new InvalidCellIdError(`Cannot encode CellId due to valid format: txHash=${txHash}, index=${index}`);\n  }\n};\n\nexport const decodeCellId = (cellId: string): OutPoint => {\n  const [txHash, index] = cellId.split(':');\n  if (!txHash.startsWith('0x') || !index.startsWith('0x')) {\n    throw new InvalidCellIdError(`Cannot decode CellId: ${cellId}`);\n  }\n  try {\n    blockchain.OutPoint.pack({\n      txHash,\n      index,\n    });\n    return {\n      txHash: append0x(txHash),\n      index: append0x(index),\n    };\n  } catch {\n    throw new InvalidCellIdError(`Cannot decode CellId due to valid format: ${cellId}`);\n  }\n};\n","import { ConstructPaymasterParams } from '../types/rgbpp';\nimport { NoLiveCellError } from '../error';\nimport { CKB_UNIT, MAX_FEE, SECP256K1_WITNESS_LOCK_SIZE, getSecp256k1CellDep } from '../constants';\nimport { append0x, calculateTransactionFee } from '../utils';\nimport { AddressPrefix, addressToScript, getTransactionSize, privateKeyToAddress } from '@nervosnetwork/ckb-sdk-utils';\n\nconst SECP256K1_MIN_CAPACITY = BigInt(61) * CKB_UNIT;\n\nexport const splitMultiCellsWithSecp256k1 = async ({\n  masterPrivateKey,\n  collector,\n  receiverAddress,\n  capacityWithCKB,\n  cellAmount,\n}: ConstructPaymasterParams) => {\n  const isMainnet = receiverAddress.startsWith('ckb');\n  const masterAddress = privateKeyToAddress(masterPrivateKey, {\n    prefix: isMainnet ? AddressPrefix.Mainnet : AddressPrefix.Testnet,\n  });\n  const masterLock = addressToScript(masterAddress);\n\n  let emptyCells = await collector.getCells({\n    lock: masterLock,\n  });\n  if (!emptyCells || emptyCells.length === 0) {\n    throw new NoLiveCellError('The address has no empty cells');\n  }\n  emptyCells = emptyCells.filter((cell) => !cell.output.type);\n\n  const cellCapacity = BigInt(capacityWithCKB) * CKB_UNIT;\n  const needCapacity = cellCapacity * BigInt(cellAmount);\n  const txFee = MAX_FEE;\n  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee, {\n    minCapacity: SECP256K1_MIN_CAPACITY,\n  });\n\n  const outputs: CKBComponents.CellOutput[] = new Array(cellAmount).fill({\n    lock: addressToScript(receiverAddress),\n    capacity: append0x(cellCapacity.toString(16)),\n  });\n\n  const changeCapacity = sumInputsCapacity - needCapacity - txFee;\n  outputs.push({\n    lock: masterLock,\n    capacity: append0x(changeCapacity.toString(16)),\n  });\n  const outputsData = new Array(cellAmount + 1).fill('0x');\n\n  const emptyWitness = { lock: '', inputType: '', outputType: '' };\n  const witnesses = inputs.map((_, index) => (index === 0 ? emptyWitness : '0x'));\n\n  const cellDeps = [getSecp256k1CellDep(isMainnet)];\n\n  const unsignedTx = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  if (txFee === MAX_FEE) {\n    const txSize = getTransactionSize(unsignedTx) + SECP256K1_WITNESS_LOCK_SIZE;\n    const estimatedTxFee = calculateTransactionFee(txSize);\n    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);\n    unsignedTx.outputs[unsignedTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));\n  }\n\n  const signedTx = collector.getCkb().signTransaction(masterPrivateKey)(unsignedTx);\n  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');\n\n  console.info(`Paymaster cells has been split and tx hash is ${txHash}`);\n};\n","import {\n  AppendIssuerCellToBtcBatchTransfer,\n  BtcBatchTransferVirtualTxParams,\n  BtcBatchTransferVirtualTxResult,\n  BtcTransferVirtualTxParams,\n  BtcTransferVirtualTxResult,\n  RgbppCkbVirtualTx,\n} from '../types/rgbpp';\nimport { NoLiveCellError, NoRgbppLiveCellError, TypeAssetNotSupportedError } from '../error';\nimport {\n  append0x,\n  calculateRgbppCellCapacity,\n  calculateTransactionFee,\n  deduplicateList,\n  fetchTypeIdCellDeps,\n  isScriptEqual,\n  isUDTTypeSupported,\n  u128ToLe,\n  buildPreLockArgs,\n  calculateCommitment,\n  compareInputs,\n  estimateWitnessSize,\n  genRgbppLockScript,\n  isRgbppCapacitySufficientForChange,\n  throwErrorWhenRgbppCellsInvalid,\n  throwErrorWhenTxInputsExceeded,\n} from '../utils';\nimport { Hex, IndexerCell } from '../types';\nimport {\n  MAX_FEE,\n  MIN_CAPACITY,\n  RGBPP_WITNESS_PLACEHOLDER,\n  SECP256K1_WITNESS_LOCK_SIZE,\n  getRgbppLockScript,\n  getSecp256k1CellDep,\n} from '../constants';\nimport { blockchain } from '@ckb-lumos/base';\nimport signWitnesses from '@nervosnetwork/ckb-sdk-core/lib/signWitnesses';\nimport {\n  addressToScript,\n  getTransactionSize,\n  rawTransactionToHash,\n  scriptToHash,\n  serializeWitnessArgs,\n} from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for the btc transfer tx\n * @param collector The collector that collects CKB live cells and transactions\n * @param xudtTypeBytes The serialized hex string of the XUDT type script\n * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id\n * @param transferAmount The XUDT amount to be transferred, if the noMergeOutputCells is true, the transferAmount will be ignored\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param noMergeOutputCells(Optional) The noMergeOutputCells indicates whether the CKB outputs need to be merged. By default, the outputs will be merged.\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genBtcTransferCkbVirtualTx = async ({\n  collector,\n  xudtTypeBytes,\n  rgbppLockArgsList,\n  transferAmount,\n  isMainnet,\n  noMergeOutputCells,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: BtcTransferVirtualTxParams): Promise<BtcTransferVirtualTxResult> => {\n  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;\n\n  if (!isUDTTypeSupported(xudtType, isMainnet)) {\n    throw new TypeAssetNotSupportedError('The type script asset is not supported now');\n  }\n\n  const deduplicatedLockArgsList = deduplicateList(rgbppLockArgsList);\n\n  const rgbppLocks = deduplicatedLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));\n  let rgbppTargetCells: IndexerCell[] = [];\n  let rgbppOtherTypeCells: IndexerCell[] = [];\n  for await (const rgbppLock of rgbppLocks) {\n    const cells = await collector.getCells({ lock: rgbppLock, isDataMustBeEmpty: false });\n\n    throwErrorWhenRgbppCellsInvalid(cells, xudtTypeBytes, isMainnet);\n\n    const targetCells = cells!.filter((cell) => isScriptEqual(cell.output.type!, xudtTypeBytes));\n    const otherTypeCells = cells!.filter((cell) => !isScriptEqual(cell.output.type!, xudtTypeBytes));\n    rgbppTargetCells = [...rgbppTargetCells, ...targetCells];\n    rgbppOtherTypeCells = [...rgbppOtherTypeCells, ...otherTypeCells];\n  }\n  rgbppTargetCells = rgbppTargetCells.sort(compareInputs);\n  rgbppOtherTypeCells = rgbppOtherTypeCells.sort(compareInputs);\n\n  let inputs: CKBComponents.CellInput[] = [];\n  let sumInputsCapacity = BigInt(0);\n  const outputs: CKBComponents.CellOutput[] = [];\n  const outputsData: Hex[] = [];\n  let needPaymasterCell = false;\n\n  // The non-target RGBPP outputs correspond to the RGBPP inputs one-to-one, and the outputs are still bound to the sender’s BTC UTXOs\n  const handleNonTargetRgbppCells = (targetRgbppOutputLen: number) => {\n    for (const [index, otherRgbppCell] of rgbppOtherTypeCells.entries()) {\n      inputs.push({\n        previousOutput: otherRgbppCell.outPoint,\n        since: '0x0',\n      });\n      sumInputsCapacity += BigInt(otherRgbppCell.output.capacity);\n      outputs.push({\n        ...otherRgbppCell.output,\n        // Vouts[targetRgbppOutputLen + 1], ..., Vouts[targetRgbppOutputLen + rgbppOtherTypeCells.length] for other RGBPP assets\n        lock: genRgbppLockScript(buildPreLockArgs(targetRgbppOutputLen + index + 1), isMainnet, btcTestnetType),\n      });\n      outputsData.push(otherRgbppCell.outputData);\n    }\n  };\n\n  if (noMergeOutputCells) {\n    // The target RGBPP outputs correspond to the RGBPP inputs one-to-one, and the outputs are bound to the receivers' BTC UTXOs\n    for (const [index, targetRgbppCell] of rgbppTargetCells.entries()) {\n      inputs.push({\n        previousOutput: targetRgbppCell.outPoint,\n        since: '0x0',\n      });\n      sumInputsCapacity += BigInt(targetRgbppCell.output.capacity);\n      outputs.push({\n        ...targetRgbppCell.output,\n        // The Vouts[0] for OP_RETURN and Vouts[1], ..., Vouts[rgbppTargetCells.length] for target RGBPP assets\n        lock: genRgbppLockScript(buildPreLockArgs(index + 1), isMainnet, btcTestnetType),\n      });\n      outputsData.push(targetRgbppCell.outputData);\n    }\n    handleNonTargetRgbppCells(rgbppTargetCells.length);\n  } else {\n    // The target RGBPP assets are divided into two parts: transfer(bound to the receivers' BTC UTXO) and change(bound to the sender’s BTC UTXO).\n    const collectResult = collector.collectUdtInputs({\n      liveCells: rgbppTargetCells,\n      needAmount: transferAmount,\n    });\n    inputs = collectResult.inputs;\n    throwErrorWhenTxInputsExceeded(inputs.length);\n    sumInputsCapacity = collectResult.sumInputsCapacity;\n\n    const rgbppCellCapacity = calculateRgbppCellCapacity(xudtType);\n\n    const needRgbppChange = collectResult.sumAmount > transferAmount;\n    // To simplify, when the xUDT does not need change, all the capacity of the inputs will be given to the receiver\n    const receiverOutputCapacity = needRgbppChange ? BigInt(rgbppTargetCells[0].output.capacity) : sumInputsCapacity;\n    // The Vouts[0] for OP_RETURN and Vouts[1] for target transfer RGBPP assets\n    outputs.push({\n      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),\n      type: xudtType,\n      capacity: append0x(receiverOutputCapacity.toString(16)),\n    });\n    outputsData.push(append0x(u128ToLe(transferAmount)));\n\n    if (needRgbppChange) {\n      const isCapacitySufficient = isRgbppCapacitySufficientForChange(sumInputsCapacity, receiverOutputCapacity);\n      needPaymasterCell = !isCapacitySufficient;\n      // When the capacity of inputs is enough for the outputs, the sender needs to recover the excess capacity.\n      const udtChangeCapacity = isCapacitySufficient ? sumInputsCapacity - receiverOutputCapacity : rgbppCellCapacity;\n      // The Vouts[2] for target change RGBPP assets\n      outputs.push({\n        lock: genRgbppLockScript(buildPreLockArgs(2), isMainnet, btcTestnetType),\n        type: xudtType,\n        capacity: append0x(udtChangeCapacity.toString(16)),\n      });\n      outputsData.push(append0x(u128ToLe(collectResult.sumAmount - transferAmount)));\n    }\n\n    handleNonTargetRgbppCells(outputs.length);\n  }\n\n  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true }, btcTestnetType);\n  if (needPaymasterCell) {\n    cellDeps.push(getSecp256k1CellDep(isMainnet));\n  }\n  const witnesses: Hex[] = [];\n  const lockArgsSet: Set<string> = new Set();\n  const allRgbppCells = rgbppTargetCells.concat(rgbppOtherTypeCells);\n  for (const cell of allRgbppCells) {\n    if (lockArgsSet.has(cell.output.lock.args)) {\n      witnesses.push('0x');\n    } else {\n      lockArgsSet.add(cell.output.lock.args);\n      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);\n    }\n  }\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  if (!needPaymasterCell) {\n    const txSize =\n      getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? estimateWitnessSize(deduplicatedLockArgsList));\n    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n\n    const changeCapacity = BigInt(outputs[outputs.length - 1].capacity) - estimatedTxFee;\n    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n  }\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    needPaymasterCell,\n    sumInputsCapacity: append0x(sumInputsCapacity.toString(16)),\n  };\n};\n\n/**\n * Generate the virtual ckb transaction for the btc batch transfer tx\n * @param collector The collector that collects CKB live cells and transactions\n * @param xudtTypeBytes The serialized hex string of the XUDT type script\n * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id\n * @param rgbppReceivers The rgbpp receiver list which include toBtcAddress and transferAmount\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genBtcBatchTransferCkbVirtualTx = async ({\n  collector,\n  xudtTypeBytes,\n  rgbppLockArgsList,\n  rgbppReceivers,\n  isMainnet,\n  btcTestnetType,\n}: BtcBatchTransferVirtualTxParams): Promise<BtcBatchTransferVirtualTxResult> => {\n  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;\n\n  if (!isUDTTypeSupported(xudtType, isMainnet)) {\n    throw new TypeAssetNotSupportedError('The type script asset is not supported now');\n  }\n\n  const rgbppLocks = rgbppLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));\n  let rgbppCells: IndexerCell[] = [];\n  for await (const rgbppLock of rgbppLocks) {\n    const cells = await collector.getCells({ lock: rgbppLock, type: xudtType });\n    if (!cells || cells.length === 0) {\n      throw new NoRgbppLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');\n    }\n    rgbppCells = [...rgbppCells, ...cells];\n  }\n  rgbppCells = rgbppCells.sort(compareInputs);\n\n  const sumTransferAmount = rgbppReceivers\n    .map((receiver) => receiver.transferAmount)\n    .reduce((prev, current) => prev + current, BigInt(0));\n\n  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);\n  const outputs: CKBComponents.CellOutput[] = rgbppReceivers.map((_, index) => ({\n    // The Vouts[0] for OP_RETURN and Vouts[1], Vouts[2], ... for RGBPP assets\n    lock: genRgbppLockScript(buildPreLockArgs(index + 1), isMainnet, btcTestnetType),\n    type: xudtType,\n    capacity: append0x(rpbppCellCapacity.toString(16)),\n  }));\n  const outputsData = rgbppReceivers.map((receiver) => append0x(u128ToLe(receiver.transferAmount)));\n\n  const { inputs, sumInputsCapacity, sumAmount } = collector.collectUdtInputs({\n    liveCells: rgbppCells,\n    needAmount: sumTransferAmount,\n  });\n\n  throwErrorWhenTxInputsExceeded(inputs.length);\n\n  // Rgbpp change cell index, if it is -1, it means there is no change rgbpp cell\n  let rgbppChangeOutIndex = -1;\n  if (sumAmount > sumTransferAmount) {\n    // Rgbpp change cell is placed at the last position by default\n    rgbppChangeOutIndex = rgbppReceivers.length + 1;\n    outputs.push({\n      // The Vouts[0] for OP_RETURN and Vouts[rgbppChangeOutIndex] for RGBPP change assets\n      lock: genRgbppLockScript(buildPreLockArgs(rgbppChangeOutIndex), isMainnet, btcTestnetType),\n      type: xudtType,\n      capacity: append0x(rpbppCellCapacity.toString(16)),\n    });\n    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));\n  }\n\n  const cellDeps = [\n    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true }, btcTestnetType)),\n    getSecp256k1CellDep(isMainnet),\n  ];\n  const witnesses: Hex[] = [];\n  const lockArgsSet: Set<string> = new Set();\n  for (const cell of rgbppCells) {\n    if (lockArgsSet.has(cell.output.lock.args)) {\n      witnesses.push('0x');\n    } else {\n      lockArgsSet.add(cell.output.lock.args);\n      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);\n    }\n  }\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    rgbppChangeOutIndex,\n    needPaymasterCell: false,\n    sumInputsCapacity: append0x(sumInputsCapacity.toString(16)),\n  };\n};\n\n/**\n * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key\n * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer\n * @param issuerAddress The issuer ckb address\n * @param collector The collector that collects CKB live cells and transactions\n * @param ckbRawTx CKB raw transaction\n * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet\n * @param ckbFeeRate The CKB transaction fee rate, default value is 1100\n */\nexport const appendIssuerCellToBtcBatchTransfer = async ({\n  secp256k1PrivateKey,\n  issuerAddress,\n  collector,\n  ckbRawTx,\n  sumInputsCapacity,\n  isMainnet,\n  ckbFeeRate,\n}: AppendIssuerCellToBtcBatchTransfer): Promise<CKBComponents.RawTransaction> => {\n  const rawTx = ckbRawTx as CKBComponents.RawTransactionToSign;\n\n  const rgbppInputsLength = rawTx.inputs.length;\n\n  const sumOutputsCapacity: bigint = rawTx.outputs\n    .map((output) => BigInt(output.capacity))\n    .reduce((prev, current) => prev + current, BigInt(0));\n\n  const issuerLock = addressToScript(issuerAddress);\n  let emptyCells = await collector.getCells({ lock: issuerLock });\n  if (!emptyCells || emptyCells.length === 0) {\n    throw new NoLiveCellError('The issuer address has no empty cells');\n  }\n  emptyCells = emptyCells.filter((cell) => !cell.output.type);\n\n  let actualInputsCapacity = BigInt(sumInputsCapacity);\n  const txFee = MAX_FEE;\n  if (actualInputsCapacity <= sumOutputsCapacity) {\n    const needCapacity = sumOutputsCapacity - actualInputsCapacity + MIN_CAPACITY;\n    const { inputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee);\n    rawTx.inputs = [...rawTx.inputs, ...inputs];\n    actualInputsCapacity += sumEmptyCapacity;\n  }\n\n  let changeCapacity = actualInputsCapacity - sumOutputsCapacity;\n  const changeOutput = {\n    lock: issuerLock,\n    capacity: append0x(changeCapacity.toString(16)),\n  };\n  rawTx.outputs = [...rawTx.outputs, changeOutput];\n  rawTx.outputsData = [...rawTx.outputsData, '0x'];\n\n  const txSize = getTransactionSize(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  const keyMap = new Map<string, string>();\n  keyMap.set(scriptToHash(issuerLock), secp256k1PrivateKey);\n\n  const issuerCellIndex = rgbppInputsLength;\n  const cells = rawTx.inputs.map((input, index) => ({\n    outPoint: input.previousOutput,\n    lock: index >= issuerCellIndex ? issuerLock : getRgbppLockScript(isMainnet),\n  }));\n\n  const emptyWitness = { lock: '', inputType: '', outputType: '' };\n  const issuerWitnesses = rawTx.inputs.slice(rgbppInputsLength).map((_, index) => (index === 0 ? emptyWitness : '0x'));\n  rawTx.witnesses = [...rawTx.witnesses, ...issuerWitnesses];\n\n  const transactionHash = rawTransactionToHash(rawTx);\n  const signedWitnesses = signWitnesses(keyMap)({\n    transactionHash,\n    witnesses: rawTx.witnesses,\n    inputCells: cells,\n    skipMissingKeys: true,\n  });\n\n  const signedTx = {\n    ...rawTx,\n    witnesses: signedWitnesses.map((witness) =>\n      typeof witness !== 'string' ? serializeWitnessArgs(witness) : witness,\n    ),\n  };\n  return signedTx;\n};\n","import {\n  UpdateCkbTxWithRealBtcTxIdParams,\n  AppendPaymasterCellAndSignTxParams,\n  AppendWitnessesParams,\n  Hex,\n  SendCkbTxParams,\n} from '../types';\nimport { MIN_CAPACITY, RGBPP_WITNESS_PLACEHOLDER, SECP256K1_WITNESS_LOCK_SIZE, getRgbppLockScript } from '../constants';\nimport {\n  append0x,\n  calculateTransactionFee,\n  isRgbppLockOrBtcTimeLock,\n  replaceLockArgsWithRealBtcTxId,\n  transformSpvProof,\n  u8ToHex,\n} from '../utils';\nimport { InputsCapacityNotEnoughError } from '../error';\nimport { buildSpvClientCellDep } from '../utils';\nimport { RGBPPUnlock, Uint16 } from '../schemas/generated/rgbpp';\nimport signWitnesses from '@nervosnetwork/ckb-sdk-core/lib/signWitnesses';\nimport {\n  bytesToHex,\n  getTransactionSize,\n  rawTransactionToHash,\n  scriptToHash,\n  serializeWitnessArgs,\n} from '@nervosnetwork/ckb-sdk-utils';\n\nexport const buildRgbppUnlockWitness = (\n  btcTxBytes: Hex,\n  btcTxProof: Hex,\n  inputsLen: number,\n  outputsLen: number,\n): Hex => {\n  const inputLen = append0x(u8ToHex(inputsLen));\n  const outputLen = append0x(u8ToHex(outputsLen));\n\n  const version = Uint16.pack([0, 0]);\n  const rgbppUnlock = RGBPPUnlock.pack({\n    version,\n    extraData: { inputLen, outputLen },\n    btcTx: append0x(btcTxBytes),\n    btcTxProof: append0x(btcTxProof),\n  });\n  return append0x(bytesToHex(rgbppUnlock));\n};\n\n/**\n * Append RGBPP unlock witnesses to ckb tx and the tx can be sent to blockchain if the needPaymasterCell is false.\n * And if the needPaymasterCell is true, appending paymaster cell to inputs and signing ckb tx are required.\n * @param collector The collector that collects CKB live cells and transactions\n * @param spvService SPV RPC service\n * @param btcTxBytes The hex string of btc transaction, refer to https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts#L609\n * @param rgbppApiSpvProof The SPV client cell and tx proof which is from BTCAssetsApi\n */\nexport const appendCkbTxWitnesses = async ({\n  ckbRawTx,\n  btcTxBytes,\n  rgbppApiSpvProof,\n}: AppendWitnessesParams): Promise<CKBComponents.RawTransaction> => {\n  const rawTx = ckbRawTx;\n\n  const { spvClient, proof } = transformSpvProof(rgbppApiSpvProof);\n  rawTx.cellDeps.push(buildSpvClientCellDep(spvClient));\n\n  const rgbppUnlock = buildRgbppUnlockWitness(btcTxBytes, proof, ckbRawTx.inputs.length, ckbRawTx.outputs.length);\n  const rgbppWitness = append0x(serializeWitnessArgs({ lock: rgbppUnlock, inputType: '', outputType: '' }));\n  rawTx.witnesses = rawTx.witnesses.map((witness) => (witness === RGBPP_WITNESS_PLACEHOLDER ? rgbppWitness : witness));\n\n  return rawTx;\n};\n\n/**\n * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key\n * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer\n * @param ckbRawTx CKB raw transaction\n * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee\n * @param paymasterCell The paymaster cell whose type is IndexerCell is used to pay the extra output cell\n * @param ckbFeeRate The CKB transaction fee rate, default value is 1100\n */\nexport const appendPaymasterCellAndSignCkbTx = async ({\n  secp256k1PrivateKey,\n  ckbRawTx,\n  sumInputsCapacity,\n  paymasterCell,\n  isMainnet,\n  ckbFeeRate,\n}: AppendPaymasterCellAndSignTxParams): Promise<CKBComponents.RawTransaction> => {\n  const rawTx = ckbRawTx as CKBComponents.RawTransactionToSign;\n  const paymasterInput = { previousOutput: paymasterCell.outPoint, since: '0x0' };\n  rawTx.inputs = [...rawTx.inputs, paymasterInput];\n  const inputsCapacity = BigInt(sumInputsCapacity) + BigInt(paymasterCell.output.capacity);\n\n  const sumOutputsCapacity: bigint = rawTx.outputs\n    .map((output) => BigInt(output.capacity))\n    .reduce((prev, current) => prev + current, BigInt(0));\n\n  if (inputsCapacity <= sumOutputsCapacity + MIN_CAPACITY) {\n    throw new InputsCapacityNotEnoughError('The sum of inputs capacity is not enough');\n  }\n\n  let changeCapacity = inputsCapacity - sumOutputsCapacity;\n  const changeOutput = {\n    lock: paymasterCell.output.lock,\n    capacity: append0x(changeCapacity.toString(16)),\n  };\n  rawTx.outputs = [...rawTx.outputs, changeOutput];\n  rawTx.outputsData = [...rawTx.outputsData, '0x'];\n\n  const txSize = getTransactionSize(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  const keyMap = new Map<string, string>();\n  keyMap.set(scriptToHash(paymasterCell.output.lock), secp256k1PrivateKey);\n  keyMap.set(scriptToHash(getRgbppLockScript(isMainnet)), '');\n\n  const paymasterCellIndex = rawTx.inputs.length - 1;\n  const cells = rawTx.inputs.map((input, index) => ({\n    outPoint: input.previousOutput,\n    lock: index === paymasterCellIndex ? paymasterCell.output.lock : getRgbppLockScript(isMainnet),\n  }));\n\n  const emptyWitness = { lock: '', inputType: '', outputType: '' };\n  rawTx.witnesses = [...rawTx.witnesses, emptyWitness];\n\n  const transactionHash = rawTransactionToHash(rawTx);\n  const signedWitnesses = signWitnesses(keyMap)({\n    transactionHash,\n    witnesses: rawTx.witnesses,\n    inputCells: cells,\n    skipMissingKeys: true,\n  });\n\n  const signedTx = {\n    ...rawTx,\n    witnesses: signedWitnesses.map((witness) =>\n      typeof witness !== 'string' ? serializeWitnessArgs(witness) : witness,\n    ),\n  };\n  return signedTx;\n};\n\nexport const sendCkbTx = async ({ collector, signedTx }: SendCkbTxParams) => {\n  const txHash = await collector.getCkb().rpc.sendTransaction(signedTx, 'passthrough');\n  return txHash;\n};\n\n/**\n * Replace the RGBPP_TX_ID_PLACEHOLDER with the real btc tx id of the rgbpp lock args and BTC time lock args\n * @param ckbRawTx CKB raw transaction\n * @param btcTxId The BTC transaction id\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet\n */\nexport const updateCkbTxWithRealBtcTxId = ({\n  ckbRawTx,\n  btcTxId,\n  isMainnet,\n}: UpdateCkbTxWithRealBtcTxIdParams): CKBComponents.RawTransaction => {\n  const outputs = ckbRawTx.outputs.map((output) => {\n    if (isRgbppLockOrBtcTimeLock(output.lock, isMainnet)) {\n      return {\n        ...output,\n        lock: {\n          ...output.lock,\n          args: replaceLockArgsWithRealBtcTxId(output.lock.args, btcTxId),\n        },\n      };\n    }\n    return output;\n  });\n  const newRawTx: CKBComponents.RawTransaction = {\n    ...ckbRawTx,\n    outputs,\n  };\n  return newRawTx;\n};\n","import { RgbppCkbVirtualTx, BtcJumpCkbVirtualTxParams, BtcJumpCkbVirtualTxResult } from '../types/rgbpp';\nimport { TypeAssetNotSupportedError } from '../error';\nimport {\n  append0x,\n  calculateRgbppCellCapacity,\n  calculateTransactionFee,\n  deduplicateList,\n  fetchTypeIdCellDeps,\n  isLockArgsSizeExceeded,\n  isScriptEqual,\n  isUDTTypeSupported,\n  u128ToLe,\n  buildPreLockArgs,\n  calculateCommitment,\n  throwErrorWhenTxInputsExceeded,\n  compareInputs,\n  estimateWitnessSize,\n  genBtcTimeLockScript,\n  genRgbppLockScript,\n  throwErrorWhenRgbppCellsInvalid,\n  isRgbppCapacitySufficientForChange,\n} from '../utils';\nimport { Hex, IndexerCell } from '../types';\nimport { RGBPP_WITNESS_PLACEHOLDER, getSecp256k1CellDep } from '../constants';\nimport { blockchain } from '@ckb-lumos/base';\nimport { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for the jumping tx from BTC to CKB\n * @param collector The collector that collects CKB live cells and transactions\n * @param xudtTypeBytes The serialized hex string of the XUDT type script\n * @param rgbppLockArgsList The rgbpp assets cell lock script args array whose data structure is: out_index | bitcoin_tx_id\n * @param transferAmount The XUDT amount to be transferred\n * @param toCkbAddress The receiver ckb address\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n * @param btcConfirmationBlocks(Optional) The BTC confirmation blocks for BTC Time lock args\n */\nexport const genBtcJumpCkbVirtualTx = async ({\n  collector,\n  xudtTypeBytes,\n  rgbppLockArgsList,\n  transferAmount,\n  toCkbAddress,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n  btcConfirmationBlocks,\n}: BtcJumpCkbVirtualTxParams): Promise<BtcJumpCkbVirtualTxResult> => {\n  const isMainnet = toCkbAddress.startsWith('ckb');\n  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;\n\n  if (!isUDTTypeSupported(xudtType, isMainnet)) {\n    throw new TypeAssetNotSupportedError('The type script asset is not supported now');\n  }\n\n  const deduplicatedLockArgsList = deduplicateList(rgbppLockArgsList);\n\n  const rgbppLocks = deduplicatedLockArgsList.map((args) => genRgbppLockScript(args, isMainnet, btcTestnetType));\n  let rgbppTargetCells: IndexerCell[] = [];\n  let rgbppOtherTypeCells: IndexerCell[] = [];\n  for await (const rgbppLock of rgbppLocks) {\n    const cells = await collector.getCells({ lock: rgbppLock, isDataMustBeEmpty: false });\n\n    throwErrorWhenRgbppCellsInvalid(cells, xudtTypeBytes, isMainnet);\n\n    const targetCells = cells!.filter((cell) => isScriptEqual(cell.output.type!, xudtTypeBytes));\n    const otherTypeCells = cells!.filter((cell) => !isScriptEqual(cell.output.type!, xudtTypeBytes));\n    rgbppTargetCells = [...rgbppTargetCells, ...targetCells];\n    rgbppOtherTypeCells = [...rgbppOtherTypeCells, ...otherTypeCells];\n  }\n  rgbppTargetCells = rgbppTargetCells.sort(compareInputs);\n  rgbppOtherTypeCells = rgbppOtherTypeCells.sort(compareInputs);\n\n  const {\n    inputs,\n    sumInputsCapacity: sumUdtCapacity,\n    sumAmount,\n  } = collector.collectUdtInputs({\n    liveCells: rgbppTargetCells,\n    needAmount: transferAmount,\n  });\n  let sumInputsCapacity = sumUdtCapacity;\n\n  throwErrorWhenTxInputsExceeded(inputs.length);\n\n  const rgbppCellCapacity = calculateRgbppCellCapacity(xudtType);\n\n  const toLock = addressToScript(toCkbAddress);\n  if (isLockArgsSizeExceeded(toLock.args)) {\n    throw new Error('The lock script size of the to ckb address is too large');\n  }\n\n  let needPaymasterCell = false;\n  const needRgbppChange = sumAmount > transferAmount;\n  // To simplify, when the xUDT does not need change, all the capacity of the inputs will be given to the receiver\n  const receiverOutputCapacity = needRgbppChange ? BigInt(rgbppTargetCells[0].output.capacity) : sumInputsCapacity;\n  // The BTC time cell does not need to be bound to the BTC UTXO\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      lock: genBtcTimeLockScript(toLock, isMainnet, btcTestnetType, btcConfirmationBlocks),\n      type: xudtType,\n      capacity: append0x(receiverOutputCapacity.toString(16)),\n    },\n  ];\n  const outputsData = [append0x(u128ToLe(transferAmount))];\n\n  if (needRgbppChange) {\n    const isCapacitySufficient = isRgbppCapacitySufficientForChange(sumInputsCapacity, receiverOutputCapacity);\n    needPaymasterCell = !isCapacitySufficient;\n    // When the capacity of inputs is enough for the outputs, the sender needs to recover the excess capacity.\n    const udtChangeCapacity = isCapacitySufficient ? sumInputsCapacity - receiverOutputCapacity : rgbppCellCapacity;\n    outputs.push({\n      // The Vouts[0] for OP_RETURN and Vouts[1] for RGBPP assets, BTC time cells don't need btc tx out_index\n      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),\n      type: xudtType,\n      capacity: append0x(udtChangeCapacity.toString(16)),\n    });\n    outputsData.push(append0x(u128ToLe(sumAmount - transferAmount)));\n  }\n\n  const targetRgbppOutputLen = outputs.length;\n  for (const [index, otherRgbppCell] of rgbppOtherTypeCells.entries()) {\n    inputs.push({\n      previousOutput: otherRgbppCell.outPoint,\n      since: '0x0',\n    });\n    sumInputsCapacity += BigInt(otherRgbppCell.output.capacity);\n    outputs.push({\n      ...otherRgbppCell.output,\n      // Vouts[targetRgbppOutputLen + 1], ..., Vouts[targetRgbppOutputLen + rgbppOtherTypeCells.length] for other RGBPP assets\n      lock: genRgbppLockScript(buildPreLockArgs(targetRgbppOutputLen + index + 1), isMainnet, btcTestnetType),\n    });\n    outputsData.push(otherRgbppCell.outputData);\n  }\n\n  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true }, btcTestnetType);\n  if (needPaymasterCell) {\n    cellDeps.push(getSecp256k1CellDep(isMainnet));\n  }\n\n  const witnesses: Hex[] = [];\n  const lockArgsSet: Set<string> = new Set();\n  const allRgbppCells = rgbppTargetCells.concat(rgbppOtherTypeCells);\n  for (const cell of allRgbppCells) {\n    if (lockArgsSet.has(cell.output.lock.args)) {\n      witnesses.push('0x');\n    } else {\n      lockArgsSet.add(cell.output.lock.args);\n      witnesses.push(RGBPP_WITNESS_PLACEHOLDER);\n    }\n  }\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  if (!needPaymasterCell) {\n    const txSize =\n      getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? estimateWitnessSize(deduplicatedLockArgsList));\n    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n    const changeCapacity = BigInt(outputs[outputs.length - 1].capacity) - estimatedTxFee;\n    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n  }\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    needPaymasterCell,\n    sumInputsCapacity: append0x(sumInputsCapacity.toString(16)),\n  };\n};\n","import {\n  addressToScript,\n  bytesToHex,\n  getTransactionSize,\n  rawTransactionToHash,\n  scriptToHash,\n  serializeOutPoint,\n  serializeWitnessArgs,\n} from '@nervosnetwork/ckb-sdk-utils';\nimport {\n  BTC_JUMP_CONFIRMATION_BLOCKS,\n  SECP256K1_WITNESS_LOCK_SIZE,\n  getBtcTimeLockScript,\n  getSecp256k1CellDep,\n} from '../constants';\nimport { BTCTimeUnlock } from '../schemas/generated/rgbpp';\nimport { BtcTimeCellStatusParams, BtcTimeCellsParams, Hex, SignBtcTimeCellsTxParams } from '../types';\nimport {\n  append0x,\n  btcTxIdAndAfterFromBtcTimeLockArgs,\n  calculateTransactionFee,\n  compareInputs,\n  fetchTypeIdCellDeps,\n  genBtcTimeLockArgs,\n  lockScriptFromBtcTimeLockArgs,\n  transformSpvProof,\n  buildSpvClientCellDep,\n} from '../utils';\nimport signWitnesses from '@nervosnetwork/ckb-sdk-core/lib/signWitnesses';\n\nexport const buildBtcTimeUnlockWitness = (btcTxProof: Hex): Hex => {\n  const btcTimeUnlock = BTCTimeUnlock.pack({ btcTxProof });\n  return append0x(bytesToHex(btcTimeUnlock));\n};\n\n/**\n * Collect btc time cells and spend them to create xUDT cells for the specific lock scripts in the btc time lock args\n * The btc time lock args data structure is: lock_script | after | new_bitcoin_tx_id\n * @param btcTimeCells The BTC time cells of xUDT\n * @param btcAssetsApi BTC Assets Api\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const buildBtcTimeCellsSpentTx = async ({\n  btcTimeCells,\n  btcAssetsApi,\n  isMainnet,\n  btcTestnetType,\n}: BtcTimeCellsParams): Promise<CKBComponents.RawTransaction> => {\n  const sortedBtcTimeCells = btcTimeCells.sort(compareInputs);\n  const inputs: CKBComponents.CellInput[] = sortedBtcTimeCells.map((cell) => ({\n    previousOutput: cell.outPoint,\n    since: '0x0',\n  }));\n\n  const outputs: CKBComponents.CellOutput[] = sortedBtcTimeCells.map((cell) => ({\n    lock: lockScriptFromBtcTimeLockArgs(cell.output.lock.args),\n    type: cell.output.type,\n    capacity: cell.output.capacity,\n  }));\n\n  const outputsData = sortedBtcTimeCells.map((cell) => cell.outputData);\n\n  const cellDeps: CKBComponents.CellDep[] = await fetchTypeIdCellDeps(\n    isMainnet,\n    { btcTime: true, xudt: true },\n    btcTestnetType,\n  );\n\n  const witnesses: Hex[] = [];\n\n  const lockArgsSet: Set<string> = new Set();\n  const cellDepsSet: Set<string> = new Set();\n  for await (const btcTimeCell of sortedBtcTimeCells) {\n    if (lockArgsSet.has(btcTimeCell.output.lock.args)) {\n      witnesses.push('0x');\n      continue;\n    }\n    lockArgsSet.add(btcTimeCell.output.lock.args);\n    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);\n    const result = await btcAssetsApi.getRgbppSpvProof(btcTxId, after);\n    const { spvClient, proof } = transformSpvProof(result);\n\n    if (!cellDepsSet.has(serializeOutPoint(spvClient))) {\n      cellDeps.push(buildSpvClientCellDep(spvClient));\n      cellDepsSet.add(serializeOutPoint(spvClient));\n    }\n\n    const btcTimeWitness = append0x(\n      serializeWitnessArgs({ lock: buildBtcTimeUnlockWitness(proof), inputType: '', outputType: '' }),\n    );\n    witnesses.push(btcTimeWitness);\n  }\n\n  const ckbTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  return ckbTx;\n};\n\n/**\n * Sign the BTC time cells spent transaction with Secp256k1 private key\n * @param secp256k1PrivateKey The Secp256k1 private key of the master address\n * @param ckbRawTx The CKB raw transaction to be signed\n * @param collector The collector that collects CKB live cells and transactions\n * @param masterCkbAddress The master CKB address\n * @param outputCapacityRange(Optional) [u64; 2], filter cells by output capacity range, [inclusive, exclusive]\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet\n */\nexport const signBtcTimeCellSpentTx = async ({\n  secp256k1PrivateKey,\n  ckbRawTx,\n  collector,\n  masterCkbAddress,\n  isMainnet,\n  outputCapacityRange,\n  ckbFeeRate,\n}: SignBtcTimeCellsTxParams): Promise<CKBComponents.RawTransaction> => {\n  const masterLock = addressToScript(masterCkbAddress);\n  let emptyCells = await collector.getCells({\n    lock: masterLock,\n    outputCapacityRange,\n  });\n  if (!emptyCells || emptyCells.length === 0) {\n    throw new Error('No empty cell found');\n  }\n  emptyCells = emptyCells.filter((cell) => !cell.output.type);\n  const emptyInput: CKBComponents.CellInput = {\n    previousOutput: emptyCells[0].outPoint,\n    since: '0x0',\n  };\n\n  const changeOutput = emptyCells[0].output;\n  const rawTx = {\n    ...ckbRawTx,\n    cellDeps: [...ckbRawTx.cellDeps, getSecp256k1CellDep(isMainnet)],\n    inputs: [emptyInput, ...ckbRawTx.inputs],\n    outputs: [changeOutput, ...ckbRawTx.outputs],\n    outputsData: ['0x', ...ckbRawTx.outputsData],\n    witnesses: [{ lock: '', inputType: '', outputType: '' }, ...ckbRawTx.witnesses],\n  };\n\n  const txSize = getTransactionSize(rawTx) + SECP256K1_WITNESS_LOCK_SIZE;\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n\n  const changeCapacity = BigInt(emptyCells[0].output.capacity) - estimatedTxFee;\n  rawTx.outputs[0].capacity = append0x(changeCapacity.toString(16));\n\n  const keyMap = new Map<string, string>();\n  keyMap.set(scriptToHash(masterLock), secp256k1PrivateKey);\n\n  const cells = rawTx.inputs.map((input, index) => ({\n    outPoint: input.previousOutput,\n    lock: index === 0 ? masterLock : getBtcTimeLockScript(isMainnet),\n  }));\n\n  const transactionHash = rawTransactionToHash(rawTx);\n  const signedWitnesses = signWitnesses(keyMap)({\n    transactionHash,\n    witnesses: rawTx.witnesses,\n    inputCells: cells,\n    skipMissingKeys: true,\n  });\n\n  const signedTx = {\n    ...rawTx,\n    witnesses: signedWitnesses.map((witness) =>\n      typeof witness !== 'string' ? serializeWitnessArgs(witness) : witness,\n    ),\n  } as CKBComponents.RawTransaction;\n\n  return signedTx;\n};\n\n/**\n * Check if the BTC time cells have been spent. If so, it means the RGB++ asset jumping(from BTC to CKB) has been successful.\n * @param collector The collector that collects CKB live cells and transactions\n * @param ckbAddress The CKB address\n * @param btcTxId The BTC transaction id\n */\nexport const isBtcTimeCellsSpent = async ({\n  collector,\n  ckbAddress,\n  btcTxId,\n  btcTestnetType,\n}: BtcTimeCellStatusParams): Promise<boolean> => {\n  const isMainnet = ckbAddress.startsWith('ckb');\n  const lock = addressToScript(ckbAddress);\n  const btcTimeLock: CKBComponents.Script = {\n    ...getBtcTimeLockScript(isMainnet, btcTestnetType),\n    args: genBtcTimeLockArgs(lock, btcTxId, BTC_JUMP_CONFIRMATION_BLOCKS),\n  };\n  const btcTimeCells = await collector.getCells({ lock: btcTimeLock, isDataMustBeEmpty: false });\n  const isSpent = !btcTimeCells || btcTimeCells.length === 0;\n  return isSpent;\n};\n","import { CkbBatchJumpBtcVirtualTxParams, CkbJumpBtcVirtualTxParams } from '../types/rgbpp';\nimport { NoLiveCellError, NoXudtLiveCellError, TypeAssetNotSupportedError } from '../error';\nimport {\n  append0x,\n  calculateRgbppCellCapacity,\n  calculateTransactionFee,\n  calculateUdtCellCapacity,\n  fetchTypeIdCellDeps,\n  isTypeAssetSupported,\n  u128ToLe,\n  genRgbppLockScript,\n} from '../utils';\nimport { MAX_FEE, MIN_CAPACITY, RGBPP_TX_WITNESS_MAX_SIZE } from '../constants';\nimport { blockchain } from '@ckb-lumos/base';\nimport { addressToScript, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for the jumping tx from CKB to BTC\n * @param collector The collector that collects CKB live cells and transactions\n * @param xudtTypeBytes The serialized hex string of the XUDT type script\n * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx\n * @param toRgbppLockArgs The receiver rgbpp lock script args whose data structure is: out_index | bitcoin_tx_id\n * @param transferAmount The XUDT amount to be transferred\n * @param witnessLockPlaceholderSize(Optional)  The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional)  The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional)  The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genCkbJumpBtcVirtualTx = async ({\n  collector,\n  xudtTypeBytes,\n  fromCkbAddress,\n  toRgbppLockArgs,\n  transferAmount,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: CkbJumpBtcVirtualTxParams): Promise<CKBComponents.RawTransaction> => {\n  const isMainnet = fromCkbAddress.startsWith('ckb');\n  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;\n  if (!isTypeAssetSupported(xudtType, isMainnet)) {\n    throw new TypeAssetNotSupportedError('The type script asset is not supported now');\n  }\n\n  const fromLock = addressToScript(fromCkbAddress);\n\n  const xudtCells = await collector.getCells({ lock: fromLock, type: xudtType });\n  if (!xudtCells || xudtCells.length === 0) {\n    throw new NoXudtLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');\n  }\n\n  const collected = collector.collectUdtInputs({\n    liveCells: xudtCells,\n    needAmount: transferAmount,\n  });\n\n  let { inputs, sumInputsCapacity } = collected;\n  const { sumAmount } = collected;\n\n  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);\n  const outputsData = [append0x(u128ToLe(transferAmount))];\n\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      lock: genRgbppLockScript(toRgbppLockArgs, isMainnet, btcTestnetType),\n      type: xudtType,\n      capacity: append0x(rpbppCellCapacity.toString(16)),\n    },\n  ];\n\n  const txFee = MAX_FEE;\n  const xudtCellCapacity = calculateUdtCellCapacity(fromLock, xudtType);\n  if (sumInputsCapacity < xudtCellCapacity + rpbppCellCapacity + MIN_CAPACITY + txFee) {\n    let emptyCells = await collector.getCells({ lock: fromLock });\n    if (!emptyCells || emptyCells.length === 0) {\n      throw new NoLiveCellError('The address has no empty cells');\n    }\n    emptyCells = emptyCells.filter((cell) => !cell.output.type);\n    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(\n      emptyCells,\n      rpbppCellCapacity,\n      txFee,\n    );\n    inputs = [...emptyInputs, ...inputs];\n    sumInputsCapacity += sumEmptyCapacity;\n  }\n\n  let changeCapacity = sumInputsCapacity - rpbppCellCapacity - txFee;\n  if (sumAmount > transferAmount) {\n    outputs.push({\n      lock: fromLock,\n      type: xudtType,\n      capacity: append0x(xudtCellCapacity.toString(16)),\n    });\n    outputsData.push(append0x(u128ToLe(sumAmount - transferAmount)));\n    changeCapacity -= xudtCellCapacity;\n  }\n  outputs.push({\n    lock: fromLock,\n    capacity: append0x(changeCapacity.toString(16)),\n  });\n  outputsData.push('0x');\n\n  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { xudt: true });\n  const witnesses = inputs.map(() => '0x');\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  if (txFee === MAX_FEE) {\n    const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);\n    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));\n  }\n\n  return ckbRawTx;\n};\n\n/**\n * Generate a virtual ckb transaction to realize a batch jump of assets from CKB to BTC\n * @param collector The collector that collects CKB live cells and transactions\n * @param xudtTypeBytes The serialized hex string of the XUDT type script\n * @param fromCkbAddress The from ckb address who will use his private key to sign the ckb tx\n * @param rgbppReceivers The rgbpp receiver list which include toRgbppLockArgs and transferAmount\n * @param witnessLockPlaceholderSize(Optional)  The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional)  The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genCkbBatchJumpBtcVirtualTx = async ({\n  collector,\n  xudtTypeBytes,\n  fromCkbAddress,\n  rgbppReceivers,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: CkbBatchJumpBtcVirtualTxParams): Promise<CKBComponents.RawTransaction> => {\n  const isMainnet = fromCkbAddress.startsWith('ckb');\n  const xudtType = blockchain.Script.unpack(xudtTypeBytes) as CKBComponents.Script;\n  if (!isTypeAssetSupported(xudtType, isMainnet)) {\n    throw new TypeAssetNotSupportedError('The type script asset is not supported now');\n  }\n\n  const fromLock = addressToScript(fromCkbAddress);\n\n  const xudtCells = await collector.getCells({ lock: fromLock, type: xudtType });\n  if (!xudtCells || xudtCells.length === 0) {\n    throw new NoXudtLiveCellError('No rgbpp cells found with the xudt type script and the rgbpp lock args');\n  }\n\n  const sumTransferAmount = rgbppReceivers\n    .map((receiver) => receiver.transferAmount)\n    .reduce((prev, current) => prev + current, BigInt(0));\n\n  const collected = collector.collectUdtInputs({\n    liveCells: xudtCells,\n    needAmount: sumTransferAmount,\n  });\n\n  let { inputs, sumInputsCapacity } = collected;\n  const { sumAmount } = collected;\n\n  const rpbppCellCapacity = calculateRgbppCellCapacity(xudtType);\n  const sumRgbppCellCapacity = rpbppCellCapacity * BigInt(rgbppReceivers.length);\n  const outputs: CKBComponents.CellOutput[] = rgbppReceivers.map((receiver) => ({\n    lock: genRgbppLockScript(receiver.toRgbppLockArgs, isMainnet, btcTestnetType),\n    type: xudtType,\n    capacity: append0x(rpbppCellCapacity.toString(16)),\n  }));\n  const outputsData = rgbppReceivers.map((receiver) => append0x(u128ToLe(receiver.transferAmount)));\n\n  const txFee = MAX_FEE;\n  const xudtCellCapacity = calculateUdtCellCapacity(fromLock, xudtType);\n  if (sumInputsCapacity < xudtCellCapacity + sumRgbppCellCapacity + MIN_CAPACITY + txFee) {\n    let emptyCells = await collector.getCells({ lock: fromLock });\n    if (!emptyCells || emptyCells.length === 0) {\n      throw new NoLiveCellError('The address has no empty cells');\n    }\n    emptyCells = emptyCells.filter((cell) => !cell.output.type);\n    const { inputs: emptyInputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(\n      emptyCells,\n      rpbppCellCapacity,\n      txFee,\n    );\n    inputs = [...emptyInputs, ...inputs];\n    sumInputsCapacity += sumEmptyCapacity;\n  }\n\n  let changeCapacity = sumInputsCapacity - sumRgbppCellCapacity - txFee;\n  if (sumAmount > sumTransferAmount) {\n    outputs.push({\n      lock: fromLock,\n      type: xudtType,\n      capacity: append0x(xudtCellCapacity.toString(16)),\n    });\n    outputsData.push(append0x(u128ToLe(sumAmount - sumTransferAmount)));\n    changeCapacity -= xudtCellCapacity;\n  }\n  outputs.push({\n    lock: fromLock,\n    capacity: append0x(changeCapacity.toString(16)),\n  });\n  outputsData.push('0x');\n\n  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { xudt: true });\n  const witnesses = inputs.map(() => '0x');\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  if (txFee === MAX_FEE) {\n    const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n    const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n    const estimatedChangeCapacity = changeCapacity + (MAX_FEE - estimatedTxFee);\n    ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(estimatedChangeCapacity.toString(16));\n  }\n\n  return ckbRawTx;\n};\n","import { RgbppCkbVirtualTx, RgbppLaunchCkbVirtualTxParams, RgbppLaunchVirtualTxResult } from '../types/rgbpp';\nimport { NoLiveCellError } from '../error';\nimport {\n  append0x,\n  calculateRgbppTokenInfoCellCapacity,\n  calculateTransactionFee,\n  fetchTypeIdCellDeps,\n  generateUniqueTypeArgs,\n  u128ToLe,\n  buildPreLockArgs,\n  calculateCommitment,\n  encodeRgbppTokenInfo,\n  genBtcTimeLockScript,\n  genRgbppLockScript,\n} from '../utils';\nimport { Hex } from '../types';\nimport {\n  MAX_FEE,\n  RGBPP_TX_WITNESS_MAX_SIZE,\n  RGBPP_WITNESS_PLACEHOLDER,\n  getXudtTypeScript,\n  getUniqueTypeScript,\n  UNLOCKABLE_LOCK_SCRIPT,\n} from '../constants';\nimport { getTransactionSize, scriptToHash } from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for the btc transfer tx\n * @param collector The collector that collects CKB live cells and transactions\n * @param ownerRgbppLockArgs The owner RGBPP lock args whose data structure is: out_index | bitcoin_tx_id\n * @param launchAmount The total amount of RGBPP assets issued\n * @param rgbppTokenInfo The RGBPP token info https://github.com/ckb-cell/unique-cell?tab=readme-ov-file#xudt-information\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genRgbppLaunchCkbVirtualTx = async ({\n  collector,\n  ownerRgbppLockArgs,\n  launchAmount,\n  rgbppTokenInfo,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  isMainnet,\n  btcTestnetType,\n}: RgbppLaunchCkbVirtualTxParams): Promise<RgbppLaunchVirtualTxResult> => {\n  const ownerLock = genRgbppLockScript(ownerRgbppLockArgs, isMainnet, btcTestnetType);\n  let emptyCells = await collector.getCells({ lock: ownerLock });\n  if (!emptyCells || emptyCells.length === 0) {\n    throw new NoLiveCellError('The owner address has no empty cells');\n  }\n  emptyCells = emptyCells.filter((cell) => !cell.output.type);\n  const infoCellCapacity = calculateRgbppTokenInfoCellCapacity(rgbppTokenInfo, isMainnet);\n\n  const txFee = MAX_FEE;\n  const { inputs, sumInputsCapacity } = collector.collectInputs(emptyCells, infoCellCapacity, txFee);\n\n  let rgbppCellCapacity = sumInputsCapacity - infoCellCapacity;\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),\n      type: {\n        ...getXudtTypeScript(isMainnet),\n        args: append0x(scriptToHash(ownerLock)),\n      },\n      capacity: append0x(rgbppCellCapacity.toString(16)),\n    },\n    {\n      lock: genBtcTimeLockScript(UNLOCKABLE_LOCK_SCRIPT, isMainnet, btcTestnetType),\n      type: {\n        ...getUniqueTypeScript(isMainnet),\n        args: generateUniqueTypeArgs(inputs[0], 1),\n      },\n      capacity: append0x(infoCellCapacity.toString(16)),\n    },\n  ];\n\n  const outputsData = [append0x(u128ToLe(launchAmount)), encodeRgbppTokenInfo(rgbppTokenInfo)];\n  const cellDeps = await fetchTypeIdCellDeps(isMainnet, { rgbpp: true, xudt: true, unique: true }, btcTestnetType);\n\n  const witnesses: Hex[] = inputs.map((_, index) => (index === 0 ? RGBPP_WITNESS_PLACEHOLDER : '0x'));\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  rgbppCellCapacity -= estimatedTxFee;\n  ckbRawTx.outputs[0].capacity = append0x(rgbppCellCapacity.toString(16));\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n    outputs: ckbRawTx.outputs,\n  };\n\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    needPaymasterCell: false,\n  };\n};\n","import { packRawClusterData } from '@spore-sdk/core';\nimport { RgbppCkbVirtualTx } from '../types/rgbpp';\nimport {\n  append0x,\n  calculateTransactionFee,\n  fetchTypeIdCellDeps,\n  buildPreLockArgs,\n  calculateCommitment,\n  genRgbppLockScript,\n  generateClusterCreateCoBuild,\n  generateClusterId,\n} from '../utils';\nimport { CreateClusterCkbVirtualTxParams, Hex, SporeVirtualTxResult } from '../types';\nimport {\n  RGBPP_TX_WITNESS_MAX_SIZE,\n  RGBPP_WITNESS_PLACEHOLDER,\n  getClusterTypeDep,\n  getClusterTypeScript,\n} from '../constants';\nimport { NoRgbppLiveCellError } from '../error';\nimport { bytesToHex, getTransactionSize } from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for creating cluster\n * @param collector The collector that collects CKB live cells and transactions\n * @param rgbppLockArgs The rgbpp assets cell lock script args whose data structure is: out_index | bitcoin_tx_id\n * @param clusterData The cluster's data, including name and description.\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genCreateClusterCkbVirtualTx = async ({\n  collector,\n  rgbppLockArgs,\n  clusterData,\n  isMainnet,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: CreateClusterCkbVirtualTxParams): Promise<SporeVirtualTxResult> => {\n  const rgbppLock = genRgbppLockScript(rgbppLockArgs, isMainnet, btcTestnetType);\n  const rgbppCells = await collector.getCells({ lock: rgbppLock });\n  if (!rgbppCells || rgbppCells.length === 0) {\n    throw new NoRgbppLiveCellError('No rgbpp cells found with the rgbpp lock args');\n  }\n  const rgbppCell = rgbppCells[0];\n\n  const inputs: CKBComponents.CellInput[] = [\n    {\n      previousOutput: rgbppCell.outPoint,\n      since: '0x0',\n    },\n  ];\n\n  const clusterId = generateClusterId(inputs[0], 0);\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      ...rgbppCell.output,\n      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster\n      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),\n      type: {\n        ...getClusterTypeScript(isMainnet),\n        args: clusterId,\n      },\n    },\n  ];\n  const outputsData: Hex[] = [bytesToHex(packRawClusterData(clusterData))];\n  const cellDeps = [\n    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType)),\n    getClusterTypeDep(isMainnet),\n  ];\n  const sporeCoBuild = generateClusterCreateCoBuild(outputs[0], outputsData[0]);\n  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  let changeCapacity = BigInt(rgbppCell.output.capacity);\n  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n\n  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    clusterId,\n    needPaymasterCell: false,\n  };\n};\n","import { RgbppCkbVirtualTx } from '../types/rgbpp';\nimport { packRawSporeData } from '@spore-sdk/core';\nimport {\n  append0x,\n  calculateRgbppSporeCellCapacity,\n  calculateTransactionFee,\n  fetchTypeIdCellDeps,\n  isClusterSporeTypeSupported,\n  buildPreLockArgs,\n  calculateCommitment,\n  genRgbppLockScript,\n  generateSporeCreateCoBuild,\n  generateSporeId,\n  generateSporeTransferCoBuild,\n  throwErrorWhenSporeCellsInvalid,\n} from '../utils';\nimport {\n  AppendIssuerCellToSporeCreate,\n  BuildAppendingIssuerCellTxParams,\n  CreateSporeCkbVirtualTxParams,\n  Hex,\n  SporeCreateVirtualTxResult,\n  SporeTransferVirtualTxResult,\n  TransferSporeCkbVirtualTxParams,\n} from '../types';\nimport {\n  MAX_FEE,\n  MIN_CAPACITY,\n  RGBPP_TX_WITNESS_MAX_SIZE,\n  RGBPP_WITNESS_PLACEHOLDER,\n  SECP256K1_WITNESS_LOCK_SIZE,\n  getClusterTypeDep,\n  getRgbppLockScript,\n  getSecp256k1CellDep,\n  getSporeTypeDep,\n  getSporeTypeScript,\n} from '../constants';\nimport {\n  NoLiveCellError,\n  NoRgbppLiveCellError,\n  RgbppUtxoBindMultiTypeAssetsError,\n  TypeAssetNotSupportedError,\n} from '../error';\nimport signWitnesses from '@nervosnetwork/ckb-sdk-core/lib/signWitnesses';\nimport {\n  addressToScript,\n  bytesToHex,\n  getTransactionSize,\n  rawTransactionToHash,\n  scriptToHash,\n  serializeWitnessArgs,\n} from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for creating spores\n * @param collector The collector that collects CKB live cells and transactions\n * @param clusterRgbppLockArgs The cluster rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id\n * @param sporeDataList The spore's data list, including name and description.\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genCreateSporeCkbVirtualTx = async ({\n  collector,\n  clusterRgbppLockArgs,\n  sporeDataList,\n  isMainnet,\n  btcTestnetType,\n}: CreateSporeCkbVirtualTxParams): Promise<SporeCreateVirtualTxResult> => {\n  const clusterRgbppLock = genRgbppLockScript(clusterRgbppLockArgs, isMainnet, btcTestnetType);\n  const clusterCells = await collector.getCells({ lock: clusterRgbppLock, isDataMustBeEmpty: false });\n  if (!clusterCells || clusterCells.length === 0) {\n    throw new NoRgbppLiveCellError('No cluster rgbpp cells found with the cluster rgbpp lock args');\n  }\n  if (clusterCells.length > 1) {\n    throw new RgbppUtxoBindMultiTypeAssetsError('The BTC UTXO must not be bound to multiple CKB cells');\n  }\n  const clusterCell = clusterCells[0];\n\n  if (!clusterCell.output.type || !isClusterSporeTypeSupported(clusterCell.output.type, isMainnet)) {\n    throw new TypeAssetNotSupportedError('The type script asset is not supported now');\n  }\n\n  const sumInputsCapacity = clusterCell.output.capacity;\n\n  const inputs: CKBComponents.CellInput[] = [\n    {\n      previousOutput: clusterCell.outPoint,\n      since: '0x0',\n    },\n  ];\n\n  const clusterCellDep: CKBComponents.CellDep = {\n    outPoint: clusterCell.outPoint,\n    depType: 'code',\n  };\n\n  const sporeOutputs = sporeDataList.map((data, index) => ({\n    // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster and Vouts[2]... for spore\n    lock: genRgbppLockScript(buildPreLockArgs(index + 2), isMainnet, btcTestnetType),\n    type: {\n      ...getSporeTypeScript(isMainnet),\n      // The CKB transaction outputs[0] fro cluster and outputs[1]... for spore\n      args: generateSporeId(inputs[0], index + 1),\n    },\n    capacity: append0x(calculateRgbppSporeCellCapacity(data).toString(16)),\n  }));\n  const sporeOutputsData = sporeDataList.map((data) => bytesToHex(packRawSporeData(data)));\n\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      ...clusterCell.output,\n      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for cluster\n      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),\n    },\n    ...sporeOutputs,\n  ];\n  const outputsData: Hex[] = [clusterCell.outputData, ...sporeOutputsData];\n  const cellDeps = [\n    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType)),\n    getClusterTypeDep(isMainnet),\n    getSporeTypeDep(isMainnet),\n    clusterCellDep,\n  ];\n  const sporeCoBuild = generateSporeCreateCoBuild({\n    sporeOutputs,\n    sporeOutputsData,\n    clusterCell,\n    clusterOutputCell: outputs[0],\n  });\n  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    sumInputsCapacity,\n    clusterCell,\n    needPaymasterCell: false,\n  };\n};\n\nconst CELL_DEP_SIZE = 32 + 4 + 1;\n\n/**\n * Append paymaster cell to the ckb transaction inputs and build the raw tx to be signed for spores creation\n * @param issuerAddress The issuer ckb address\n * @param collector The collector that collects CKB live cells and transactions\n * @param ckbRawTx CKB raw transaction\n * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 65\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n */\nexport const buildAppendingIssuerCellToSporesCreateTx = async ({\n  issuerAddress,\n  collector,\n  ckbRawTx,\n  sumInputsCapacity,\n  witnessLockPlaceholderSize = SECP256K1_WITNESS_LOCK_SIZE,\n  ckbFeeRate,\n}: BuildAppendingIssuerCellTxParams): Promise<CKBComponents.RawTransactionToSign> => {\n  const rawTx = ckbRawTx as CKBComponents.RawTransactionToSign;\n\n  const sumOutputsCapacity: bigint = rawTx.outputs\n    .map((output) => BigInt(output.capacity))\n    .reduce((prev, current) => prev + current, BigInt(0));\n\n  const issuerLock = addressToScript(issuerAddress);\n  let emptyCells = await collector.getCells({ lock: issuerLock });\n  if (!emptyCells || emptyCells.length === 0) {\n    throw new NoLiveCellError('The issuer address has no empty cells');\n  }\n  emptyCells = emptyCells.filter((cell) => !cell.output.type);\n\n  let actualInputsCapacity = BigInt(sumInputsCapacity);\n  const txFee = MAX_FEE;\n  if (actualInputsCapacity <= sumOutputsCapacity) {\n    const needCapacity = sumOutputsCapacity - actualInputsCapacity + MIN_CAPACITY;\n    const { inputs, sumInputsCapacity: sumEmptyCapacity } = collector.collectInputs(emptyCells, needCapacity, txFee);\n    rawTx.inputs = [...rawTx.inputs, ...inputs];\n    actualInputsCapacity += sumEmptyCapacity;\n  }\n\n  let changeCapacity = actualInputsCapacity - sumOutputsCapacity;\n  const changeOutput = {\n    lock: issuerLock,\n    capacity: append0x(changeCapacity.toString(16)),\n  };\n  rawTx.outputs = [...rawTx.outputs, changeOutput];\n  rawTx.outputsData = [...rawTx.outputsData, '0x'];\n\n  const txSize = getTransactionSize(rawTx) + witnessLockPlaceholderSize + CELL_DEP_SIZE;\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n  rawTx.outputs[rawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  return rawTx;\n};\n\n/**\n * Append paymaster cell to the ckb transaction inputs and sign the transaction with paymaster cell's secp256k1 private key\n * @param secp256k1PrivateKey The Secp256k1 private key of the paymaster cells maintainer\n * @param issuerAddress The issuer ckb address\n * @param collector The collector that collects CKB live cells and transactions\n * @param ckbRawTx CKB raw transaction\n * @param sumInputsCapacity The sum capacity of ckb inputs which is to be used to calculate ckb tx fee\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n */\nexport const appendIssuerCellToSporesCreate = async ({\n  secp256k1PrivateKey,\n  issuerAddress,\n  collector,\n  ckbRawTx,\n  sumInputsCapacity,\n  isMainnet,\n  ckbFeeRate,\n}: AppendIssuerCellToSporeCreate): Promise<CKBComponents.RawTransaction> => {\n  const rgbppInputsLength = ckbRawTx.inputs.length;\n\n  const rawTx = await buildAppendingIssuerCellToSporesCreateTx({\n    issuerAddress,\n    collector,\n    ckbRawTx,\n    sumInputsCapacity,\n    ckbFeeRate,\n  });\n\n  rawTx.cellDeps = [...rawTx.cellDeps, getSecp256k1CellDep(isMainnet)];\n\n  const issuerLock = addressToScript(issuerAddress);\n\n  const keyMap = new Map<string, string>();\n  keyMap.set(scriptToHash(issuerLock), secp256k1PrivateKey);\n\n  const issuerCellIndex = rgbppInputsLength;\n  const cells = rawTx.inputs.map((input, index) => ({\n    outPoint: input.previousOutput,\n    lock: index >= issuerCellIndex ? issuerLock : getRgbppLockScript(isMainnet),\n  }));\n\n  const emptyWitness = { lock: '', inputType: '', outputType: '' };\n  const issuerWitnesses = rawTx.inputs.slice(rgbppInputsLength).map((_, index) => (index === 0 ? emptyWitness : '0x'));\n\n  const lastRawTxWitnessIndex = rawTx.witnesses.length - 1;\n  rawTx.witnesses = [\n    ...rawTx.witnesses.slice(0, lastRawTxWitnessIndex),\n    ...issuerWitnesses,\n    // The cobuild witness will be placed to the tail of the witnesses\n    rawTx.witnesses[lastRawTxWitnessIndex],\n  ];\n\n  const transactionHash = rawTransactionToHash(rawTx);\n  const signedWitnesses = signWitnesses(keyMap)({\n    transactionHash,\n    witnesses: rawTx.witnesses,\n    inputCells: cells,\n    skipMissingKeys: true,\n  });\n\n  const signedTx = {\n    ...rawTx,\n    witnesses: signedWitnesses.map((witness) =>\n      typeof witness !== 'string' ? serializeWitnessArgs(witness) : witness,\n    ),\n  };\n  return signedTx;\n};\n\n/**\n * Generate the virtual ckb transaction for transferring spore\n * @param collector The collector that collects CKB live cells and transactions\n * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id\n * @param sporeTypeBytes The spore type script serialized bytes\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genTransferSporeCkbVirtualTx = async ({\n  collector,\n  sporeRgbppLockArgs,\n  sporeTypeBytes,\n  isMainnet,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: TransferSporeCkbVirtualTxParams): Promise<SporeTransferVirtualTxResult> => {\n  const sporeRgbppLock = genRgbppLockScript(sporeRgbppLockArgs, isMainnet, btcTestnetType);\n  const sporeCells = await collector.getCells({ lock: sporeRgbppLock, isDataMustBeEmpty: false });\n\n  throwErrorWhenSporeCellsInvalid(sporeCells, sporeTypeBytes, isMainnet);\n\n  const sporeCell = sporeCells![0];\n\n  const inputs: CKBComponents.CellInput[] = [\n    {\n      previousOutput: sporeCell.outPoint,\n      since: '0x0',\n    },\n  ];\n\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      ...sporeCell.output,\n      // The BTC transaction Vouts[0] for OP_RETURN, Vouts[1] for spore\n      lock: genRgbppLockScript(buildPreLockArgs(1), isMainnet, btcTestnetType),\n    },\n  ];\n  const outputsData: Hex[] = [sporeCell.outputData];\n  const cellDeps = [\n    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType)),\n    getSporeTypeDep(isMainnet),\n  ];\n  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);\n  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  let changeCapacity = BigInt(sporeCell.output.capacity);\n  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n\n  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    sporeCell,\n    needPaymasterCell: false,\n    sumInputsCapacity: sporeCell.output.capacity,\n  };\n};\n","import { BtcTimeCellsParams, RgbppCkbVirtualTx } from '../types/rgbpp';\nimport {\n  btcTxIdAndAfterFromBtcTimeLockArgs,\n  buildSpvClientCellDep,\n  calculateCommitment,\n  compareInputs,\n  genBtcTimeLockScript,\n  lockScriptFromBtcTimeLockArgs,\n  transformSpvProof,\n  generateSporeTransferCoBuild,\n  throwErrorWhenSporeCellsInvalid,\n  append0x,\n  fetchTypeIdCellDeps,\n  calculateTransactionFee,\n} from '../utils';\nimport {\n  Hex,\n  LeapSporeFromBtcToCkbVirtualTxParams,\n  LeapSporeFromCkbToBtcVirtualTxParams,\n  SporeLeapVirtualTxResult,\n} from '../types';\nimport {\n  RGBPP_TX_WITNESS_MAX_SIZE,\n  RGBPP_WITNESS_PLACEHOLDER,\n  getRgbppLockScript,\n  getSporeTypeDep,\n} from '../constants';\nimport { NoRgbppLiveCellError } from '../error';\nimport { buildBtcTimeUnlockWitness } from '../rgbpp';\nimport { blockchain } from '@ckb-lumos/base';\nimport {\n  addressToScript,\n  getTransactionSize,\n  serializeOutPoint,\n  serializeWitnessArgs,\n} from '@nervosnetwork/ckb-sdk-utils';\n\n/**\n * Generate the virtual ckb transaction for leaping spore from BTC to CKB\n * @param collector The collector that collects CKB live cells and transactions\n * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id\n * @param sporeTypeBytes The spore type script serialized bytes\n * @param toCkbAddress The receiver ckb address\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const genLeapSporeFromBtcToCkbVirtualTx = async ({\n  collector,\n  sporeRgbppLockArgs,\n  sporeTypeBytes,\n  toCkbAddress,\n  isMainnet,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: LeapSporeFromBtcToCkbVirtualTxParams): Promise<SporeLeapVirtualTxResult> => {\n  const sporeRgbppLock = {\n    ...getRgbppLockScript(isMainnet, btcTestnetType),\n    args: append0x(sporeRgbppLockArgs),\n  };\n  const sporeCells = await collector.getCells({ lock: sporeRgbppLock, isDataMustBeEmpty: false });\n\n  throwErrorWhenSporeCellsInvalid(sporeCells, sporeTypeBytes, isMainnet);\n\n  const sporeCell = sporeCells![0];\n\n  const inputs: CKBComponents.CellInput[] = [\n    {\n      previousOutput: sporeCell.outPoint,\n      since: '0x0',\n    },\n  ];\n\n  const toLock = addressToScript(toCkbAddress);\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      ...sporeCell.output,\n      lock: genBtcTimeLockScript(toLock, isMainnet, btcTestnetType),\n    },\n  ];\n  const outputsData: Hex[] = [sporeCell.outputData];\n  const cellDeps = [\n    ...(await fetchTypeIdCellDeps(isMainnet, { rgbpp: true }, btcTestnetType)),\n    getSporeTypeDep(isMainnet),\n  ];\n  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);\n  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  let changeCapacity = BigInt(sporeCell.output.capacity);\n  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n\n  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  const virtualTx: RgbppCkbVirtualTx = {\n    ...ckbRawTx,\n  };\n  const commitment = calculateCommitment(virtualTx);\n\n  return {\n    ckbRawTx,\n    commitment,\n    sporeCell,\n    needPaymasterCell: false,\n    sumInputsCapacity: sporeCell.output.capacity,\n  };\n};\n\n/**\n * Collect btc time cells and spend them to create spore cells for the specific lock scripts in the btc time lock args\n * The btc time lock args data structure is: lock_script | after | new_bitcoin_tx_id\n * @param btcTimeCells The BTC time cells of spore\n * @param btcAssetsApi BTC Assets Api\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet(see btcTestnetType for details about BTC Testnet)\n * @param btcTestnetType(Optional) The Bitcoin Testnet type including Testnet3 and Signet, default value is Testnet3\n */\nexport const buildSporeBtcTimeCellsSpentTx = async ({\n  btcTimeCells,\n  btcAssetsApi,\n  isMainnet,\n  btcTestnetType,\n}: BtcTimeCellsParams): Promise<CKBComponents.RawTransaction> => {\n  const sortedBtcTimeCells = btcTimeCells.sort(compareInputs);\n  const inputs: CKBComponents.CellInput[] = sortedBtcTimeCells.map((cell) => ({\n    previousOutput: cell.outPoint,\n    since: '0x0',\n  }));\n\n  const outputs: CKBComponents.CellOutput[] = sortedBtcTimeCells.map((cell) => ({\n    lock: lockScriptFromBtcTimeLockArgs(cell.output.lock.args),\n    type: cell.output.type,\n    capacity: cell.output.capacity,\n  }));\n\n  const outputsData = sortedBtcTimeCells.map((cell) => cell.outputData);\n\n  const cellDeps: CKBComponents.CellDep[] = [\n    ...(await fetchTypeIdCellDeps(isMainnet, { btcTime: true }, btcTestnetType)),\n    getSporeTypeDep(isMainnet),\n  ];\n\n  const witnesses: Hex[] = [];\n\n  const lockArgsSet: Set<string> = new Set();\n  const cellDepsSet: Set<string> = new Set();\n  for await (const btcTimeCell of sortedBtcTimeCells) {\n    if (lockArgsSet.has(btcTimeCell.output.lock.args)) {\n      witnesses.push('0x');\n      continue;\n    }\n    lockArgsSet.add(btcTimeCell.output.lock.args);\n    const { btcTxId, after } = btcTxIdAndAfterFromBtcTimeLockArgs(btcTimeCell.output.lock.args);\n    const result = await btcAssetsApi.getRgbppSpvProof(btcTxId, after);\n    const { spvClient, proof } = transformSpvProof(result);\n\n    if (!cellDepsSet.has(serializeOutPoint(spvClient))) {\n      cellDeps.push(buildSpvClientCellDep(spvClient));\n      cellDepsSet.add(serializeOutPoint(spvClient));\n    }\n\n    const btcTimeWitness = append0x(\n      serializeWitnessArgs({ lock: buildBtcTimeUnlockWitness(proof), inputType: '', outputType: '' }),\n    );\n    witnesses.push(btcTimeWitness);\n  }\n\n  const sporeCoBuild = generateSporeTransferCoBuild(sortedBtcTimeCells, outputs);\n  witnesses.push(sporeCoBuild);\n\n  const ckbTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  return ckbTx;\n};\n\n/**\n * Generate the virtual ckb transaction for leaping spore from CKB to BTC\n * @param collector The collector that collects CKB live cells and transactions\n * @param sporeRgbppLockArgs The spore rgbpp cell lock script args whose data structure is: out_index | bitcoin_tx_id\n * @param sporeTypeBytes The spore type script serialized bytes\n * @param toCkbAddress The receiver ckb address\n * @param isMainnet True is for BTC and CKB Mainnet, false is for BTC and CKB Testnet\n * @param witnessLockPlaceholderSize(Optional) The WitnessArgs.lock placeholder bytes array size and the default value is 5000\n * @param ckbFeeRate(Optional) The CKB transaction fee rate, default value is 1100\n */\nexport const genLeapSporeFromCkbToBtcRawTx = async ({\n  collector,\n  sporeTypeBytes,\n  fromCkbAddress,\n  toRgbppLockArgs,\n  isMainnet,\n  witnessLockPlaceholderSize,\n  ckbFeeRate,\n  btcTestnetType,\n}: LeapSporeFromCkbToBtcVirtualTxParams): Promise<CKBComponents.RawTransaction> => {\n  const fromLock = addressToScript(fromCkbAddress);\n  const sporeType = blockchain.Script.unpack(sporeTypeBytes) as CKBComponents.Script;\n  const sporeCells = await collector.getCells({ lock: fromLock, type: sporeType });\n  if (!sporeCells || sporeCells.length === 0) {\n    throw new NoRgbppLiveCellError('No spore rgbpp cells found with the spore rgbpp lock args and spore type script');\n  }\n  const sporeCell = sporeCells[0];\n\n  const inputs: CKBComponents.CellInput[] = [\n    {\n      previousOutput: sporeCell.outPoint,\n      since: '0x0',\n    },\n  ];\n\n  const outputs: CKBComponents.CellOutput[] = [\n    {\n      ...sporeCell.output,\n      lock: {\n        ...getRgbppLockScript(isMainnet, btcTestnetType),\n        args: append0x(toRgbppLockArgs),\n      },\n    },\n  ];\n  const outputsData: Hex[] = [sporeCell.outputData];\n  const cellDeps = [getSporeTypeDep(isMainnet)];\n  const sporeCoBuild = generateSporeTransferCoBuild([sporeCell], outputs);\n  const witnesses = [RGBPP_WITNESS_PLACEHOLDER, sporeCoBuild];\n\n  const ckbRawTx: CKBComponents.RawTransaction = {\n    version: '0x0',\n    cellDeps,\n    headerDeps: [],\n    inputs,\n    outputs,\n    outputsData,\n    witnesses,\n  };\n\n  let changeCapacity = BigInt(sporeCell.output.capacity);\n  const txSize = getTransactionSize(ckbRawTx) + (witnessLockPlaceholderSize ?? RGBPP_TX_WITNESS_MAX_SIZE);\n  const estimatedTxFee = calculateTransactionFee(txSize, ckbFeeRate);\n  changeCapacity -= estimatedTxFee;\n\n  ckbRawTx.outputs[ckbRawTx.outputs.length - 1].capacity = append0x(changeCapacity.toString(16));\n\n  return ckbRawTx;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,IAAAA,gBAAyE;;;ACFzE,mBAA8C;AAE9C,IAAM,EAAE,QAAQ,QAAQ,QAAQ,IAAI;AAcpC,IAAM,eAAW,oCAA2D;AAAA,EAC1E,YAAY;AAAA;AAAA,EAEZ,MAAM,CAAC,aAAa;AAClB,QAAI,aAAa,OAAS,QAAO,IAAI,WAAW,CAAC,CAAW,CAAC;AAC7D,QAAI,aAAa,OAAS,QAAO,IAAI,WAAW,CAAC,CAAW,CAAC;AAC7D,QAAI,aAAa,QAAS,QAAO,IAAI,WAAW,CAAC,CAAW,CAAC;AAC7D,QAAI,aAAa,QAAS,QAAO,IAAI,WAAW,CAAC,CAAW,CAAC;AAE7D,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AAAA,EACA,QAAQ,CAACC,UAAS;AAChB,QAAIA,MAAK,CAAC,MAAM,EAAa,QAAO;AACpC,QAAIA,MAAK,CAAC,MAAM,EAAa,QAAO;AACpC,QAAIA,MAAK,CAAC,MAAM,EAAa,QAAO;AACpC,QAAIA,MAAK,CAAC,MAAM,EAAa,QAAO;AAEpC,UAAM,IAAI,MAAM,mBAAmB;AAAA,EACrC;AACF,CAAC;AAED,IAAM,cAAU,oCAA2C;AAAA,EACzD,YAAY;AAAA;AAAA,EAEZ,MAAM,CAAC,YAAY;AACjB,QAAI,YAAY,OAAY,QAAO,IAAI,WAAW,CAAC,CAAC,CAAC;AACrD,QAAI,YAAY,WAAY,QAAO,IAAI,WAAW,CAAC,CAAC,CAAC;AAErD,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AAAA,EACA,QAAQ,CAACA,UAAS;AAChB,QAAIA,MAAK,CAAC,MAAM,EAAG,QAAO;AAC1B,QAAIA,MAAK,CAAC,MAAM,EAAG,QAAO;AAE1B,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AACF,CAAC;;;AD/CD,IAAM,EAAE,OAAO,QAAQ,OAAO,QAAQ,QAAQ,OAAO,UAAU,IAAI;AAEnE,IAAM,qBAAqB,UAAU,EAAE,MAAM,oBAAM,QAAQ,QAAQ,oBAAM,OAAO,CAAC;AAEjF,SAAS,8BAA8B,YAAoB;AACzD,aAAO,qCAAsB;AAAA,IAC3B,MAAM,oBAAM;AAAA,IACZ,QAAQ,oBAAM;AAAA,IACd;AAAA,EACF,CAAC;AACH;AAEA,IAAM,OAAO,8BAA8B,CAAC;AAErC,IAAM,SAAS,8BAA8B,EAAE;AAE/C,IAAM,UAAU,8BAA8B,EAAE;AAEhD,IAAM,QAAQ;AAEd,IAAM,WAAW,OAAO,KAAK;AAE7B,IAAM,cAAc,OAAO,QAAQ;AAEnC,IAAM,WAAW,OAAO,KAAK;AAE7B,IAAM,YAAY,OAAO,MAAM;AAE/B,IAAM,kBAAkB,8BAA8B,EAAE;AAExD,IAAM,qBAAqB,OAAO,eAAe;AAEjD,IAAM,SAAS;AAAA,EACpB;AAAA,IACE,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EACA,CAAC,YAAY,YAAY,MAAM;AACjC;AAEO,IAAM,WAAW;AAAA,EACtB;AAAA,IACE,QAAQ;AAAA,IACR,OAAO;AAAA,EACT;AAAA,EACA,CAAC,UAAU,OAAO;AACpB;AAEO,IAAM,YAAY;AAAA,EACvB;AAAA,IACE,OAAO;AAAA,IACP,gBAAgB;AAAA,EAClB;AAAA,EACA,CAAC,SAAS,gBAAgB;AAC5B;AAEO,IAAM,UAAU;AAAA,EACrB;AAAA,IACE,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAAA,EACA,CAAC,YAAY,SAAS;AACxB;AAEO,IAAM,YAAY;AAAA,EACvB;AAAA,IACE,SAAS;AAAA,IACT,eAAe;AAAA,IACf,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,YAAY;AAAA,IACZ,kBAAkB;AAAA,IAClB,eAAe;AAAA,IACf,WAAW;AAAA,IACX,KAAK;AAAA,EACP;AAAA,EACA;AAAA,IACE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEO,IAAM,SAAS;AAAA,EACpB;AAAA,IACE,KAAK;AAAA,IACL,OAAO;AAAA,EACT;AAAA,EACA,CAAC,OAAO,OAAO;AACjB;AAEO,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,QAAQ;AAAA,IACR,WAAW;AAAA,EACb;AAAA,EACA,CAAC,UAAU,WAAW;AACxB;AAEO,IAAM,kBAAkB;AAAA,EAC7B;AAAA,IACE,MAAM;AAAA,IACN,SAAS;AAAA,EACX;AAAA,EACA,CAAC,QAAQ,SAAS;AACpB;AAEO,IAAM,cAAc;AAAA,EACzB;AAAA,IACE,MAAM;AAAA,IACN,WAAW;AAAA,IACX,YAAY;AAAA,EACd;AAAA,EACA,CAAC,QAAQ,aAAa,YAAY;AACpC;AAEO,IAAM,YAAY,OAAO,MAAM;AAE/B,IAAM,gBAAgB,OAAO,UAAU;AAEvC,IAAM,aAAa,OAAO,OAAO;AAEjC,IAAM,eAAe,OAAO,SAAS;AAErC,IAAM,aAAa;AAAA,EACxB;AAAA,IACE,UAAU;AAAA,IACV,MAAM;AAAA,IACN,OAAO;AAAA,EACT;AAAA,EACA,CAAC,YAAY,QAAQ,OAAO;AAC9B;AAEO,IAAM,gBAAgB,OAAO,UAAU;AAEvC,IAAM,iBAAiB;AAAA,EAC5B;AAAA,IACE,SAAS;AAAA,IACT,UAAU;AAAA,IACV,YAAY;AAAA,IACZ,QAAQ;AAAA,IACR,SAAS;AAAA,IACT,aAAa;AAAA,EACf;AAAA,EACA,CAAC,WAAW,YAAY,cAAc,UAAU,WAAW,aAAa;AAC1E;AAEO,IAAM,cAAc;AAAA,EACzB;AAAA,IACE,KAAK;AAAA,IACL,WAAW;AAAA,EACb;AAAA,EACA,CAAC,OAAO,WAAW;AACrB;AAEO,IAAM,iBAAiB,OAAO,WAAW;AAEzC,IAAM,QAAQ;AAAA,EACnB;AAAA,IACE,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,cAAc;AAAA,IACd,WAAW;AAAA,EACb;AAAA,EACA,CAAC,UAAU,UAAU,gBAAgB,WAAW;AAClD;AAEO,IAAM,UAAU;AAAA,EACrB;AAAA,IACE,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,cAAc;AAAA,IACd,WAAW;AAAA,IACX,WAAW;AAAA,EACb;AAAA,EACA,CAAC,UAAU,UAAU,gBAAgB,aAAa,WAAW;AAC/D;;;AE5LA,IAAAC,gBAAyE;AAkCzE,IAAM,EAAE,OAAAC,QAAO,QAAAC,SAAQ,OAAAC,QAAO,QAAAC,SAAQ,QAAAC,SAAQ,OAAAC,QAAO,WAAAC,WAAU,IAAI;AAEnE,IAAMC,sBAAqBD,WAAU,EAAE,MAAM,oBAAM,QAAQ,QAAQ,oBAAM,OAAO,CAAC;AAEjF,SAASE,+BAA8B,YAAoB;AACzD,aAAO,qCAAsB;AAAA,IAC3B,MAAM,oBAAM;AAAA,IACZ,QAAQ,oBAAM;AAAA,IACd;AAAA,EACF,CAAC;AACH;AAEA,IAAMC,QAAOD,+BAA8B,CAAC;AAErC,IAAM,cAAcJ;AAAA,EACzB;AAAA,IACE,eAAe;AAAA,IACf,qBAAqB;AAAA,EACvB;AAAA,EACA,CAAC,iBAAiB,qBAAqB;AACzC;AAEO,IAAM,YAAYA;AAAA,EACvB;AAAA,IACE,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AAAA,EACA,CAAC,YAAY,SAAS;AACxB;AAEO,IAAM,sBAAsBA;AAAA,EACjC;AAAA,IACE,UAAUK;AAAA,IACV,WAAWA;AAAA,EACb;AAAA,EACA,CAAC,YAAY,WAAW;AAC1B;AAEO,IAAM,SAASD,+BAA8B,CAAC;AAE9C,IAAM,cAAcH;AAAA,EACzB;AAAA,IACE,SAAS;AAAA,IACT,WAAW;AAAA,IACX,OAAO;AAAA,IACP,YAAY;AAAA,EACd;AAAA,EACA,CAAC,WAAW,aAAa,SAAS,YAAY;AAChD;AAEO,IAAM,cAAcA;AAAA,EACzB;AAAA,IACE,YAAY;AAAA,IACZ,OAAO;AAAA,IACP,SAAS;AAAA,EACX;AAAA,EACA,CAAC,cAAc,SAAS,SAAS;AACnC;AAEO,IAAM,oBAAoBD;AAAA,EAC/B;AAAA,IACE,eAAe;AAAA,EACjB;AAAA,EACA,CAAC,eAAe;AAClB;AAEO,IAAM,gBAAgBC;AAAA,EAC3B;AAAA,IACE,YAAY;AAAA,EACd;AAAA,EACA,CAAC,YAAY;AACf;;;AC3GA,IAAAK,gBAAkB;AAClB,0BAAgB;;;ACCT,IAAM,WAAW,OAAO,GAAU;AAClC,IAAM,UAAU,OAAO,GAAS;AAChC,IAAM,eAAe,OAAO,EAAE,IAAI,OAAO,GAAU;AACnD,IAAM,8BAA8B;AACpC,IAAM,+BAA+B;AACrC,IAAM,4BAA4B;AAClC,IAAM,6BAA6B;AAEnC,IAAM,4BAA4B;AAClC,IAAM,0BAA0B;AAEvC,IAAM,cAAc;AAAA,EAClB,kBAAkB;AAAA,IAChB,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,iBAAiB;AAAA,IACf,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,cAAc;AAAA,IACZ,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,oBAAoB;AAAA,IAClB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,mBAAmB;AAAA,IACjB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,gBAAgB;AAAA,IACd,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,sBAAsB;AAAA,IACpB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,gBAAgB;AAAA,IACd,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,aAAa;AAAA,IACX,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,kBAAkB;AAAA,IAChB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,eAAe;AAAA,IACb,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,mBAAmB;AAAA,IACjB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,gBAAgB;AAAA,IACd,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,iBAAiB;AAAA,IACf,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,cAAc;AAAA,IACZ,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA;AAAA,EAGA,uBAAuB;AAAA,IACrB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,oBAAoB;AAAA,IAClB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,0BAA0B;AAAA,IACxB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,yBAAyB;AAAA,IACvB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,sBAAsB;AAAA,IACpB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,4BAA4B;AAAA,IAC1B,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AACF;AAEA,IAAM,cAAc;AAAA,EAClB,kBAAkB;AAAA,IAChB,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,iBAAiB;AAAA,IACf,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,cAAc;AAAA,IACZ,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,oBAAoB;AAAA,IAClB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,mBAAmB;AAAA,IACjB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,gBAAgB;AAAA,IACd,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,sBAAsB;AAAA,IACpB,UAAU,EAAE,QAAQ,sEAAsE,OAAO,MAAM;AAAA,IACvG,SAAS;AAAA,EACX;AAAA,EAEA,gBAAgB;AAAA,IACd,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,aAAa;AAAA,IACX,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,kBAAkB;AAAA,IAChB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,eAAe;AAAA,IACb,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,mBAAmB;AAAA,IACjB,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,gBAAgB;AAAA,IACd,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AAAA,EAEA,iBAAiB;AAAA,IACf,UAAU;AAAA,IACV,UAAU;AAAA,IACV,MAAM;AAAA,EACR;AAAA,EAEA,cAAc;AAAA,IACZ,UAAU;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,IACT;AAAA,IACA,SAAS;AAAA,EACX;AACF;AAEO,IAAM,yBAAyB;AAAA,EACpC,UAAU;AAAA,EACV,UAAU;AAAA,EACV,MAAM;AACR;AAEO,IAAM,sBAAsB,CAAC,cAClC,YAAY,YAAY,mBAAmB,YAAY;AAElD,IAAM,oBAAoB,CAAC,cAChC,YAAY,YAAY,iBAAiB,YAAY;AAChD,IAAM,aAAa,CAAC,cAAwB,YAAY,YAAY,cAAc,YAAY;AAE9F,IAAM,qBAAqB,CAAC,WAAoB,mBAAoC;AACzF,MAAI,WAAW;AACb,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,mBAAmB,WAAW,YAAY,wBAAwB,YAAY;AACvF;AAEO,IAAM,kBAAkB,CAAC,WAAoB,mBAAoC;AACtF,MAAI,WAAW;AACb,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,mBAAmB,WAAW,YAAY,qBAAqB,YAAY;AACpF;AAEO,IAAM,wBAAwB,CAAC,WAAoB,mBAAoC;AAC5F,MAAI,WAAW;AACb,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,mBAAmB,WAAW,YAAY,2BAA2B,YAAY;AAC1F;AAEO,IAAM,uBAAuB,CAAC,WAAoB,mBAAoC;AAC3F,MAAI,WAAW;AACb,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,mBAAmB,WAAW,YAAY,0BAA0B,YAAY;AACzF;AACO,IAAM,oBAAoB,CAAC,WAAoB,mBAAoC;AACxF,MAAI,WAAW;AACb,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,mBAAmB,WAAW,YAAY,uBAAuB,YAAY;AACtF;AAEO,IAAM,0BAA0B,CAAC,WAAoB,mBAAoC;AAC9F,MAAI,WAAW;AACb,WAAO,YAAY;AAAA,EACrB;AACA,SAAO,mBAAmB,WAAW,YAAY,6BAA6B,YAAY;AAC5F;AAEO,IAAM,sBAAsB,CAAC,cAClC,YAAY,YAAY,mBAAmB,YAAY;AAClD,IAAM,mBAAmB,CAAC,cAC/B,YAAY,YAAY,gBAAgB,YAAY;AAE/C,IAAM,uBAAuB,CAAC,cACnC,YAAY,YAAY,oBAAoB,YAAY;AACnD,IAAM,oBAAoB,CAAC,cAChC,YAAY,YAAY,iBAAiB,YAAY;AAEhD,IAAM,qBAAqB,CAAC,cACjC,YAAY,YAAY,kBAAkB,YAAY;AACjD,IAAM,kBAAkB,CAAC,cAC9B,YAAY,YAAY,eAAe,YAAY;;;ACrS9C,IAAM,yBAAN,cAAqC,MAAM;AAAA,EAChD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,eAAN,cAA2B,MAAM;AAAA,EACtC,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,kBAAN,cAA8B,MAAM;AAAA,EACzC,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,sBAAN,cAAkC,MAAM;AAAA,EAC7C,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,uBAAN,cAAmC,MAAM;AAAA,EAC9C,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EACjD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,+BAAN,cAA2C,MAAM;AAAA,EACtD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,6BAAN,cAAyC,MAAM;AAAA,EACpD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,0BAAN,cAAsC,MAAM;AAAA,EACjD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,gCAAN,cAA4C,MAAM;AAAA,EACvD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,oCAAN,cAAgD,MAAM;AAAA,EAC3D,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,8BAAN,cAA0C,MAAM;AAAA,EACrD,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;AAEO,IAAM,qBAAN,cAAiC,MAAM;AAAA,EAC5C,OAAO;AAAA,EACP,YAAY,SAAiB;AAC3B,UAAM,OAAO;AAAA,EACf;AACF;;;ACzGA,4BAA0B;AAEnB,IAAM,cAAc,CAAI,QAA0B;AACvD,MAAI;AACF,eAAO,sBAAAC,SAAc,KAAK;AAAA,MACxB,MAAM;AAAA,IACR,CAAC;AAAA,EACH,SAAS,OAAO;AACd,YAAQ,MAAM,KAAK;AAAA,EACrB;AACA,SAAO;AACT;;;ACXA,2BAAuC;AAGhC,IAAM,WAAW,CAAC,QAAwB;AAC/C,MAAI,IAAI,WAAW,IAAI,GAAG;AACxB,WAAO,IAAI,UAAU,CAAC;AAAA,EACxB;AACA,SAAO;AACT;AAEO,IAAM,WAAW,CAAC,QAAyB;AAChD,SAAO,KAAK,WAAW,IAAI,IAAI,MAAM,KAAK,GAAG;AAC/C;AAEA,IAAM,mBAAmB,CAAC,gBAAqC;AAC7D,SAAO,MAAM,UAAU,IAAI,KAAK,IAAI,WAAW,WAAW,GAAG,CAAC,OAAO,OAAO,EAAE,SAAS,EAAE,GAAG,MAAM,EAAE,CAAC,EAAE,KAAK,EAAE;AAChH;AAEO,IAAM,UAAU,CAAC,OAAuB;AAC7C,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,QAAM,OAAO,IAAI,SAAS,MAAM;AAChC,OAAK,SAAS,GAAG,EAAE;AACnB,SAAO,iBAAiB,MAAM;AAChC;AAEO,IAAM,UAAU,CAAC,QAAwB;AAC9C,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,QAAM,OAAO,IAAI,SAAS,MAAM;AAChC,OAAK,UAAU,GAAG,KAAK,IAAI;AAC3B,SAAO,iBAAiB,MAAM;AAChC;AAEA,IAAM,WAAW,CAAC,KAAsB,iBAAmC;AACzE,QAAM,SAAS,IAAI,YAAY,CAAC;AAChC,QAAM,OAAO,IAAI,SAAS,MAAM;AAChC,OAAK,UAAU,GAAG,OAAO,GAAG,GAAG,YAAY;AAC3C,SAAO,iBAAiB,MAAM;AAChC;AAEO,IAAM,UAAU,CAAC,QAAiC;AACvD,SAAO,SAAS,KAAK,KAAK;AAC5B;AAEO,IAAM,UAAU,CAAC,QAAiC;AACvD,SAAO,SAAS,KAAK,IAAI;AAC3B;AAEO,IAAM,aAAa,CAAC,QAAiC;AAC1D,QAAM,MAAM,QAAQ,GAAG;AACvB,QAAM,KAAK,WAAW,SAAS,KAAK,EAAE,EAAE,SAAS,EAAE,CAAC;AACpD,SAAO,SAAS,SAAS,IAAI,EAAE,EAAE,SAAS,EAAE,CAAC;AAC/C;AAEO,IAAM,UAAU,CAAC,UAA0B;AAChD,QAAMC,aAAQ,iCAAW,SAAS,KAAK,CAAC;AACxC,QAAM,QAAQ,KAAKA,OAAM,YAAY,CAAC,KAAK,QAAQ,MAAM,IAAI,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC;AAC/F,SAAO,SAAS,OAAO,EAAE;AAC3B;AAEO,IAAM,UAAU,CAAC,QAAwB;AAC9C,QAAM,MAAM,IAAI,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAC7C,QAAM,WAAW,QAAQ,KAAK,IAAI,MAAM,CAAC,CAAC,EAAE;AAC5C,QAAM,YAAY,QAAQ,KAAK,IAAI,MAAM,GAAG,CAAC,CAAC,EAAE;AAChD,SAAO,GAAG,QAAQ,GAAG,SAAS;AAChC;AAEO,IAAM,WAAW,CAAC,SAAyB;AAChD,QAAM,MAAM,KAAK,SAAS,EAAE,EAAE,SAAS,IAAI,GAAG;AAC9C,QAAM,WAAW,QAAQ,OAAO,KAAK,IAAI,MAAM,EAAE,CAAC,EAAE,CAAC;AACrD,QAAM,YAAY,QAAQ,OAAO,KAAK,IAAI,MAAM,GAAG,EAAE,CAAC,EAAE,CAAC;AACzD,SAAO,GAAG,QAAQ,GAAG,SAAS;AAChC;AAEO,IAAM,WAAW,CAAC,UAA0B;AACjD,QAAMA,aAAQ,iCAAW,SAAS,KAAK,CAAC;AACxC,QAAM,QAAQ,KAAKA,OAAM,YAAY,CAAC,KAAK,QAAQ,MAAM,IAAI,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,GAAG,EAAE,CAAC;AAC/F,SAAO,OAAO,KAAK;AACrB;AAEO,IAAM,YAAY,CAAC,SAAiB;AACzC,MAAI,SAAS,KAAK,KAAK;AACvB,MAAI,OAAO,WAAW,IAAI,GAAG;AAC3B,WAAO;AAAA,EACT;AACA,eAAS,iCAAW,IAAI,YAAY,EAAE,OAAO,MAAM,CAAC;AACpD,SAAO;AACT;AAEO,IAAM,YAAY,CAAC,QAAgB;AACxC,MAAI,SAAS,IAAI,KAAK;AACtB,MAAI;AACF,aAAS,IAAI,YAAY,EAAE,WAAO,iCAAW,MAAM,CAAC;AAAA,EACtD,SAAS,OAAO;AACd,YAAQ,MAAM,oBAAoB,KAAK;AAAA,EACzC;AACA,SAAO;AACT;AAEO,IAAM,aAAa,CAAC,QAAa;AACtC,aAAO,qCAAW,iCAAW,SAAS,GAAG,CAAC,EAAE,QAAQ,CAAC;AACvD;;;ACpGA,IAAAC,wBAA+E;AAC/E,kBAAqF;;;ACDrF,uBAAuB;AAwBvB,kBAA2B;AAC3B,IAAAC,wBAMO;AAGA,IAAM,qBAAqB,CAAC,eAAoB,WAAoB,mBAAoC;AAC7G,SAAO;AAAA,IACL,GAAG,mBAAmB,WAAW,cAAc;AAAA,IAC/C,MAAM,SAAS,aAAa;AAAA,EAC9B;AACF;AAEO,IAAM,qBAAqB,CAAC,MAA4B,SAAc,UAAuB;AAClG,QAAM,UAAU,uBAAW,OAAO,KAAK,WAAW,OAAO,CAAC;AAC1D,QAAM,aAAa,OAAO,WAAO,uCAAgB,IAAI,CAAC;AACtD,aAAO,kCAAW,YAAY,KAAK,EAAE,YAAY,OAAO,QAAQ,CAAC,CAAC;AACpE;AAUO,IAAM,uBAAuB,CAClC,QACA,WACA,gBACA,0BACG;AACH,QAAM,OAAO;AAAA,IACX;AAAA,IACA;AAAA,IACA,yBAAyB;AAAA,EAC3B;AACA,SAAO;AAAA,IACL,GAAG,qBAAqB,WAAW,cAAc;AAAA,IACjD;AAAA,EACF;AACF;AAGA,IAAM,qBAAqB;AAEpB,IAAM,sBAAsB,CAAC,mBAA0E;AAC5G,QAAM,OAAO,wBAAO,OAAO;AAC3B,OAAK,WAAO,kCAAW,UAAU,OAAO,CAAC,CAAC;AAC1C,QAAM,UAAU,CAAC,GAAG,CAAC;AACrB,OAAK,OAAO,OAAO;AAEnB,QAAM,EAAE,QAAQ,SAAS,YAAY,IAAI;AAEzC,MAAI,OAAO,SAAS,sBAAsB,QAAQ,SAAS,oBAAoB;AAC7E,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,OAAK,OAAO,CAAC,OAAO,QAAQ,QAAQ,MAAM,CAAC;AAE3C,aAAW,SAAS,QAAQ;AAC1B,SAAK,WAAO,sCAAW,yCAAkB,MAAM,cAAc,CAAC,CAAC;AAAA,EACjE;AACA,WAAS,QAAQ,GAAG,QAAQ,QAAQ,QAAQ,SAAS;AACnD,UAAM,SAAS,QAAQ,KAAK;AAC5B,UAAM,aAAa,YAAY,KAAK;AACpC,SAAK,WAAO,sCAAW,uCAAgB,MAAM,CAAC,CAAC;AAE/C,UAAM,gBAAgB,QAAQ,SAAS,UAAU,EAAE,SAAS,CAAC;AAC7D,SAAK,WAAO,kCAAW,SAAS,aAAa,CAAC,CAAC;AAC/C,SAAK,WAAO,kCAAW,UAAU,CAAC;AAAA,EACpC;AAEA,aAAO,yBAAO,KAAK,MAAM,CAAC;AAC5B;AASO,IAAM,gCAAgC,CAAC,SAAoC;AAChF,QAAM,EAAE,WAAW,IAAI,YAAY,OAAO,SAAS,IAAI,CAAC;AACxD,SAAO;AAAA,IACL,GAAG;AAAA,IACH,UAAU,SAAS,OAAO,WAAW,QAAQ;AAAA,EAC/C;AACF;AAMO,IAAM,qCAAqC,CAAC,SAA+B;AAChF,QAAM,EAAE,SAAS,MAAM,IAAI,YAAY,OAAO,SAAS,IAAI,CAAC;AAC5D,UAAQ,IAAI,OAAO;AACnB,UAAQ,IAAI,KAAK;AACjB,SAAO;AAAA,IACL,SAAS,WAAW,SAAS,OAAO,CAAC;AAAA,IACrC;AAAA,EACF;AACF;AAOO,IAAM,qBAAqB,CAAC,UAAkB,YAAsB;AACzE,SAAO,KAAK,QAAQ,QAAQ,CAAC,GAAG,SAAS,WAAW,OAAO,CAAC,CAAC;AAC/D;AAEO,IAAM,mBAAmB,CAAC,aAAqB;AACpD,SAAO,mBAAmB,UAAU,uBAAuB;AAC7D;AAMO,IAAM,sBAAsB,CAAC,WAAqC;AACvE,QAAM,WAAW,UAAU,OAAO,MAAM;AACxC,SAAO;AAAA,IACL,SAAS,WAAW,SAAS,OAAO;AAAA,IACpC,UAAU,SAAS;AAAA,EACrB;AACF;AAEO,IAAM,gBAAgB,CAAC,GAAgB,MAAmB;AAC/D,MAAI,EAAE,OAAO,KAAK,OAAO,EAAE,OAAO,KAAK,MAAM;AAC3C,WAAO;AAAA,EACT;AACA,MAAI,EAAE,OAAO,KAAK,OAAO,EAAE,OAAO,KAAK,MAAM;AAC3C,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAUA,IAAM,2BAA2B,KAAK;AACtC,IAAM,iBAAiB,KAAK;AACrB,IAAM,iCAAiC,CAAC,UAAe,SAAmB;AAC/E,QAAM,aAAa,SAAS,QAAQ,EAAE;AACtC,MAAI,aAAa,0BAA0B;AACzC,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC3E;AACA,SAAO,KAAK,SAAS,QAAQ,EAAE,UAAU,GAAG,aAAa,cAAc,CAAC,GAAG,SAAS,WAAW,IAAI,CAAC,CAAC;AACvG;AAEA,IAAM,eAAiC,CAAC,YAAY,QAAQ;AAC5D,IAAM,cAAc,CAAC,OAA6B,UAChD,MAAM,aAAa,MAAM,YAAY,MAAM,aAAa,MAAM;AAEzD,IAAM,kBAAkB,CAAC,MAAgC,cAAgC;AAC9F,MAAI,WAAW;AACb,WAAO,YAAY,KAAK,MAAM,mBAAmB,SAAS,CAAC;AAAA,EAC7D;AACA,SAAO,aAAa,KAAK,CAAC,YAAY,YAAY,KAAK,MAAM,mBAAmB,WAAW,OAAO,CAAC,CAAC;AACtG;AAEO,IAAM,6BAA6B,CAAC,SAA4C;AACrF,SAAO,gBAAgB,MAAM,IAAI,KAAK,gBAAgB,MAAM,KAAK;AACnE;AAEO,IAAM,oBAAoB,CAAC,MAAgC,cAAgC;AAChG,MAAI,WAAW;AACb,WAAO,YAAY,KAAK,MAAM,qBAAqB,SAAS,CAAC;AAAA,EAC/D;AACA,SAAO,aAAa,KAAK,CAAC,YAAY,YAAY,KAAK,MAAM,qBAAqB,WAAW,OAAO,CAAC,CAAC;AACxG;AAEO,IAAM,2BAA2B,CAAC,MAA4B,cAAuB;AAC1F,MAAI,WAAW;AACb,WAAO,YAAY,MAAM,mBAAmB,SAAS,CAAC,KAAK,YAAY,MAAM,qBAAqB,SAAS,CAAC;AAAA,EAC9G;AACA,SAAO,aAAa,QAAQ,CAAC,YAAY;AAAA,IACvC,mBAAmB,WAAW,OAAO;AAAA,IACrC,qBAAqB,WAAW,OAAO;AAAA,EACzC,CAAC,EAAE,KAAK,CAAC,WAAW,YAAY,QAAQ,IAAI,CAAC;AAC/C;AAEO,IAAM,oBAAoB,CAAC,aAAqD;AACrF,SAAO,YAAY,QAAQ;AAC7B;AAEO,IAAM,wBAAwB,CAAC,cAAsC;AAC1E,QAAM,UAAiC;AAAA,IACrC,UAAU;AAAA,IACV,SAAS;AAAA,EACX;AACA,SAAO;AACT;AAMO,IAAM,sBAAsB,CAAC,sBAAqC;AACvE,QAAM,mBAAmB,IAAI,IAAI,iBAAiB;AAClD,QAAM,kBAAkB,iBAAiB;AACzC,SAAO,4BAA4B;AACrC;AAOO,IAAM,uBAAuB,CAAC,cAA8B;AACjE,QAAM,UAAU,QAAQ,UAAU,OAAO;AACzC,QAAM,OAAO,SAAS,UAAU,UAAU,IAAI,CAAC;AAC/C,QAAM,WAAW,QAAQ,KAAK,SAAS,CAAC;AACxC,QAAM,SAAS,SAAS,UAAU,UAAU,MAAM,CAAC;AACnD,QAAM,aAAa,QAAQ,OAAO,SAAS,CAAC;AAC5C,SAAO,KAAK,OAAO,GAAG,QAAQ,GAAG,IAAI,GAAG,UAAU,GAAG,MAAM;AAC7D;AAEO,IAAM,8BAA8B,CAAC,cAAsC;AAChF,QAAM,mBAAmB,qBAAqB,SAAS;AACvD,SAAO,OAAO,SAAS,gBAAgB,EAAE,SAAS,CAAC;AACrD;AAEO,IAAM,iCAAiC,CAAC,aAAqB;AAClE,MAAI,WAAW,4BAA4B;AACzC,UAAM,IAAI,8BAA8B,6CAA6C,0BAA0B,EAAE;AAAA,EACnH;AACF;AAGO,IAAM,kCAAkC,CAC7C,OACA,eACA,cACG;AACH,MAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAChC,UAAM,IAAI,qBAAqB,+CAA+C;AAAA,EAChF;AACA,QAAM,YAAY,MAAM,OAAO,CAAC,SAAS,CAAC,CAAC,KAAK,OAAO,IAAI;AAC3D,MAAI,UAAU,WAAW,GAAG;AAC1B,UAAM,IAAI,qBAAqB,+CAA+C;AAAA,EAChF;AAEA,QAAM,wBAAwB,UAAU;AAAA,IACtC,CAAC,SAAS,KAAK,OAAO,QAAQ,CAAC,mBAAmB,KAAK,OAAO,MAAM,SAAS;AAAA,EAC/E;AACA,MAAI,uBAAuB;AACzB,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,gBAAgB,UAAU,KAAK,CAAC,SAAS,cAAc,KAAK,OAAO,MAAO,aAAa,CAAC;AAC9F,MAAI,CAAC,eAAe;AAClB,UAAM,IAAI,qBAAqB,wEAAwE;AAAA,EACzG;AACF;AAKO,IAAM,qCAAqC,CAChD,sBACA,2BACY;AACZ,QAAM,wBAAwB,2BAA2B;AACzD,SAAO,uBAAuB,yBAAyB;AACzD;;;ADhSO,IAAM,0BAA0B,CAAC,QAAgB,YAA6B;AACnF,QAAM,OAAO,WAAW,OAAO,IAAI;AACnC,QAAM,QAAQ,OAAO,GAAI;AACzB,QAAM,OAAO,OAAO,MAAM,IAAI;AAC9B,QAAM,MAAM,OAAO;AACnB,SAAO,MAAM,QAAQ,OAAO,MAAM,OAAO,CAAC,IAAI;AAChD;AAEO,IAAM,qBAAqB,CAAC,MAA4B,cAAgC;AAC7F,QAAM,eAAW,uCAAgB,kBAAkB,SAAS,CAAC;AAC7D,QAAM,gBAAY,uCAAgB;AAAA,IAChC,GAAG;AAAA,IACH,MAAM;AAAA,EACR,CAAC;AACD,SAAO,aAAa;AACtB;AAEO,IAAM,uBAAuB,CAAC,MAA4B,cAAgC;AAC/F,QAAM,gBAAY,uCAAgB,mBAAmB,SAAS,CAAC;AAC/D,QAAM,gBAAY,uCAAgB;AAAA,IAChC,GAAG;AAAA,IACH,MAAM;AAAA,EACR,CAAC;AACD,SAAO,cAAc;AACvB;AAEO,IAAM,8BAA8B,CAAC,MAA4B,cAAgC;AACtG,QAAM,gBAAY,uCAAgB;AAAA,IAChC,GAAG;AAAA,IACH,MAAM;AAAA,EACR,CAAC;AACD,QAAM,kBAAc,uCAAgB,qBAAqB,SAAS,CAAC;AACnE,SAAO,qBAAqB,MAAM,SAAS,KAAK,gBAAgB;AAClE;AAEO,IAAM,uBAAuB,CAAC,MAA4B,cAAgC;AAC/F,SAAO,mBAAmB,MAAM,SAAS,KAAK,4BAA4B,MAAM,SAAS;AAC3F;AAEA,IAAM,qBAAqB;AAC3B,IAAM,qBAAqB;AAG3B,IAAM,yBAAyB;AACxB,IAAM,yBAAyB,CAAC,SAAc,SAAS,IAAI,EAAE,SAAS,yBAAyB;AAGtG,IAAM,+BAA+B;AAWrC,IAAM,kBAAkB,KAAK,IAAI;AAC1B,IAAM,6BAA6B,CAAC,aAA4C;AACrF,QAAM,eAAe,WAAW,SAAS,SAAS,IAAI,EAAE,SAAS,IAAI;AACrE,QAAM,cAAc,KAAK;AACzB,QAAM,WACJ,kBAAkB,cAAc,qBAAqB,qBAAqB;AAC5E,SAAO,OAAO,QAAQ,IAAI;AAC5B;AAKA,IAAM,wBAAwB;AACvB,IAAM,2BAA2B,CAAC,MAA4B,YAA2C;AAC9G,QAAM,eAAe,SAAS,KAAK,IAAI,EAAE,SAAS;AAClD,QAAM,eAAe,UAAU,SAAS,QAAQ,IAAI,EAAE,SAAS,IAAI;AACnE,QAAM,WAAW,KAAK;AACtB,QAAM,WAAW,KAAK;AACtB,QAAM,WAAW,WAAW,WAAW,qBAAqB;AAC5D,SAAO,OAAO,WAAW,CAAC,IAAI;AAChC;AAGO,IAAM,qCAAqC,CAAC,WAA2B,SAAuC;AACnH,QAAM,WAAW,SAAS,KAAK,IAAI,EAAE,SAAS,IAAI;AAClD,QAAM,eAAe,SAAS,qBAAqB,SAAS,CAAC,EAAE,SAAS;AACxE,QAAM,iBAAiB,KAAK,IAAI;AAChC,QAAM,WAAW,WAAW,iBAAiB,qBAAqB;AAClE,SAAO,OAAO,QAAQ,IAAI;AAC5B;AAGO,IAAM,sCAAsC,CAAC,WAA2B,cAA+B;AAC5G,QAAM,cAAc,qBAAqB,wBAAwB,SAAS;AAC1E,QAAM,WAAW,SAAS,YAAY,IAAI,EAAE,SAAS,IAAI;AACzD,QAAM,eAAe,SAAS,qBAAqB,SAAS,CAAC,EAAE,SAAS;AACxE,QAAM,WAAW,KAAK,IAAI;AAC1B,QAAM,WAAW,WAAW,WAAW,qBAAqB;AAC5D,SAAO,OAAO,QAAQ,IAAI;AAC5B;AAGO,IAAM,yBAAyB,CAAC,YAAqC,qBAA6B;AACvG,QAAM,YAAQ,sCAAW,sCAAe,UAAU,CAAC;AACnD,QAAM,QAAI,+BAAQ,IAAI,MAAM,MAAM,8BAAQ;AAC1C,IAAE,OAAO,KAAK;AACd,IAAE,WAAO,kCAAW,KAAK,QAAQ,OAAO,gBAAgB,CAAC,CAAC,EAAE,CAAC;AAC7D,SAAO,KAAK,EAAE,OAAO,KAAK,EAAE,MAAM,GAAG,EAAE,CAAC;AAC1C;AAIO,IAAM,oCAAoC,CAAC,gBAAwC;AACxF,QAAM,sBAAkB,gCAAmB,WAAW,EAAE;AACxD,QAAM,kBAAkB,KAAK,IAAI;AACjC,QAAM,WAAW,kBAAkB,kBAAkB,qBAAqB;AAC1E,SAAO,OAAO,WAAW,CAAC,IAAI;AAChC;AAWO,IAAM,kCAAkC,CAAC,cAAsC;AACpF,QAAM,oBAAgB,8BAAiB,SAAS,EAAE;AAClD,QAAM,gBAAgB,KAAK,IAAI;AAC/B,QAAM,WAAW,kBAAkB,gBAAgB,qBAAqB,gBAAgB;AACxF,SAAO,OAAO,WAAW,CAAC,IAAI;AAChC;AAGO,IAAM,gCAAgC,CAAC,SAA8B;AAC1E,QAAM,eAAe,SAAS,KAAK,UAAU,EAAE,SAAS;AACxD,QAAM,WAAW,SAAS,KAAK,OAAO,KAAK,IAAI,EAAE,SAAS,IAAI,IAAI;AAClE,QAAM,WAAW,KAAK,OAAO,OAAO,SAAS,KAAK,OAAO,KAAK,IAAI,EAAE,SAAS,IAAI,IAAI,KAAK;AAC1F,QAAM,WAAW,eAAe,WAAW,WAAW;AACtD,SAAO,OAAO,QAAQ,IAAI;AAC5B;AAEO,IAAM,kBAAkB,CAAC,sBAAoC;AAClE,SAAO,MAAM,KAAK,IAAI,IAAI,iBAAiB,CAAC;AAC9C;AAGO,IAAM,gBAAgB,CAAC,IAAgC,OAAmC;AAC/F,QAAM,QAAQ,OAAO,OAAO,WAAW,SAAS,EAAE,IAAI,aAAS,uCAAgB,EAAE,CAAC;AAClF,QAAM,QAAQ,OAAO,OAAO,WAAW,SAAS,EAAE,IAAI,aAAS,uCAAgB,EAAE,CAAC;AAClF,SAAO,UAAU;AACnB;AAQO,IAAM,qCAAqC,OAChD,OACA,cACqB;AACrB,MAAI,oBAAoB,OAAO,CAAC;AAChC,mBAAiB,SAAS,MAAM,QAAQ;AACtC,UAAM,WAAW,MAAM,UAAU,YAAY,MAAM,cAAe;AAClE,QAAI,CAAC,UAAU;AACb,YAAM,IAAI,gBAAgB,8CAA8C;AAAA,IAC1E;AACA,yBAAqB,OAAO,SAAS,OAAO,QAAQ;AAAA,EACtD;AACA,QAAM,qBAAqB,MAAM,QAC9B,IAAI,CAAC,WAAW,OAAO,OAAO,QAAQ,CAAC,EACvC,OAAO,CAAC,MAAM,YAAY,OAAO,SAAS,OAAO,CAAC,CAAC;AACtD,SAAO,oBAAoB;AAC7B;;;AE9LA,qBAOO;AAKP,IAAAC,wBAA8D;AAGvD,IAAM,oBAAoB,CAAC,YAAqC,qBAA6B;AAClG,QAAM,YAAQ,sCAAW,sCAAe,UAAU,CAAC;AACnD,QAAM,QAAI,+BAAQ,IAAI,MAAM,MAAM,8BAAQ;AAC1C,IAAE,OAAO,KAAK;AACd,IAAE,WAAO,kCAAW,KAAK,QAAQ,OAAO,gBAAgB,CAAC,CAAC,EAAE,CAAC;AAC7D,SAAO,KAAK,EAAE,OAAO,KAAK,CAAC;AAC7B;AAGO,IAAM,kBAAkB,CAAC,YAAqC,qBAA6B;AAChG,SAAO,kBAAkB,YAAY,gBAAgB;AACvD;AAEO,IAAM,+BAA+B,CAC1C,eACA,sBACW;AACX,QAAM,SAAS;AAAA,IACb,YAAY;AAAA,IACZ,MAAM;AAAA,EACR;AACA,QAAM,EAAE,QAAQ,QAAI,4CAA4B,MAAM;AACtD,aAAO,6CAA6B,OAAO;AAC7C;AAEO,IAAM,6BAA6B,CAAC;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAyC;AACvC,MAAI,aAAa,WAAW,iBAAiB,QAAQ;AACnD,UAAM,IAAI,MAAM,8DAA8D;AAAA,EAChF;AACA,MAAI,eAA8C,CAAC;AAGnD,QAAM,eAAe;AAAA,IACnB,YAAY,YAAY;AAAA,IACxB,MAAM,YAAY;AAAA,EACpB;AACA,QAAM,gBAAgB;AAAA,IACpB,YAAY;AAAA,IACZ,MAAM,YAAY;AAAA,EACpB;AACA,QAAM,EAAE,QAAQ,QAAI,8CAA8B,cAAc,aAAa;AAC7E,iBAAe,aAAa,OAAO,OAAO;AAG1C,WAAS,QAAQ,GAAG,QAAQ,aAAa,QAAQ,SAAS;AACxD,UAAM,cAAc;AAAA,MAClB,YAAY,aAAa,KAAK;AAAA,MAC9B,MAAM,iBAAiB,KAAK;AAAA,IAC9B;AACA,UAAM,EAAE,SAAAC,SAAQ,QAAI,0CAA0B,WAAW;AACzD,mBAAe,aAAa,OAAOA,QAAO;AAAA,EAC5C;AACA,aAAO,6CAA6B,YAAY;AAClD;AAEO,IAAM,+BAA+B,CAC1C,YACA,gBACW;AACX,MAAI,WAAW,WAAW,YAAY,QAAQ;AAC5C,UAAM,IAAI,MAAM,qEAAqE;AAAA,EACvF;AACA,MAAI,eAA8C,CAAC;AACnD,WAAS,QAAQ,GAAG,QAAQ,WAAW,QAAQ,SAAS;AACtD,UAAM,YAAY,WAAW,KAAK;AAClC,UAAM,aAAa,gBAAgB,YAAY,UAAU,aAAa,UAAU,KAAM;AACtF,UAAM,aAAa;AAAA,MACjB,YAAY,WAAW,KAAK,EAAE;AAAA,MAC9B,MAAM;AAAA,IACR;AACA,UAAM,cAAc;AAAA,MAClB,YAAY,YAAY,KAAK;AAAA,MAC7B,MAAM;AAAA,IACR;AACA,UAAM,EAAE,QAAQ,QAAI,4CAA4B,YAAY,WAAW;AACvE,mBAAe,aAAa,OAAO,OAAO;AAAA,EAC5C;AACA,aAAO,6CAA6B,YAAY;AAClD;AAGO,IAAM,kCAAkC,CAC7C,YACA,gBACA,cACG;AACH,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,qBAAqB,2DAA2D;AAAA,EAC5F;AACA,MAAI,WAAW,SAAS,GAAG;AACzB,UAAM,IAAI,kCAAkC,sDAAsD;AAAA,EACpG;AACA,QAAM,YAAY,WAAW,CAAC;AAE9B,MAAI,CAAC,UAAU,OAAO,MAAM;AAC1B,UAAM,IAAI,4BAA4B,sDAAsD;AAAA,EAC9F;AAEA,MAAI,CAAC,qBAAqB,UAAU,OAAO,MAAM,SAAS,GAAG;AAC3D,UAAM,IAAI,4BAA4B,sDAAsD;AAAA,EAC9F;AAEA,MAAI,CAAC,cAAc,UAAU,OAAO,MAAM,cAAc,GAAG;AACzD,UAAM,IAAI,4BAA4B,6DAA6D;AAAA,EACrG;AACF;;;AC/HA,mBAAkB;AAsBlB,IAAM,4BACJ;AAEF,IAAM,gCACJ;AAEF,IAAM,UAAU,CAAC,QAAgB,aAAAC,QAAM,IAAI,KAAK,EAAE,SAAS,IAAK,CAAC;AAEjE,IAAM,oBAAoB,YAAY;AACpC,MAAI;AACF,UAAM,WAAW,MAAM,QAAQ,IAAI,CAAC,QAAQ,yBAAyB,GAAG,QAAQ,6BAA6B,CAAC,CAAC;AAC/G,WAAO,SAAS;AAAA,EAClB,SAAS,OAAO;AAAA,EAEhB;AACF;AASO,IAAM,sBAAsB,OACjC,WACA,UACA,mBACqC;AACrC,MAAI,eAAe,gBAAgB,WAAW,cAAc;AAC5D,MAAI,aAAa,kBAAkB,WAAW,cAAc;AAC5D,MAAI,UAAU,WAAW,SAAS;AAClC,MAAI,YAAY,iBAAiB,SAAS;AAE1C,QAAM,cAAc,MAAM,kBAAkB;AAC5C,MAAI,aAAa;AACf,QAAI,mBAAmB,UAAU;AAC/B,qBAAe,YAAY,MAAM;AACjC,mBAAa,YAAY,QAAQ;AAAA,IACnC,OAAO;AACL,qBAAe,YAAY,YAAY,MAAM,UAAU,YAAY,MAAM;AACzE,mBAAa,YAAY,YAAY,QAAQ,UAAU,YAAY,QAAQ;AAAA,IAC7E;AACA,QAAI,CAAC,WAAW;AACd,gBAAU,YAAY,KAAK;AAC3B,kBAAY,YAAY,OAAO;AAAA,IACjC;AAAA,EACF;AACA,MAAI,WAAoC,CAAC;AACzC,MAAI,SAAS,OAAO;AAOlB,eAAW;AAAA,MACT,GAAG;AAAA,MACH;AAAA,MACA;AAAA,QACE,GAAG;AAAA,QACH,UAAU;AAAA,UACR,GAAG,aAAa;AAAA,UAChB,OAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,SAAS,SAAS;AAOpB,eAAW;AAAA,MACT,GAAG;AAAA,MACH;AAAA,MACA;AAAA,QACE,GAAG;AAAA,QACH,UAAU;AAAA,UACR,GAAG,WAAW;AAAA,UACd,OAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,MAAI,SAAS,MAAM;AACjB,eAAW,CAAC,GAAG,UAAU,OAAO;AAAA,EAClC;AAEA,MAAI,SAAS,QAAQ;AACnB,eAAW,CAAC,GAAG,UAAU,SAAS;AAAA,EACpC;AAEA,SAAO;AACT;;;ACxHA,IAAAC,eAAsD;AAI/C,IAAM,eAAe,CAAC,QAAc,UAA6B;AACtE,MAAI,CAAC,OAAO,WAAW,IAAI,KAAK,CAAC,MAAM,WAAW,IAAI,GAAG;AACvD,UAAM,IAAI,mBAAmB,oDAAoD,MAAM,WAAW,KAAK,EAAE;AAAA,EAC3G;AACA,MAAI;AACF,4BAAW,SAAS,KAAK;AAAA,MACvB;AAAA,MACA;AAAA,IACF,CAAC;AACD,WAAO,GAAG,MAAM,IAAI,KAAK;AAAA,EAC3B,QAAQ;AACN,UAAM,IAAI,mBAAmB,oDAAoD,MAAM,WAAW,KAAK,EAAE;AAAA,EAC3G;AACF;AAEO,IAAM,eAAe,CAAC,WAA6B;AACxD,QAAM,CAAC,QAAQ,KAAK,IAAI,OAAO,MAAM,GAAG;AACxC,MAAI,CAAC,OAAO,WAAW,IAAI,KAAK,CAAC,MAAM,WAAW,IAAI,GAAG;AACvD,UAAM,IAAI,mBAAmB,yBAAyB,MAAM,EAAE;AAAA,EAChE;AACA,MAAI;AACF,4BAAW,SAAS,KAAK;AAAA,MACvB;AAAA,MACA;AAAA,IACF,CAAC;AACD,WAAO;AAAA,MACL,QAAQ,SAAS,MAAM;AAAA,MACvB,OAAO,SAAS,KAAK;AAAA,IACvB;AAAA,EACF,QAAQ;AACN,UAAM,IAAI,mBAAmB,6CAA6C,MAAM,EAAE;AAAA,EACpF;AACF;;;ATRA,IAAM,cAAc,CAAC,YAAiD;AAAA,EACpE,WAAW,OAAO;AAAA,EAClB,WAAW,OAAO;AAAA,EAClB,MAAM,OAAO;AACf;AAEO,IAAM,YAAN,MAAgB;AAAA,EACb;AAAA,EACA;AAAA,EAER,YAAY,EAAE,YAAY,cAAc,GAAkD;AACxF,SAAK,aAAa;AAClB,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,SAAS;AACP,WAAO,IAAI,oBAAAC,QAAI,KAAK,UAAU;AAAA,EAChC;AAAA,EAEA,MAAM,SAAS;AAAA,IACb;AAAA,IACA;AAAA,IACA,oBAAoB;AAAA,IACpB;AAAA,EACF,GAK2B;AACzB,QAAI,YAA8B,CAAC;AACnC,QAAI,MAAM;AACR,kBAAY;AAAA,QACV,oBAAoB;AAAA,QACpB,QAAQ,YAAY,IAAI;AAAA,QACxB,aAAa;AAAA,QACb,QAAQ;AAAA,UACN,QAAQ,OAAO,YAAY,IAAI,IAAI;AAAA,UACnC,uBAAuB,qBAAqB,CAAC,OAAO,CAAC,OAAO,KAAK,IAAI;AAAA,UACrE,uBAAuB;AAAA,QACzB;AAAA,MACF;AAAA,IACF,WAAW,MAAM;AACf,kBAAY;AAAA,QACV,oBAAoB;AAAA,QACpB,QAAQ,YAAY,IAAI;AAAA,QACxB,aAAa;AAAA,MACf;AAAA,IACF;AACA,UAAM,UAAU;AAAA,MACd,IAAI,KAAK,MAAM,KAAK,OAAO,IAAI,GAAM;AAAA,MACrC,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,QAAQ,CAAC,WAAW,OAAO,OAAO;AAAA,IACpC;AACA,UAAM,OAAO,KAAK,UAAU,SAAS,MAAM,IAAI;AAC/C,UAAM,YACJ,UAAM,cAAAC,SAAM;AAAA,MACV,QAAQ;AAAA,MACR,KAAK,KAAK;AAAA,MACV,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,MACA,SAAS;AAAA,MACT,MAAM;AAAA,IACR,CAAC,GACD;AACF,QAAI,SAAS,OAAO;AAClB,cAAQ,MAAM,SAAS,KAAK;AAC5B,YAAM,IAAI,aAAa,8BAA8B;AAAA,IACvD,OAAO;AACL,YAAM,MAAM,YAA2B,SAAS,OAAO,OAAO;AAC9D,UAAI,QAAQ,MAAM;AAChB,cAAM,IAAI,aAAa,kDAAkD;AAAA,MAC3E;AACA,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEA,cAAc,WAA0B,cAAsB,KAAa,QAAuC;AAChH,UAAM,iBAAiB,QAAQ,eAAe;AAC9C,UAAM,SAAoC,CAAC;AAC3C,QAAI,oBAAoB,OAAO,CAAC;AAChC,UAAM,cAAc,UAAU,SAAS,KAAK,2BAA2B,UAAU,CAAC,EAAE,MAAM;AAC1F,eAAW,QAAQ,WAAW;AAC5B,aAAO,KAAK;AAAA,QACV,gBAAgB;AAAA,UACd,QAAQ,KAAK,SAAS;AAAA,UACtB,OAAO,KAAK,SAAS;AAAA,QACvB;AAAA,QACA,OAAO;AAAA,MACT,CAAC;AACD,2BAAqB,OAAO,KAAK,OAAO,QAAQ;AAChD,UAAI,qBAAqB,eAAe,iBAAiB,OAAO,CAAC,aAAa;AAC5E;AAAA,MACF;AAAA,IACF;AACA,QAAI,oBAAoB,eAAe,iBAAiB,KAAK;AAC3D,YAAM,UAAU,QAAQ,UAAU;AAClC,YAAM,IAAI,uBAAuB,OAAO;AAAA,IAC1C;AACA,WAAO,EAAE,QAAQ,kBAAkB;AAAA,EACrC;AAAA,EAEA,iBAAiB,EAAE,WAAW,WAAW,GAAuE;AAC9G,UAAM,SAAoC,CAAC;AAC3C,QAAI,oBAAoB,OAAO,CAAC;AAChC,QAAI,YAAY,OAAO,CAAC;AACxB,UAAM,cAAc,UAAU,SAAS,KAAK,2BAA2B,UAAU,CAAC,EAAE,MAAM;AAC1F,eAAW,QAAQ,WAAW;AAC5B,UAAI,KAAK,eAAe,MAAM;AAC5B;AAAA,MACF;AACA,aAAO,KAAK;AAAA,QACV,gBAAgB;AAAA,UACd,QAAQ,KAAK,SAAS;AAAA,UACtB,OAAO,KAAK,SAAS;AAAA,QACvB;AAAA,QACA,OAAO;AAAA,MACT,CAAC;AACD,0BAAoB,oBAAoB,OAAO,KAAK,OAAO,QAAQ;AAGnE,mBAAa,SAAS,SAAS,KAAK,UAAU,EAAE,MAAM,GAAG,EAAE,CAAC;AAC5D,UAAI,aAAa,cAAc,CAAC,aAAa;AAC3C;AAAA,MACF;AAAA,IACF;AACA,QAAI,YAAY,YAAY;AAC1B,YAAM,IAAI,wBAAwB,0BAA0B;AAAA,IAC9D;AACA,WAAO,EAAE,QAAQ,mBAAmB,UAAU;AAAA,EAChD;AAAA,EAEA,MAAM,YAAY,UAAkC,WAAW,MAAuC;AACpG,UAAM,MAAM,IAAI,oBAAAD,QAAI,KAAK,UAAU;AACnC,UAAM,EAAE,KAAK,IAAI,MAAM,IAAI,IAAI,YAAY,UAAU,QAAQ;AAC7D,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,aAAa,WAAqC,WAAW,OAA0C;AAC3G,UAAM,MAAM,IAAI,oBAAAA,QAAI,KAAK,UAAU;AACnC,UAAM,QAAQ,IAAI,IAAI,mBAAmB,UAAU,IAAI,CAAC,aAAa,CAAC,eAAe,UAAU,QAAQ,CAAC,CAAC;AACzG,WAAO,MAAM,KAAK,EAAE,KAAK,CAAC,cAAc,UAAU,IAAI,CAAC,aAAa,SAAS,IAAI,CAAC;AAAA,EACpF;AACF;;;AUzKA,IAAAE,wBAAwF;AAExF,IAAM,yBAAyB,OAAO,EAAE,IAAI;AAErC,IAAM,+BAA+B,OAAO;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAgC;AAC9B,QAAM,YAAY,gBAAgB,WAAW,KAAK;AAClD,QAAM,oBAAgB,2CAAoB,kBAAkB;AAAA,IAC1D,QAAQ,YAAY,oCAAc,UAAU,oCAAc;AAAA,EAC5D,CAAC;AACD,QAAM,iBAAa,uCAAgB,aAAa;AAEhD,MAAI,aAAa,MAAM,UAAU,SAAS;AAAA,IACxC,MAAM;AAAA,EACR,CAAC;AACD,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,gBAAgB,gCAAgC;AAAA,EAC5D;AACA,eAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAE1D,QAAM,eAAe,OAAO,eAAe,IAAI;AAC/C,QAAM,eAAe,eAAe,OAAO,UAAU;AACrD,QAAM,QAAQ;AACd,QAAM,EAAE,QAAQ,kBAAkB,IAAI,UAAU,cAAc,YAAY,cAAc,OAAO;AAAA,IAC7F,aAAa;AAAA,EACf,CAAC;AAED,QAAM,UAAsC,IAAI,MAAM,UAAU,EAAE,KAAK;AAAA,IACrE,UAAM,uCAAgB,eAAe;AAAA,IACrC,UAAU,SAAS,aAAa,SAAS,EAAE,CAAC;AAAA,EAC9C,CAAC;AAED,QAAM,iBAAiB,oBAAoB,eAAe;AAC1D,UAAQ,KAAK;AAAA,IACX,MAAM;AAAA,IACN,UAAU,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAChD,CAAC;AACD,QAAM,cAAc,IAAI,MAAM,aAAa,CAAC,EAAE,KAAK,IAAI;AAEvD,QAAM,eAAe,EAAE,MAAM,IAAI,WAAW,IAAI,YAAY,GAAG;AAC/D,QAAM,YAAY,OAAO,IAAI,CAAC,GAAG,UAAW,UAAU,IAAI,eAAe,IAAK;AAE9E,QAAM,WAAW,CAAC,oBAAoB,SAAS,CAAC;AAEhD,QAAM,aAAa;AAAA,IACjB,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,UAAU,SAAS;AACrB,UAAM,aAAS,0CAAmB,UAAU,IAAI;AAChD,UAAM,iBAAiB,wBAAwB,MAAM;AACrD,UAAM,0BAA0B,kBAAkB,UAAU;AAC5D,eAAW,QAAQ,WAAW,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,wBAAwB,SAAS,EAAE,CAAC;AAAA,EAC5G;AAEA,QAAM,WAAW,UAAU,OAAO,EAAE,gBAAgB,gBAAgB,EAAE,UAAU;AAChF,QAAM,SAAS,MAAM,UAAU,OAAO,EAAE,IAAI,gBAAgB,UAAU,aAAa;AAEnF,UAAQ,KAAK,iDAAiD,MAAM,EAAE;AACxE;;;ACtCA,IAAAC,eAA2B;AAC3B,2BAA0B;AAC1B,IAAAC,wBAMO;AAcA,IAAM,6BAA6B,OAAO;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAuE;AACrE,QAAM,WAAW,wBAAW,OAAO,OAAO,aAAa;AAEvD,MAAI,CAAC,mBAAmB,UAAU,SAAS,GAAG;AAC5C,UAAM,IAAI,2BAA2B,4CAA4C;AAAA,EACnF;AAEA,QAAM,2BAA2B,gBAAgB,iBAAiB;AAElE,QAAM,aAAa,yBAAyB,IAAI,CAAC,SAAS,mBAAmB,MAAM,WAAW,cAAc,CAAC;AAC7G,MAAI,mBAAkC,CAAC;AACvC,MAAI,sBAAqC,CAAC;AAC1C,mBAAiB,aAAa,YAAY;AACxC,UAAM,QAAQ,MAAM,UAAU,SAAS,EAAE,MAAM,WAAW,mBAAmB,MAAM,CAAC;AAEpF,oCAAgC,OAAO,eAAe,SAAS;AAE/D,UAAM,cAAc,MAAO,OAAO,CAAC,SAAS,cAAc,KAAK,OAAO,MAAO,aAAa,CAAC;AAC3F,UAAM,iBAAiB,MAAO,OAAO,CAAC,SAAS,CAAC,cAAc,KAAK,OAAO,MAAO,aAAa,CAAC;AAC/F,uBAAmB,CAAC,GAAG,kBAAkB,GAAG,WAAW;AACvD,0BAAsB,CAAC,GAAG,qBAAqB,GAAG,cAAc;AAAA,EAClE;AACA,qBAAmB,iBAAiB,KAAK,aAAa;AACtD,wBAAsB,oBAAoB,KAAK,aAAa;AAE5D,MAAI,SAAoC,CAAC;AACzC,MAAI,oBAAoB,OAAO,CAAC;AAChC,QAAM,UAAsC,CAAC;AAC7C,QAAM,cAAqB,CAAC;AAC5B,MAAI,oBAAoB;AAGxB,QAAM,4BAA4B,CAAC,yBAAiC;AAClE,eAAW,CAAC,OAAO,cAAc,KAAK,oBAAoB,QAAQ,GAAG;AACnE,aAAO,KAAK;AAAA,QACV,gBAAgB,eAAe;AAAA,QAC/B,OAAO;AAAA,MACT,CAAC;AACD,2BAAqB,OAAO,eAAe,OAAO,QAAQ;AAC1D,cAAQ,KAAK;AAAA,QACX,GAAG,eAAe;AAAA;AAAA,QAElB,MAAM,mBAAmB,iBAAiB,uBAAuB,QAAQ,CAAC,GAAG,WAAW,cAAc;AAAA,MACxG,CAAC;AACD,kBAAY,KAAK,eAAe,UAAU;AAAA,IAC5C;AAAA,EACF;AAEA,MAAI,oBAAoB;AAEtB,eAAW,CAAC,OAAO,eAAe,KAAK,iBAAiB,QAAQ,GAAG;AACjE,aAAO,KAAK;AAAA,QACV,gBAAgB,gBAAgB;AAAA,QAChC,OAAO;AAAA,MACT,CAAC;AACD,2BAAqB,OAAO,gBAAgB,OAAO,QAAQ;AAC3D,cAAQ,KAAK;AAAA,QACX,GAAG,gBAAgB;AAAA;AAAA,QAEnB,MAAM,mBAAmB,iBAAiB,QAAQ,CAAC,GAAG,WAAW,cAAc;AAAA,MACjF,CAAC;AACD,kBAAY,KAAK,gBAAgB,UAAU;AAAA,IAC7C;AACA,8BAA0B,iBAAiB,MAAM;AAAA,EACnD,OAAO;AAEL,UAAM,gBAAgB,UAAU,iBAAiB;AAAA,MAC/C,WAAW;AAAA,MACX,YAAY;AAAA,IACd,CAAC;AACD,aAAS,cAAc;AACvB,mCAA+B,OAAO,MAAM;AAC5C,wBAAoB,cAAc;AAElC,UAAM,oBAAoB,2BAA2B,QAAQ;AAE7D,UAAM,kBAAkB,cAAc,YAAY;AAElD,UAAM,yBAAyB,kBAAkB,OAAO,iBAAiB,CAAC,EAAE,OAAO,QAAQ,IAAI;AAE/F,YAAQ,KAAK;AAAA,MACX,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,MACvE,MAAM;AAAA,MACN,UAAU,SAAS,uBAAuB,SAAS,EAAE,CAAC;AAAA,IACxD,CAAC;AACD,gBAAY,KAAK,SAAS,SAAS,cAAc,CAAC,CAAC;AAEnD,QAAI,iBAAiB;AACnB,YAAM,uBAAuB,mCAAmC,mBAAmB,sBAAsB;AACzG,0BAAoB,CAAC;AAErB,YAAM,oBAAoB,uBAAuB,oBAAoB,yBAAyB;AAE9F,cAAQ,KAAK;AAAA,QACX,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,QACvE,MAAM;AAAA,QACN,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,MACnD,CAAC;AACD,kBAAY,KAAK,SAAS,SAAS,cAAc,YAAY,cAAc,CAAC,CAAC;AAAA,IAC/E;AAEA,8BAA0B,QAAQ,MAAM;AAAA,EAC1C;AAEA,QAAM,WAAW,MAAM,oBAAoB,WAAW,EAAE,OAAO,MAAM,MAAM,KAAK,GAAG,cAAc;AACjG,MAAI,mBAAmB;AACrB,aAAS,KAAK,oBAAoB,SAAS,CAAC;AAAA,EAC9C;AACA,QAAM,YAAmB,CAAC;AAC1B,QAAM,cAA2B,oBAAI,IAAI;AACzC,QAAM,gBAAgB,iBAAiB,OAAO,mBAAmB;AACjE,aAAW,QAAQ,eAAe;AAChC,QAAI,YAAY,IAAI,KAAK,OAAO,KAAK,IAAI,GAAG;AAC1C,gBAAU,KAAK,IAAI;AAAA,IACrB,OAAO;AACL,kBAAY,IAAI,KAAK,OAAO,KAAK,IAAI;AACrC,gBAAU,KAAK,yBAAyB;AAAA,IAC1C;AAAA,EACF;AAEA,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAAC,mBAAmB;AACtB,UAAM,aACJ,0CAAmB,QAAQ,KAAK,8BAA8B,oBAAoB,wBAAwB;AAC5G,UAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AAEjE,UAAM,iBAAiB,OAAO,QAAQ,QAAQ,SAAS,CAAC,EAAE,QAAQ,IAAI;AACtE,aAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAC/F;AAEA,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,EAC5D;AACF;AAWO,IAAM,kCAAkC,OAAO;AAAA,EACpD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAiF;AAC/E,QAAM,WAAW,wBAAW,OAAO,OAAO,aAAa;AAEvD,MAAI,CAAC,mBAAmB,UAAU,SAAS,GAAG;AAC5C,UAAM,IAAI,2BAA2B,4CAA4C;AAAA,EACnF;AAEA,QAAM,aAAa,kBAAkB,IAAI,CAAC,SAAS,mBAAmB,MAAM,WAAW,cAAc,CAAC;AACtG,MAAI,aAA4B,CAAC;AACjC,mBAAiB,aAAa,YAAY;AACxC,UAAM,QAAQ,MAAM,UAAU,SAAS,EAAE,MAAM,WAAW,MAAM,SAAS,CAAC;AAC1E,QAAI,CAAC,SAAS,MAAM,WAAW,GAAG;AAChC,YAAM,IAAI,qBAAqB,wEAAwE;AAAA,IACzG;AACA,iBAAa,CAAC,GAAG,YAAY,GAAG,KAAK;AAAA,EACvC;AACA,eAAa,WAAW,KAAK,aAAa;AAE1C,QAAM,oBAAoB,eACvB,IAAI,CAAC,aAAa,SAAS,cAAc,EACzC,OAAO,CAAC,MAAM,YAAY,OAAO,SAAS,OAAO,CAAC,CAAC;AAEtD,QAAM,oBAAoB,2BAA2B,QAAQ;AAC7D,QAAM,UAAsC,eAAe,IAAI,CAAC,GAAG,WAAW;AAAA;AAAA,IAE5E,MAAM,mBAAmB,iBAAiB,QAAQ,CAAC,GAAG,WAAW,cAAc;AAAA,IAC/E,MAAM;AAAA,IACN,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,EACnD,EAAE;AACF,QAAM,cAAc,eAAe,IAAI,CAAC,aAAa,SAAS,SAAS,SAAS,cAAc,CAAC,CAAC;AAEhG,QAAM,EAAE,QAAQ,mBAAmB,UAAU,IAAI,UAAU,iBAAiB;AAAA,IAC1E,WAAW;AAAA,IACX,YAAY;AAAA,EACd,CAAC;AAED,iCAA+B,OAAO,MAAM;AAG5C,MAAI,sBAAsB;AAC1B,MAAI,YAAY,mBAAmB;AAEjC,0BAAsB,eAAe,SAAS;AAC9C,YAAQ,KAAK;AAAA;AAAA,MAEX,MAAM,mBAAmB,iBAAiB,mBAAmB,GAAG,WAAW,cAAc;AAAA,MACzF,MAAM;AAAA,MACN,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,IACnD,CAAC;AACD,gBAAY,KAAK,SAAS,SAAS,YAAY,iBAAiB,CAAC,CAAC;AAAA,EACpE;AAEA,QAAM,WAAW;AAAA,IACf,GAAI,MAAM,oBAAoB,WAAW,EAAE,OAAO,MAAM,MAAM,KAAK,GAAG,cAAc;AAAA,IACpF,oBAAoB,SAAS;AAAA,EAC/B;AACA,QAAM,YAAmB,CAAC;AAC1B,QAAM,cAA2B,oBAAI,IAAI;AACzC,aAAW,QAAQ,YAAY;AAC7B,QAAI,YAAY,IAAI,KAAK,OAAO,KAAK,IAAI,GAAG;AAC1C,gBAAU,KAAK,IAAI;AAAA,IACrB,OAAO;AACL,kBAAY,IAAI,KAAK,OAAO,KAAK,IAAI;AACrC,gBAAU,KAAK,yBAAyB;AAAA,IAC1C;AAAA,EACF;AAEA,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,IACnB,mBAAmB,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,EAC5D;AACF;AAYO,IAAM,qCAAqC,OAAO;AAAA,EACvD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAiF;AAC/E,QAAM,QAAQ;AAEd,QAAM,oBAAoB,MAAM,OAAO;AAEvC,QAAM,qBAA6B,MAAM,QACtC,IAAI,CAAC,WAAW,OAAO,OAAO,QAAQ,CAAC,EACvC,OAAO,CAAC,MAAM,YAAY,OAAO,SAAS,OAAO,CAAC,CAAC;AAEtD,QAAM,iBAAa,uCAAgB,aAAa;AAChD,MAAI,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,WAAW,CAAC;AAC9D,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,gBAAgB,uCAAuC;AAAA,EACnE;AACA,eAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAE1D,MAAI,uBAAuB,OAAO,iBAAiB;AACnD,QAAM,QAAQ;AACd,MAAI,wBAAwB,oBAAoB;AAC9C,UAAM,eAAe,qBAAqB,uBAAuB;AACjE,UAAM,EAAE,QAAQ,mBAAmB,iBAAiB,IAAI,UAAU,cAAc,YAAY,cAAc,KAAK;AAC/G,UAAM,SAAS,CAAC,GAAG,MAAM,QAAQ,GAAG,MAAM;AAC1C,4BAAwB;AAAA,EAC1B;AAEA,MAAI,iBAAiB,uBAAuB;AAC5C,QAAM,eAAe;AAAA,IACnB,MAAM;AAAA,IACN,UAAU,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAChD;AACA,QAAM,UAAU,CAAC,GAAG,MAAM,SAAS,YAAY;AAC/C,QAAM,cAAc,CAAC,GAAG,MAAM,aAAa,IAAI;AAE/C,QAAM,aAAS,0CAAmB,KAAK,IAAI;AAC3C,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAClB,QAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAEvF,QAAM,SAAS,oBAAI,IAAoB;AACvC,SAAO,QAAI,oCAAa,UAAU,GAAG,mBAAmB;AAExD,QAAM,kBAAkB;AACxB,QAAM,QAAQ,MAAM,OAAO,IAAI,CAAC,OAAO,WAAW;AAAA,IAChD,UAAU,MAAM;AAAA,IAChB,MAAM,SAAS,kBAAkB,aAAa,mBAAmB,SAAS;AAAA,EAC5E,EAAE;AAEF,QAAM,eAAe,EAAE,MAAM,IAAI,WAAW,IAAI,YAAY,GAAG;AAC/D,QAAM,kBAAkB,MAAM,OAAO,MAAM,iBAAiB,EAAE,IAAI,CAAC,GAAG,UAAW,UAAU,IAAI,eAAe,IAAK;AACnH,QAAM,YAAY,CAAC,GAAG,MAAM,WAAW,GAAG,eAAe;AAEzD,QAAM,sBAAkB,4CAAqB,KAAK;AAClD,QAAM,sBAAkB,qBAAAC,SAAc,MAAM,EAAE;AAAA,IAC5C;AAAA,IACA,WAAW,MAAM;AAAA,IACjB,YAAY;AAAA,IACZ,iBAAiB;AAAA,EACnB,CAAC;AAED,QAAM,WAAW;AAAA,IACf,GAAG;AAAA,IACH,WAAW,gBAAgB;AAAA,MAAI,CAAC,YAC9B,OAAO,YAAY,eAAW,4CAAqB,OAAO,IAAI;AAAA,IAChE;AAAA,EACF;AACA,SAAO;AACT;;;ACxYA,IAAAC,wBAA0B;AAC1B,IAAAC,wBAMO;AAEA,IAAM,0BAA0B,CACrC,YACA,YACA,WACA,eACQ;AACR,QAAM,WAAW,SAAS,QAAQ,SAAS,CAAC;AAC5C,QAAM,YAAY,SAAS,QAAQ,UAAU,CAAC;AAE9C,QAAM,UAAU,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC;AAClC,QAAM,cAAc,YAAY,KAAK;AAAA,IACnC;AAAA,IACA,WAAW,EAAE,UAAU,UAAU;AAAA,IACjC,OAAO,SAAS,UAAU;AAAA,IAC1B,YAAY,SAAS,UAAU;AAAA,EACjC,CAAC;AACD,SAAO,aAAS,kCAAW,WAAW,CAAC;AACzC;AAUO,IAAM,uBAAuB,OAAO;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AACF,MAAoE;AAClE,QAAM,QAAQ;AAEd,QAAM,EAAE,WAAW,MAAM,IAAI,kBAAkB,gBAAgB;AAC/D,QAAM,SAAS,KAAK,sBAAsB,SAAS,CAAC;AAEpD,QAAM,cAAc,wBAAwB,YAAY,OAAO,SAAS,OAAO,QAAQ,SAAS,QAAQ,MAAM;AAC9G,QAAM,eAAe,aAAS,4CAAqB,EAAE,MAAM,aAAa,WAAW,IAAI,YAAY,GAAG,CAAC,CAAC;AACxG,QAAM,YAAY,MAAM,UAAU,IAAI,CAAC,YAAa,YAAY,4BAA4B,eAAe,OAAQ;AAEnH,SAAO;AACT;AAUO,IAAM,kCAAkC,OAAO;AAAA,EACpD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAiF;AAC/E,QAAM,QAAQ;AACd,QAAM,iBAAiB,EAAE,gBAAgB,cAAc,UAAU,OAAO,MAAM;AAC9E,QAAM,SAAS,CAAC,GAAG,MAAM,QAAQ,cAAc;AAC/C,QAAM,iBAAiB,OAAO,iBAAiB,IAAI,OAAO,cAAc,OAAO,QAAQ;AAEvF,QAAM,qBAA6B,MAAM,QACtC,IAAI,CAAC,WAAW,OAAO,OAAO,QAAQ,CAAC,EACvC,OAAO,CAAC,MAAM,YAAY,OAAO,SAAS,OAAO,CAAC,CAAC;AAEtD,MAAI,kBAAkB,qBAAqB,cAAc;AACvD,UAAM,IAAI,6BAA6B,0CAA0C;AAAA,EACnF;AAEA,MAAI,iBAAiB,iBAAiB;AACtC,QAAM,eAAe;AAAA,IACnB,MAAM,cAAc,OAAO;AAAA,IAC3B,UAAU,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAChD;AACA,QAAM,UAAU,CAAC,GAAG,MAAM,SAAS,YAAY;AAC/C,QAAM,cAAc,CAAC,GAAG,MAAM,aAAa,IAAI;AAE/C,QAAM,aAAS,0CAAmB,KAAK,IAAI;AAC3C,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAClB,QAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAEvF,QAAM,SAAS,oBAAI,IAAoB;AACvC,SAAO,QAAI,oCAAa,cAAc,OAAO,IAAI,GAAG,mBAAmB;AACvE,SAAO,QAAI,oCAAa,mBAAmB,SAAS,CAAC,GAAG,EAAE;AAE1D,QAAM,qBAAqB,MAAM,OAAO,SAAS;AACjD,QAAM,QAAQ,MAAM,OAAO,IAAI,CAAC,OAAO,WAAW;AAAA,IAChD,UAAU,MAAM;AAAA,IAChB,MAAM,UAAU,qBAAqB,cAAc,OAAO,OAAO,mBAAmB,SAAS;AAAA,EAC/F,EAAE;AAEF,QAAM,eAAe,EAAE,MAAM,IAAI,WAAW,IAAI,YAAY,GAAG;AAC/D,QAAM,YAAY,CAAC,GAAG,MAAM,WAAW,YAAY;AAEnD,QAAM,sBAAkB,4CAAqB,KAAK;AAClD,QAAM,sBAAkB,sBAAAC,SAAc,MAAM,EAAE;AAAA,IAC5C;AAAA,IACA,WAAW,MAAM;AAAA,IACjB,YAAY;AAAA,IACZ,iBAAiB;AAAA,EACnB,CAAC;AAED,QAAM,WAAW;AAAA,IACf,GAAG;AAAA,IACH,WAAW,gBAAgB;AAAA,MAAI,CAAC,YAC9B,OAAO,YAAY,eAAW,4CAAqB,OAAO,IAAI;AAAA,IAChE;AAAA,EACF;AACA,SAAO;AACT;AAEO,IAAM,YAAY,OAAO,EAAE,WAAW,SAAS,MAAuB;AAC3E,QAAM,SAAS,MAAM,UAAU,OAAO,EAAE,IAAI,gBAAgB,UAAU,aAAa;AACnF,SAAO;AACT;AAQO,IAAM,6BAA6B,CAAC;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AACF,MAAsE;AACpE,QAAM,UAAU,SAAS,QAAQ,IAAI,CAAC,WAAW;AAC/C,QAAI,yBAAyB,OAAO,MAAM,SAAS,GAAG;AACpD,aAAO;AAAA,QACL,GAAG;AAAA,QACH,MAAM;AAAA,UACJ,GAAG,OAAO;AAAA,UACV,MAAM,+BAA+B,OAAO,KAAK,MAAM,OAAO;AAAA,QAChE;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT,CAAC;AACD,QAAM,WAAyC;AAAA,IAC7C,GAAG;AAAA,IACH;AAAA,EACF;AACA,SAAO;AACT;;;ACzJA,IAAAC,eAA2B;AAC3B,IAAAC,wBAAoD;AAc7C,IAAM,yBAAyB,OAAO;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAqE;AACnE,QAAM,YAAY,aAAa,WAAW,KAAK;AAC/C,QAAM,WAAW,wBAAW,OAAO,OAAO,aAAa;AAEvD,MAAI,CAAC,mBAAmB,UAAU,SAAS,GAAG;AAC5C,UAAM,IAAI,2BAA2B,4CAA4C;AAAA,EACnF;AAEA,QAAM,2BAA2B,gBAAgB,iBAAiB;AAElE,QAAM,aAAa,yBAAyB,IAAI,CAAC,SAAS,mBAAmB,MAAM,WAAW,cAAc,CAAC;AAC7G,MAAI,mBAAkC,CAAC;AACvC,MAAI,sBAAqC,CAAC;AAC1C,mBAAiB,aAAa,YAAY;AACxC,UAAM,QAAQ,MAAM,UAAU,SAAS,EAAE,MAAM,WAAW,mBAAmB,MAAM,CAAC;AAEpF,oCAAgC,OAAO,eAAe,SAAS;AAE/D,UAAM,cAAc,MAAO,OAAO,CAAC,SAAS,cAAc,KAAK,OAAO,MAAO,aAAa,CAAC;AAC3F,UAAM,iBAAiB,MAAO,OAAO,CAAC,SAAS,CAAC,cAAc,KAAK,OAAO,MAAO,aAAa,CAAC;AAC/F,uBAAmB,CAAC,GAAG,kBAAkB,GAAG,WAAW;AACvD,0BAAsB,CAAC,GAAG,qBAAqB,GAAG,cAAc;AAAA,EAClE;AACA,qBAAmB,iBAAiB,KAAK,aAAa;AACtD,wBAAsB,oBAAoB,KAAK,aAAa;AAE5D,QAAM;AAAA,IACJ;AAAA,IACA,mBAAmB;AAAA,IACnB;AAAA,EACF,IAAI,UAAU,iBAAiB;AAAA,IAC7B,WAAW;AAAA,IACX,YAAY;AAAA,EACd,CAAC;AACD,MAAI,oBAAoB;AAExB,iCAA+B,OAAO,MAAM;AAE5C,QAAM,oBAAoB,2BAA2B,QAAQ;AAE7D,QAAM,aAAS,uCAAgB,YAAY;AAC3C,MAAI,uBAAuB,OAAO,IAAI,GAAG;AACvC,UAAM,IAAI,MAAM,yDAAyD;AAAA,EAC3E;AAEA,MAAI,oBAAoB;AACxB,QAAM,kBAAkB,YAAY;AAEpC,QAAM,yBAAyB,kBAAkB,OAAO,iBAAiB,CAAC,EAAE,OAAO,QAAQ,IAAI;AAE/F,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,MAAM,qBAAqB,QAAQ,WAAW,gBAAgB,qBAAqB;AAAA,MACnF,MAAM;AAAA,MACN,UAAU,SAAS,uBAAuB,SAAS,EAAE,CAAC;AAAA,IACxD;AAAA,EACF;AACA,QAAM,cAAc,CAAC,SAAS,SAAS,cAAc,CAAC,CAAC;AAEvD,MAAI,iBAAiB;AACnB,UAAM,uBAAuB,mCAAmC,mBAAmB,sBAAsB;AACzG,wBAAoB,CAAC;AAErB,UAAM,oBAAoB,uBAAuB,oBAAoB,yBAAyB;AAC9F,YAAQ,KAAK;AAAA;AAAA,MAEX,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,MACvE,MAAM;AAAA,MACN,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,IACnD,CAAC;AACD,gBAAY,KAAK,SAAS,SAAS,YAAY,cAAc,CAAC,CAAC;AAAA,EACjE;AAEA,QAAM,uBAAuB,QAAQ;AACrC,aAAW,CAAC,OAAO,cAAc,KAAK,oBAAoB,QAAQ,GAAG;AACnE,WAAO,KAAK;AAAA,MACV,gBAAgB,eAAe;AAAA,MAC/B,OAAO;AAAA,IACT,CAAC;AACD,yBAAqB,OAAO,eAAe,OAAO,QAAQ;AAC1D,YAAQ,KAAK;AAAA,MACX,GAAG,eAAe;AAAA;AAAA,MAElB,MAAM,mBAAmB,iBAAiB,uBAAuB,QAAQ,CAAC,GAAG,WAAW,cAAc;AAAA,IACxG,CAAC;AACD,gBAAY,KAAK,eAAe,UAAU;AAAA,EAC5C;AAEA,QAAM,WAAW,MAAM,oBAAoB,WAAW,EAAE,OAAO,MAAM,MAAM,KAAK,GAAG,cAAc;AACjG,MAAI,mBAAmB;AACrB,aAAS,KAAK,oBAAoB,SAAS,CAAC;AAAA,EAC9C;AAEA,QAAM,YAAmB,CAAC;AAC1B,QAAM,cAA2B,oBAAI,IAAI;AACzC,QAAM,gBAAgB,iBAAiB,OAAO,mBAAmB;AACjE,aAAW,QAAQ,eAAe;AAChC,QAAI,YAAY,IAAI,KAAK,OAAO,KAAK,IAAI,GAAG;AAC1C,gBAAU,KAAK,IAAI;AAAA,IACrB,OAAO;AACL,kBAAY,IAAI,KAAK,OAAO,KAAK,IAAI;AACrC,gBAAU,KAAK,yBAAyB;AAAA,IAC1C;AAAA,EACF;AAEA,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,CAAC,mBAAmB;AACtB,UAAM,aACJ,0CAAmB,QAAQ,KAAK,8BAA8B,oBAAoB,wBAAwB;AAC5G,UAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,UAAM,iBAAiB,OAAO,QAAQ,QAAQ,SAAS,CAAC,EAAE,QAAQ,IAAI;AACtE,aAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAC/F;AAEA,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,EAC5D;AACF;;;ACvLA,IAAAC,wBAQO;AAoBP,IAAAC,wBAA0B;AAEnB,IAAM,4BAA4B,CAAC,eAAyB;AACjE,QAAM,gBAAgB,cAAc,KAAK,EAAE,WAAW,CAAC;AACvD,SAAO,aAAS,kCAAW,aAAa,CAAC;AAC3C;AAUO,IAAM,2BAA2B,OAAO;AAAA,EAC7C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAiE;AAC/D,QAAM,qBAAqB,aAAa,KAAK,aAAa;AAC1D,QAAM,SAAoC,mBAAmB,IAAI,CAAC,UAAU;AAAA,IAC1E,gBAAgB,KAAK;AAAA,IACrB,OAAO;AAAA,EACT,EAAE;AAEF,QAAM,UAAsC,mBAAmB,IAAI,CAAC,UAAU;AAAA,IAC5E,MAAM,8BAA8B,KAAK,OAAO,KAAK,IAAI;AAAA,IACzD,MAAM,KAAK,OAAO;AAAA,IAClB,UAAU,KAAK,OAAO;AAAA,EACxB,EAAE;AAEF,QAAM,cAAc,mBAAmB,IAAI,CAAC,SAAS,KAAK,UAAU;AAEpE,QAAM,WAAoC,MAAM;AAAA,IAC9C;AAAA,IACA,EAAE,SAAS,MAAM,MAAM,KAAK;AAAA,IAC5B;AAAA,EACF;AAEA,QAAM,YAAmB,CAAC;AAE1B,QAAM,cAA2B,oBAAI,IAAI;AACzC,QAAM,cAA2B,oBAAI,IAAI;AACzC,mBAAiB,eAAe,oBAAoB;AAClD,QAAI,YAAY,IAAI,YAAY,OAAO,KAAK,IAAI,GAAG;AACjD,gBAAU,KAAK,IAAI;AACnB;AAAA,IACF;AACA,gBAAY,IAAI,YAAY,OAAO,KAAK,IAAI;AAC5C,UAAM,EAAE,SAAS,MAAM,IAAI,mCAAmC,YAAY,OAAO,KAAK,IAAI;AAC1F,UAAM,SAAS,MAAM,aAAa,iBAAiB,SAAS,KAAK;AACjE,UAAM,EAAE,WAAW,MAAM,IAAI,kBAAkB,MAAM;AAErD,QAAI,CAAC,YAAY,QAAI,yCAAkB,SAAS,CAAC,GAAG;AAClD,eAAS,KAAK,sBAAsB,SAAS,CAAC;AAC9C,kBAAY,QAAI,yCAAkB,SAAS,CAAC;AAAA,IAC9C;AAEA,UAAM,iBAAiB;AAAA,UACrB,4CAAqB,EAAE,MAAM,0BAA0B,KAAK,GAAG,WAAW,IAAI,YAAY,GAAG,CAAC;AAAA,IAChG;AACA,cAAU,KAAK,cAAc;AAAA,EAC/B;AAEA,QAAM,QAAsC;AAAA,IAC1C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;AAYO,IAAM,yBAAyB,OAAO;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAuE;AACrE,QAAM,iBAAa,uCAAgB,gBAAgB;AACnD,MAAI,aAAa,MAAM,UAAU,SAAS;AAAA,IACxC,MAAM;AAAA,IACN;AAAA,EACF,CAAC;AACD,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,MAAM,qBAAqB;AAAA,EACvC;AACA,eAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAC1D,QAAM,aAAsC;AAAA,IAC1C,gBAAgB,WAAW,CAAC,EAAE;AAAA,IAC9B,OAAO;AAAA,EACT;AAEA,QAAM,eAAe,WAAW,CAAC,EAAE;AACnC,QAAM,QAAQ;AAAA,IACZ,GAAG;AAAA,IACH,UAAU,CAAC,GAAG,SAAS,UAAU,oBAAoB,SAAS,CAAC;AAAA,IAC/D,QAAQ,CAAC,YAAY,GAAG,SAAS,MAAM;AAAA,IACvC,SAAS,CAAC,cAAc,GAAG,SAAS,OAAO;AAAA,IAC3C,aAAa,CAAC,MAAM,GAAG,SAAS,WAAW;AAAA,IAC3C,WAAW,CAAC,EAAE,MAAM,IAAI,WAAW,IAAI,YAAY,GAAG,GAAG,GAAG,SAAS,SAAS;AAAA,EAChF;AAEA,QAAM,aAAS,0CAAmB,KAAK,IAAI;AAC3C,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AAEjE,QAAM,iBAAiB,OAAO,WAAW,CAAC,EAAE,OAAO,QAAQ,IAAI;AAC/D,QAAM,QAAQ,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAEhE,QAAM,SAAS,oBAAI,IAAoB;AACvC,SAAO,QAAI,oCAAa,UAAU,GAAG,mBAAmB;AAExD,QAAM,QAAQ,MAAM,OAAO,IAAI,CAAC,OAAO,WAAW;AAAA,IAChD,UAAU,MAAM;AAAA,IAChB,MAAM,UAAU,IAAI,aAAa,qBAAqB,SAAS;AAAA,EACjE,EAAE;AAEF,QAAM,sBAAkB,4CAAqB,KAAK;AAClD,QAAM,sBAAkB,sBAAAC,SAAc,MAAM,EAAE;AAAA,IAC5C;AAAA,IACA,WAAW,MAAM;AAAA,IACjB,YAAY;AAAA,IACZ,iBAAiB;AAAA,EACnB,CAAC;AAED,QAAM,WAAW;AAAA,IACf,GAAG;AAAA,IACH,WAAW,gBAAgB;AAAA,MAAI,CAAC,YAC9B,OAAO,YAAY,eAAW,4CAAqB,OAAO,IAAI;AAAA,IAChE;AAAA,EACF;AAEA,SAAO;AACT;AAQO,IAAM,sBAAsB,OAAO;AAAA,EACxC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAiD;AAC/C,QAAM,YAAY,WAAW,WAAW,KAAK;AAC7C,QAAM,WAAO,uCAAgB,UAAU;AACvC,QAAM,cAAoC;AAAA,IACxC,GAAG,qBAAqB,WAAW,cAAc;AAAA,IACjD,MAAM,mBAAmB,MAAM,SAAS,4BAA4B;AAAA,EACtE;AACA,QAAM,eAAe,MAAM,UAAU,SAAS,EAAE,MAAM,aAAa,mBAAmB,MAAM,CAAC;AAC7F,QAAM,UAAU,CAAC,gBAAgB,aAAa,WAAW;AACzD,SAAO;AACT;;;AC9LA,IAAAC,eAA2B;AAC3B,IAAAC,yBAAoD;AAa7C,IAAM,yBAAyB,OAAO;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAwE;AACtE,QAAM,YAAY,eAAe,WAAW,KAAK;AACjD,QAAM,WAAW,wBAAW,OAAO,OAAO,aAAa;AACvD,MAAI,CAAC,qBAAqB,UAAU,SAAS,GAAG;AAC9C,UAAM,IAAI,2BAA2B,4CAA4C;AAAA,EACnF;AAEA,QAAM,eAAW,wCAAgB,cAAc;AAE/C,QAAM,YAAY,MAAM,UAAU,SAAS,EAAE,MAAM,UAAU,MAAM,SAAS,CAAC;AAC7E,MAAI,CAAC,aAAa,UAAU,WAAW,GAAG;AACxC,UAAM,IAAI,oBAAoB,wEAAwE;AAAA,EACxG;AAEA,QAAM,YAAY,UAAU,iBAAiB;AAAA,IAC3C,WAAW;AAAA,IACX,YAAY;AAAA,EACd,CAAC;AAED,MAAI,EAAE,QAAQ,kBAAkB,IAAI;AACpC,QAAM,EAAE,UAAU,IAAI;AAEtB,QAAM,oBAAoB,2BAA2B,QAAQ;AAC7D,QAAM,cAAc,CAAC,SAAS,SAAS,cAAc,CAAC,CAAC;AAEvD,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,MAAM,mBAAmB,iBAAiB,WAAW,cAAc;AAAA,MACnE,MAAM;AAAA,MACN,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,IACnD;AAAA,EACF;AAEA,QAAM,QAAQ;AACd,QAAM,mBAAmB,yBAAyB,UAAU,QAAQ;AACpE,MAAI,oBAAoB,mBAAmB,oBAAoB,eAAe,OAAO;AACnF,QAAI,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,SAAS,CAAC;AAC5D,QAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,YAAM,IAAI,gBAAgB,gCAAgC;AAAA,IAC5D;AACA,iBAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAC1D,UAAM,EAAE,QAAQ,aAAa,mBAAmB,iBAAiB,IAAI,UAAU;AAAA,MAC7E;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,aAAS,CAAC,GAAG,aAAa,GAAG,MAAM;AACnC,yBAAqB;AAAA,EACvB;AAEA,MAAI,iBAAiB,oBAAoB,oBAAoB;AAC7D,MAAI,YAAY,gBAAgB;AAC9B,YAAQ,KAAK;AAAA,MACX,MAAM;AAAA,MACN,MAAM;AAAA,MACN,UAAU,SAAS,iBAAiB,SAAS,EAAE,CAAC;AAAA,IAClD,CAAC;AACD,gBAAY,KAAK,SAAS,SAAS,YAAY,cAAc,CAAC,CAAC;AAC/D,sBAAkB;AAAA,EACpB;AACA,UAAQ,KAAK;AAAA,IACX,MAAM;AAAA,IACN,UAAU,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAChD,CAAC;AACD,cAAY,KAAK,IAAI;AAErB,QAAM,WAAW,MAAM,oBAAoB,WAAW,EAAE,MAAM,KAAK,CAAC;AACpE,QAAM,YAAY,OAAO,IAAI,MAAM,IAAI;AAEvC,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,UAAU,SAAS;AACrB,UAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,UAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,UAAM,0BAA0B,kBAAkB,UAAU;AAC5D,aAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,wBAAwB,SAAS,EAAE,CAAC;AAAA,EACxG;AAEA,SAAO;AACT;AAYO,IAAM,8BAA8B,OAAO;AAAA,EAChD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA6E;AAC3E,QAAM,YAAY,eAAe,WAAW,KAAK;AACjD,QAAM,WAAW,wBAAW,OAAO,OAAO,aAAa;AACvD,MAAI,CAAC,qBAAqB,UAAU,SAAS,GAAG;AAC9C,UAAM,IAAI,2BAA2B,4CAA4C;AAAA,EACnF;AAEA,QAAM,eAAW,wCAAgB,cAAc;AAE/C,QAAM,YAAY,MAAM,UAAU,SAAS,EAAE,MAAM,UAAU,MAAM,SAAS,CAAC;AAC7E,MAAI,CAAC,aAAa,UAAU,WAAW,GAAG;AACxC,UAAM,IAAI,oBAAoB,wEAAwE;AAAA,EACxG;AAEA,QAAM,oBAAoB,eACvB,IAAI,CAAC,aAAa,SAAS,cAAc,EACzC,OAAO,CAAC,MAAM,YAAY,OAAO,SAAS,OAAO,CAAC,CAAC;AAEtD,QAAM,YAAY,UAAU,iBAAiB;AAAA,IAC3C,WAAW;AAAA,IACX,YAAY;AAAA,EACd,CAAC;AAED,MAAI,EAAE,QAAQ,kBAAkB,IAAI;AACpC,QAAM,EAAE,UAAU,IAAI;AAEtB,QAAM,oBAAoB,2BAA2B,QAAQ;AAC7D,QAAM,uBAAuB,oBAAoB,OAAO,eAAe,MAAM;AAC7E,QAAM,UAAsC,eAAe,IAAI,CAAC,cAAc;AAAA,IAC5E,MAAM,mBAAmB,SAAS,iBAAiB,WAAW,cAAc;AAAA,IAC5E,MAAM;AAAA,IACN,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,EACnD,EAAE;AACF,QAAM,cAAc,eAAe,IAAI,CAAC,aAAa,SAAS,SAAS,SAAS,cAAc,CAAC,CAAC;AAEhG,QAAM,QAAQ;AACd,QAAM,mBAAmB,yBAAyB,UAAU,QAAQ;AACpE,MAAI,oBAAoB,mBAAmB,uBAAuB,eAAe,OAAO;AACtF,QAAI,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,SAAS,CAAC;AAC5D,QAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,YAAM,IAAI,gBAAgB,gCAAgC;AAAA,IAC5D;AACA,iBAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAC1D,UAAM,EAAE,QAAQ,aAAa,mBAAmB,iBAAiB,IAAI,UAAU;AAAA,MAC7E;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,aAAS,CAAC,GAAG,aAAa,GAAG,MAAM;AACnC,yBAAqB;AAAA,EACvB;AAEA,MAAI,iBAAiB,oBAAoB,uBAAuB;AAChE,MAAI,YAAY,mBAAmB;AACjC,YAAQ,KAAK;AAAA,MACX,MAAM;AAAA,MACN,MAAM;AAAA,MACN,UAAU,SAAS,iBAAiB,SAAS,EAAE,CAAC;AAAA,IAClD,CAAC;AACD,gBAAY,KAAK,SAAS,SAAS,YAAY,iBAAiB,CAAC,CAAC;AAClE,sBAAkB;AAAA,EACpB;AACA,UAAQ,KAAK;AAAA,IACX,MAAM;AAAA,IACN,UAAU,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAChD,CAAC;AACD,cAAY,KAAK,IAAI;AAErB,QAAM,WAAW,MAAM,oBAAoB,WAAW,EAAE,MAAM,KAAK,CAAC;AACpE,QAAM,YAAY,OAAO,IAAI,MAAM,IAAI;AAEvC,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,UAAU,SAAS;AACrB,UAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,UAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,UAAM,0BAA0B,kBAAkB,UAAU;AAC5D,aAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,wBAAwB,SAAS,EAAE,CAAC;AAAA,EACxG;AAEA,SAAO;AACT;;;AChNA,IAAAC,yBAAiD;AAa1C,IAAM,6BAA6B,OAAO;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA0E;AACxE,QAAM,YAAY,mBAAmB,oBAAoB,WAAW,cAAc;AAClF,MAAI,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,UAAU,CAAC;AAC7D,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,gBAAgB,sCAAsC;AAAA,EAClE;AACA,eAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAC1D,QAAM,mBAAmB,oCAAoC,gBAAgB,SAAS;AAEtF,QAAM,QAAQ;AACd,QAAM,EAAE,QAAQ,kBAAkB,IAAI,UAAU,cAAc,YAAY,kBAAkB,KAAK;AAEjG,MAAI,oBAAoB,oBAAoB;AAC5C,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,MACvE,MAAM;AAAA,QACJ,GAAG,kBAAkB,SAAS;AAAA,QAC9B,MAAM,aAAS,qCAAa,SAAS,CAAC;AAAA,MACxC;AAAA,MACA,UAAU,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAAA,IACnD;AAAA,IACA;AAAA,MACE,MAAM,qBAAqB,wBAAwB,WAAW,cAAc;AAAA,MAC5E,MAAM;AAAA,QACJ,GAAG,oBAAoB,SAAS;AAAA,QAChC,MAAM,uBAAuB,OAAO,CAAC,GAAG,CAAC;AAAA,MAC3C;AAAA,MACA,UAAU,SAAS,iBAAiB,SAAS,EAAE,CAAC;AAAA,IAClD;AAAA,EACF;AAEA,QAAM,cAAc,CAAC,SAAS,SAAS,YAAY,CAAC,GAAG,qBAAqB,cAAc,CAAC;AAC3F,QAAM,WAAW,MAAM,oBAAoB,WAAW,EAAE,OAAO,MAAM,MAAM,MAAM,QAAQ,KAAK,GAAG,cAAc;AAE/G,QAAM,YAAmB,OAAO,IAAI,CAAC,GAAG,UAAW,UAAU,IAAI,4BAA4B,IAAK;AAElG,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,uBAAqB;AACrB,WAAS,QAAQ,CAAC,EAAE,WAAW,SAAS,kBAAkB,SAAS,EAAE,CAAC;AAEtE,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,IACH,SAAS,SAAS;AAAA,EACpB;AAEA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,EACrB;AACF;;;AC9GA,IAAAC,eAAmC;AAoBnC,IAAAC,yBAA+C;AAYxC,IAAM,+BAA+B,OAAO;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAsE;AACpE,QAAM,YAAY,mBAAmB,eAAe,WAAW,cAAc;AAC7E,QAAM,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,UAAU,CAAC;AAC/D,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,qBAAqB,+CAA+C;AAAA,EAChF;AACA,QAAM,YAAY,WAAW,CAAC;AAE9B,QAAM,SAAoC;AAAA,IACxC;AAAA,MACE,gBAAgB,UAAU;AAAA,MAC1B,OAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,YAAY,kBAAkB,OAAO,CAAC,GAAG,CAAC;AAChD,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,GAAG,UAAU;AAAA;AAAA,MAEb,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,MACvE,MAAM;AAAA,QACJ,GAAG,qBAAqB,SAAS;AAAA,QACjC,MAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,QAAM,cAAqB,KAAC,uCAAW,iCAAmB,WAAW,CAAC,CAAC;AACvE,QAAM,WAAW;AAAA,IACf,GAAI,MAAM,oBAAoB,WAAW,EAAE,OAAO,KAAK,GAAG,cAAc;AAAA,IACxE,kBAAkB,SAAS;AAAA,EAC7B;AACA,QAAM,eAAe,6BAA6B,QAAQ,CAAC,GAAG,YAAY,CAAC,CAAC;AAC5E,QAAM,YAAY,CAAC,2BAA2B,YAAY;AAE1D,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,iBAAiB,OAAO,UAAU,OAAO,QAAQ;AACrD,QAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAElB,WAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAE7F,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,EACrB;AACF;;;ACtGA,IAAAC,eAAiC;AA0CjC,IAAAC,wBAA0B;AAC1B,IAAAC,yBAOO;AAUA,IAAM,6BAA6B,OAAO;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA0E;AACxE,QAAM,mBAAmB,mBAAmB,sBAAsB,WAAW,cAAc;AAC3F,QAAM,eAAe,MAAM,UAAU,SAAS,EAAE,MAAM,kBAAkB,mBAAmB,MAAM,CAAC;AAClG,MAAI,CAAC,gBAAgB,aAAa,WAAW,GAAG;AAC9C,UAAM,IAAI,qBAAqB,+DAA+D;AAAA,EAChG;AACA,MAAI,aAAa,SAAS,GAAG;AAC3B,UAAM,IAAI,kCAAkC,sDAAsD;AAAA,EACpG;AACA,QAAM,cAAc,aAAa,CAAC;AAElC,MAAI,CAAC,YAAY,OAAO,QAAQ,CAAC,4BAA4B,YAAY,OAAO,MAAM,SAAS,GAAG;AAChG,UAAM,IAAI,2BAA2B,4CAA4C;AAAA,EACnF;AAEA,QAAM,oBAAoB,YAAY,OAAO;AAE7C,QAAM,SAAoC;AAAA,IACxC;AAAA,MACE,gBAAgB,YAAY;AAAA,MAC5B,OAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,iBAAwC;AAAA,IAC5C,UAAU,YAAY;AAAA,IACtB,SAAS;AAAA,EACX;AAEA,QAAM,eAAe,cAAc,IAAI,CAAC,MAAM,WAAW;AAAA;AAAA,IAEvD,MAAM,mBAAmB,iBAAiB,QAAQ,CAAC,GAAG,WAAW,cAAc;AAAA,IAC/E,MAAM;AAAA,MACJ,GAAG,mBAAmB,SAAS;AAAA;AAAA,MAE/B,MAAM,gBAAgB,OAAO,CAAC,GAAG,QAAQ,CAAC;AAAA,IAC5C;AAAA,IACA,UAAU,SAAS,gCAAgC,IAAI,EAAE,SAAS,EAAE,CAAC;AAAA,EACvE,EAAE;AACF,QAAM,mBAAmB,cAAc,IAAI,CAAC,aAAS,uCAAW,+BAAiB,IAAI,CAAC,CAAC;AAEvF,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,GAAG,YAAY;AAAA;AAAA,MAEf,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,IACzE;AAAA,IACA,GAAG;AAAA,EACL;AACA,QAAM,cAAqB,CAAC,YAAY,YAAY,GAAG,gBAAgB;AACvE,QAAM,WAAW;AAAA,IACf,GAAI,MAAM,oBAAoB,WAAW,EAAE,OAAO,KAAK,GAAG,cAAc;AAAA,IACxE,kBAAkB,SAAS;AAAA,IAC3B,gBAAgB,SAAS;AAAA,IACzB;AAAA,EACF;AACA,QAAM,eAAe,2BAA2B;AAAA,IAC9C;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB,QAAQ,CAAC;AAAA,EAC9B,CAAC;AACD,QAAM,YAAY,CAAC,2BAA2B,YAAY;AAE1D,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,EACrB;AACF;AAEA,IAAM,gBAAgB,KAAK,IAAI;AAWxB,IAAM,2CAA2C,OAAO;AAAA,EAC7D;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,6BAA6B;AAAA,EAC7B;AACF,MAAqF;AACnF,QAAM,QAAQ;AAEd,QAAM,qBAA6B,MAAM,QACtC,IAAI,CAAC,WAAW,OAAO,OAAO,QAAQ,CAAC,EACvC,OAAO,CAAC,MAAM,YAAY,OAAO,SAAS,OAAO,CAAC,CAAC;AAEtD,QAAM,iBAAa,wCAAgB,aAAa;AAChD,MAAI,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,WAAW,CAAC;AAC9D,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,gBAAgB,uCAAuC;AAAA,EACnE;AACA,eAAa,WAAW,OAAO,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI;AAE1D,MAAI,uBAAuB,OAAO,iBAAiB;AACnD,QAAM,QAAQ;AACd,MAAI,wBAAwB,oBAAoB;AAC9C,UAAM,eAAe,qBAAqB,uBAAuB;AACjE,UAAM,EAAE,QAAQ,mBAAmB,iBAAiB,IAAI,UAAU,cAAc,YAAY,cAAc,KAAK;AAC/G,UAAM,SAAS,CAAC,GAAG,MAAM,QAAQ,GAAG,MAAM;AAC1C,4BAAwB;AAAA,EAC1B;AAEA,MAAI,iBAAiB,uBAAuB;AAC5C,QAAM,eAAe;AAAA,IACnB,MAAM;AAAA,IACN,UAAU,SAAS,eAAe,SAAS,EAAE,CAAC;AAAA,EAChD;AACA,QAAM,UAAU,CAAC,GAAG,MAAM,SAAS,YAAY;AAC/C,QAAM,cAAc,CAAC,GAAG,MAAM,aAAa,IAAI;AAE/C,QAAM,aAAS,2CAAmB,KAAK,IAAI,6BAA6B;AACxE,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAClB,QAAM,QAAQ,MAAM,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAEvF,SAAO;AACT;AAYO,IAAM,iCAAiC,OAAO;AAAA,EACnD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA4E;AAC1E,QAAM,oBAAoB,SAAS,OAAO;AAE1C,QAAM,QAAQ,MAAM,yCAAyC;AAAA,IAC3D;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AAED,QAAM,WAAW,CAAC,GAAG,MAAM,UAAU,oBAAoB,SAAS,CAAC;AAEnE,QAAM,iBAAa,wCAAgB,aAAa;AAEhD,QAAM,SAAS,oBAAI,IAAoB;AACvC,SAAO,QAAI,qCAAa,UAAU,GAAG,mBAAmB;AAExD,QAAM,kBAAkB;AACxB,QAAM,QAAQ,MAAM,OAAO,IAAI,CAAC,OAAO,WAAW;AAAA,IAChD,UAAU,MAAM;AAAA,IAChB,MAAM,SAAS,kBAAkB,aAAa,mBAAmB,SAAS;AAAA,EAC5E,EAAE;AAEF,QAAM,eAAe,EAAE,MAAM,IAAI,WAAW,IAAI,YAAY,GAAG;AAC/D,QAAM,kBAAkB,MAAM,OAAO,MAAM,iBAAiB,EAAE,IAAI,CAAC,GAAG,UAAW,UAAU,IAAI,eAAe,IAAK;AAEnH,QAAM,wBAAwB,MAAM,UAAU,SAAS;AACvD,QAAM,YAAY;AAAA,IAChB,GAAG,MAAM,UAAU,MAAM,GAAG,qBAAqB;AAAA,IACjD,GAAG;AAAA;AAAA,IAEH,MAAM,UAAU,qBAAqB;AAAA,EACvC;AAEA,QAAM,sBAAkB,6CAAqB,KAAK;AAClD,QAAM,sBAAkB,sBAAAC,SAAc,MAAM,EAAE;AAAA,IAC5C;AAAA,IACA,WAAW,MAAM;AAAA,IACjB,YAAY;AAAA,IACZ,iBAAiB;AAAA,EACnB,CAAC;AAED,QAAM,WAAW;AAAA,IACf,GAAG;AAAA,IACH,WAAW,gBAAgB;AAAA,MAAI,CAAC,YAC9B,OAAO,YAAY,eAAW,6CAAqB,OAAO,IAAI;AAAA,IAChE;AAAA,EACF;AACA,SAAO;AACT;AAYO,IAAM,+BAA+B,OAAO;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA8E;AAC5E,QAAM,iBAAiB,mBAAmB,oBAAoB,WAAW,cAAc;AACvF,QAAM,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,gBAAgB,mBAAmB,MAAM,CAAC;AAE9F,kCAAgC,YAAY,gBAAgB,SAAS;AAErE,QAAM,YAAY,WAAY,CAAC;AAE/B,QAAM,SAAoC;AAAA,IACxC;AAAA,MACE,gBAAgB,UAAU;AAAA,MAC1B,OAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,GAAG,UAAU;AAAA;AAAA,MAEb,MAAM,mBAAmB,iBAAiB,CAAC,GAAG,WAAW,cAAc;AAAA,IACzE;AAAA,EACF;AACA,QAAM,cAAqB,CAAC,UAAU,UAAU;AAChD,QAAM,WAAW;AAAA,IACf,GAAI,MAAM,oBAAoB,WAAW,EAAE,OAAO,KAAK,GAAG,cAAc;AAAA,IACxE,gBAAgB,SAAS;AAAA,EAC3B;AACA,QAAM,eAAe,6BAA6B,CAAC,SAAS,GAAG,OAAO;AACtE,QAAM,YAAY,CAAC,2BAA2B,YAAY;AAE1D,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,iBAAiB,OAAO,UAAU,OAAO,QAAQ;AACrD,QAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAElB,WAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAE7F,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,IACnB,mBAAmB,UAAU,OAAO;AAAA,EACtC;AACF;;;AC1UA,IAAAC,eAA2B;AAC3B,IAAAC,yBAKO;AAaA,IAAM,oCAAoC,OAAO;AAAA,EACtD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAA+E;AAC7E,QAAM,iBAAiB;AAAA,IACrB,GAAG,mBAAmB,WAAW,cAAc;AAAA,IAC/C,MAAM,SAAS,kBAAkB;AAAA,EACnC;AACA,QAAM,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,gBAAgB,mBAAmB,MAAM,CAAC;AAE9F,kCAAgC,YAAY,gBAAgB,SAAS;AAErE,QAAM,YAAY,WAAY,CAAC;AAE/B,QAAM,SAAoC;AAAA,IACxC;AAAA,MACE,gBAAgB,UAAU;AAAA,MAC1B,OAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,aAAS,wCAAgB,YAAY;AAC3C,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,GAAG,UAAU;AAAA,MACb,MAAM,qBAAqB,QAAQ,WAAW,cAAc;AAAA,IAC9D;AAAA,EACF;AACA,QAAM,cAAqB,CAAC,UAAU,UAAU;AAChD,QAAM,WAAW;AAAA,IACf,GAAI,MAAM,oBAAoB,WAAW,EAAE,OAAO,KAAK,GAAG,cAAc;AAAA,IACxE,gBAAgB,SAAS;AAAA,EAC3B;AACA,QAAM,eAAe,6BAA6B,CAAC,SAAS,GAAG,OAAO;AACtE,QAAM,YAAY,CAAC,2BAA2B,YAAY;AAE1D,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,iBAAiB,OAAO,UAAU,OAAO,QAAQ;AACrD,QAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAElB,WAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAE7F,QAAM,YAA+B;AAAA,IACnC,GAAG;AAAA,EACL;AACA,QAAM,aAAa,oBAAoB,SAAS;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,mBAAmB;AAAA,IACnB,mBAAmB,UAAU,OAAO;AAAA,EACtC;AACF;AAUO,IAAM,gCAAgC,OAAO;AAAA,EAClD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAiE;AAC/D,QAAM,qBAAqB,aAAa,KAAK,aAAa;AAC1D,QAAM,SAAoC,mBAAmB,IAAI,CAAC,UAAU;AAAA,IAC1E,gBAAgB,KAAK;AAAA,IACrB,OAAO;AAAA,EACT,EAAE;AAEF,QAAM,UAAsC,mBAAmB,IAAI,CAAC,UAAU;AAAA,IAC5E,MAAM,8BAA8B,KAAK,OAAO,KAAK,IAAI;AAAA,IACzD,MAAM,KAAK,OAAO;AAAA,IAClB,UAAU,KAAK,OAAO;AAAA,EACxB,EAAE;AAEF,QAAM,cAAc,mBAAmB,IAAI,CAAC,SAAS,KAAK,UAAU;AAEpE,QAAM,WAAoC;AAAA,IACxC,GAAI,MAAM,oBAAoB,WAAW,EAAE,SAAS,KAAK,GAAG,cAAc;AAAA,IAC1E,gBAAgB,SAAS;AAAA,EAC3B;AAEA,QAAM,YAAmB,CAAC;AAE1B,QAAM,cAA2B,oBAAI,IAAI;AACzC,QAAM,cAA2B,oBAAI,IAAI;AACzC,mBAAiB,eAAe,oBAAoB;AAClD,QAAI,YAAY,IAAI,YAAY,OAAO,KAAK,IAAI,GAAG;AACjD,gBAAU,KAAK,IAAI;AACnB;AAAA,IACF;AACA,gBAAY,IAAI,YAAY,OAAO,KAAK,IAAI;AAC5C,UAAM,EAAE,SAAS,MAAM,IAAI,mCAAmC,YAAY,OAAO,KAAK,IAAI;AAC1F,UAAM,SAAS,MAAM,aAAa,iBAAiB,SAAS,KAAK;AACjE,UAAM,EAAE,WAAW,MAAM,IAAI,kBAAkB,MAAM;AAErD,QAAI,CAAC,YAAY,QAAI,0CAAkB,SAAS,CAAC,GAAG;AAClD,eAAS,KAAK,sBAAsB,SAAS,CAAC;AAC9C,kBAAY,QAAI,0CAAkB,SAAS,CAAC;AAAA,IAC9C;AAEA,UAAM,iBAAiB;AAAA,UACrB,6CAAqB,EAAE,MAAM,0BAA0B,KAAK,GAAG,WAAW,IAAI,YAAY,GAAG,CAAC;AAAA,IAChG;AACA,cAAU,KAAK,cAAc;AAAA,EAC/B;AAEA,QAAM,eAAe,6BAA6B,oBAAoB,OAAO;AAC7E,YAAU,KAAK,YAAY;AAE3B,QAAM,QAAsC;AAAA,IAC1C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,SAAO;AACT;AAYO,IAAM,gCAAgC,OAAO;AAAA,EAClD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAmF;AACjF,QAAM,eAAW,wCAAgB,cAAc;AAC/C,QAAM,YAAY,wBAAW,OAAO,OAAO,cAAc;AACzD,QAAM,aAAa,MAAM,UAAU,SAAS,EAAE,MAAM,UAAU,MAAM,UAAU,CAAC;AAC/E,MAAI,CAAC,cAAc,WAAW,WAAW,GAAG;AAC1C,UAAM,IAAI,qBAAqB,iFAAiF;AAAA,EAClH;AACA,QAAM,YAAY,WAAW,CAAC;AAE9B,QAAM,SAAoC;AAAA,IACxC;AAAA,MACE,gBAAgB,UAAU;AAAA,MAC1B,OAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,UAAsC;AAAA,IAC1C;AAAA,MACE,GAAG,UAAU;AAAA,MACb,MAAM;AAAA,QACJ,GAAG,mBAAmB,WAAW,cAAc;AAAA,QAC/C,MAAM,SAAS,eAAe;AAAA,MAChC;AAAA,IACF;AAAA,EACF;AACA,QAAM,cAAqB,CAAC,UAAU,UAAU;AAChD,QAAM,WAAW,CAAC,gBAAgB,SAAS,CAAC;AAC5C,QAAM,eAAe,6BAA6B,CAAC,SAAS,GAAG,OAAO;AACtE,QAAM,YAAY,CAAC,2BAA2B,YAAY;AAE1D,QAAM,WAAyC;AAAA,IAC7C,SAAS;AAAA,IACT;AAAA,IACA,YAAY,CAAC;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,MAAI,iBAAiB,OAAO,UAAU,OAAO,QAAQ;AACrD,QAAM,aAAS,2CAAmB,QAAQ,KAAK,8BAA8B;AAC7E,QAAM,iBAAiB,wBAAwB,QAAQ,UAAU;AACjE,oBAAkB;AAElB,WAAS,QAAQ,SAAS,QAAQ,SAAS,CAAC,EAAE,WAAW,SAAS,eAAe,SAAS,EAAE,CAAC;AAE7F,SAAO;AACT;","names":["import_codec","byte","import_codec","array","vector","union","option","struct","table","byteVecOf","fallbackBytesCodec","createFallbackFixedBytesCodec","byte","import_axios","camelcaseKeys","bytes","import_ckb_sdk_utils","import_ckb_sdk_utils","import_ckb_sdk_utils","actions","axios","import_base","CKB","axios","import_ckb_sdk_utils","import_base","import_ckb_sdk_utils","signWitnesses","import_signWitnesses","import_ckb_sdk_utils","signWitnesses","import_base","import_ckb_sdk_utils","import_ckb_sdk_utils","import_signWitnesses","signWitnesses","import_base","import_ckb_sdk_utils","import_ckb_sdk_utils","import_core","import_ckb_sdk_utils","import_core","import_signWitnesses","import_ckb_sdk_utils","signWitnesses","import_base","import_ckb_sdk_utils"]}