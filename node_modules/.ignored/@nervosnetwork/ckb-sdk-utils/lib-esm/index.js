import JSBI from 'jsbi';
import ECPair from './ecpair.js';
import { hexToBytes, toBigEndian } from './convertors/index.js';
import { pubkeyToAddress } from './address/index.js';
import { ParameterRequiredException, HexStringWithout0xException } from './exceptions/index.js';
import crypto from './crypto/index.js';
import { serializeScript } from './serialization/index.js';
import { cellOccupied } from './occupiedCapacity.js';
import { serializeRawTransaction, serializeTransaction, serializeWitnessArgs } from './serialization/transaction.js';
import { PERSONAL } from './const.js';
export * from './address/index.js';
export * from './serialization/index.js';
export * from './convertors/index.js';
export * from './exceptions/index.js';
export * from './const.js';
export * from './validators.js';
export * from './epochs.js';
export * from './sizes.js';
export * from './occupiedCapacity.js';
export * from './calculateTransactionFee.js';
export { ECPair };
import * as systemScripts_1 from './systemScripts.js';
export { systemScripts_1 as systemScripts };
import * as reconcilers_1 from './reconcilers/index.js';
export { reconcilers_1 as reconcilers };
export { serializeScript, serializeRawTransaction, serializeTransaction, serializeWitnessArgs, JSBI, PERSONAL };
export const { blake2b, bech32, bech32m, blake160 } = crypto;
export const scriptToHash = (script) => {
    if (!script)
        throw new ParameterRequiredException('Script');
    const serializedScript = serializeScript(script);
    const s = blake2b(32, null, null, PERSONAL);
    s.update(hexToBytes(serializedScript));
    const digest = s.digest('hex');
    return `0x${digest}`;
};
export const rawTransactionToHash = (rawTransaction) => {
    if (!rawTransaction)
        throw new ParameterRequiredException('Raw transaction');
    const serializedRawTransaction = serializeRawTransaction(rawTransaction);
    const s = blake2b(32, null, null, PERSONAL);
    s.update(hexToBytes(serializedRawTransaction));
    const digest = s.digest('hex');
    return `0x${digest}`;
};
export const privateKeyToPublicKey = (privateKey) => {
    const keyPair = new ECPair(privateKey);
    return keyPair.publicKey;
};
export const privateKeyToAddress = (privateKey, options) => pubkeyToAddress(privateKeyToPublicKey(privateKey), options);
export const extractDAOData = (dao) => {
    if (!dao.startsWith('0x')) {
        throw new HexStringWithout0xException(dao);
    }
    const value = dao.replace('0x', '');
    return {
        c: toBigEndian(`0x${value.slice(0, 16)}`),
        ar: toBigEndian(`0x${value.slice(16, 32)}`),
        s: toBigEndian(`0x${value.slice(32, 48)}`),
        u: toBigEndian(`0x${value.slice(48, 64)}`),
    };
};
export const calculateMaximumWithdraw = (outputCell, outputDataCapacity, depositDAO, withdrawDAO) => {
    const depositCellSerialized = cellOccupied(outputCell) + outputDataCapacity.slice(2).length / 2;
    const occupiedCapacity = JSBI.asUintN(128, JSBI.multiply(JSBI.BigInt(100000000), JSBI.BigInt(depositCellSerialized)));
    return `0x${JSBI.add(JSBI.divide(JSBI.multiply(JSBI.subtract(JSBI.asUintN(128, JSBI.BigInt(outputCell.capacity)), occupiedCapacity), JSBI.asUintN(128, JSBI.BigInt(extractDAOData(withdrawDAO).ar))), JSBI.asUintN(128, JSBI.BigInt(extractDAOData(depositDAO).ar))), occupiedCapacity).toString(16)}`;
};
//# sourceMappingURL=index.js.map