import * as bitcoin from 'bitcoinjs-lib';
export { bitcoin };
import limitPromiseConcurrency from 'p-limit';
import { BtcAssetsApi, BtcApiUtxoParams } from '@rgbpp-sdk/service';
import * as ecpair from 'ecpair';
export { ECPairInterface } from 'ecpair';
import { Collector } from '@rgbpp-sdk/ckb';
export { default as ecc } from '@bitcoinerlab/secp256k1';
export { isP2PKH, isP2TR, isP2WPKH } from 'bitcoinjs-lib/src/psbt/psbtutils.js';
export { isTaprootInput } from 'bitcoinjs-lib/src/psbt/bip371.js';

declare const ECPair: ecpair.ECPairAPI;

declare enum NetworkType {
    MAINNET = 0,
    TESTNET = 1,
    REGTEST = 2
}
interface RgbppBtcConfig {
    /**
     * The minimum fee rate that can be declared in a BTC transaction, in satoshi per byte.
     * Note this value can be different in different networks.
     */
    feeRate: number;
    /**
     * The minimum satoshi amount that can be declared in a BTC_UTXO.
     * BTC_UTXOs with satoshi below this constant are considered dust and will not be collected/created.
     * Officially, this constant should be 1,0000, but currently we are using 1,000 for testing purposes.
     */
    btcUtxoDustLimit: number;
    /**
     * The minimum satoshi amount that can be declared in a RGBPP_UTXO.
     * RGBPP_UTXOs with satoshi below this constant are considered dust and will not be created.
     */
    rgbppUtxoDustLimit: number;
    /**
     * The bitcoin-js lib predefined network object.
     * It contains crucial data to define what network we're working on.
     */
    network: bitcoin.Network;
    /**
     * The network type on RgbppBtc.
     * Note the "REGTEST" network is a deprecated network type, so you shouldn't use it.
     */
    networkType: NetworkType;
}

/**
 * Get RgbppBtcConfig by a network type.
 * If the network type is "REGTEST", it throws an unsupported network error.
 */
declare function networkTypeToConfig(networkType: NetworkType): RgbppBtcConfig;
/**
 * Get RgbppBtcConfig by a bitcoinjs-lib network object.
 * If the network is not recognized, it throws an unsupported network error.
 */
declare function networkToConfig(network: bitcoin.Network): RgbppBtcConfig;

/**
 * Convert network type to bitcoinjs-lib network.
 */
declare function networkTypeToNetwork(networkType: NetworkType): bitcoin.Network;
/**
 * Convert bitcoinjs-lib network to network type.
 */
declare function networkToNetworkType(network: bitcoin.Network): NetworkType;

interface TxInput {
    data: {
        hash: string;
        index: number;
        witnessUtxo: {
            value: number;
            script: Buffer;
        };
        tapInternalKey?: Buffer;
    };
    utxo: Utxo;
}
type TxOutput = TxAddressOutput | TxScriptOutput;
interface TxBaseOutput {
    value: number;
    fixed?: boolean;
    protected?: boolean;
    minUtxoSatoshi?: number;
}
interface TxAddressOutput extends TxBaseOutput {
    address: string;
}
interface TxScriptOutput extends TxBaseOutput {
    script: Buffer;
}
type InitOutput = TxAddressOutput | TxDataOutput | TxScriptOutput;
interface TxDataOutput extends TxBaseOutput {
    data: Buffer | string;
}
declare class TxBuilder {
    inputs: TxInput[];
    outputs: TxOutput[];
    source: DataSource;
    config: RgbppBtcConfig;
    networkType: NetworkType;
    onlyNonRgbppUtxos: boolean;
    onlyConfirmedUtxos: boolean;
    minUtxoSatoshi: number;
    feeRate?: number;
    constructor(props: {
        source: DataSource;
        onlyNonRgbppUtxos?: boolean;
        onlyConfirmedUtxos?: boolean;
        minUtxoSatoshi?: number;
        feeRate?: number;
    });
    hasInput(hash: string, index: number): boolean;
    addInput(utxo: Utxo): void;
    addInputs(utxos: Utxo[]): void;
    validateInputs(): Promise<void>;
    addOutput(output: InitOutput): void;
    addOutputs(outputs: InitOutput[]): void;
    payFee(props: {
        address: string;
        publicKey?: string;
        changeAddress?: string;
        deductFromOutputs?: boolean;
        excludeUtxos?: BaseOutput[];
        feeRate?: number;
    }): Promise<{
        fee: number;
        feeRate: number;
        changeIndex: number;
    }>;
    injectSatoshi(props: {
        address: string;
        publicKey?: string;
        targetAmount: number;
        changeAddress?: string;
        injectCollected?: boolean;
        deductFromOutputs?: boolean;
        internalCacheKey?: string;
        excludeUtxos?: BaseOutput[];
    }): Promise<{
        collected: number;
        changeIndex: number;
        changeAmount: number;
    }>;
    injectChange(props: {
        amount: number;
        address: string;
        fromAddress: string;
        fromPublicKey?: string;
        internalCacheKey?: string;
        excludeUtxos?: BaseOutput[];
    }): Promise<{
        changeIndex: number;
    }>;
    canInjectChangeToOutputs(changeAddress: string): boolean;
    calculateFee(feeRate?: number): Promise<number>;
    createEstimatedPsbt(): Promise<bitcoin.Psbt>;
    summary(): {
        inputsTotal: number;
        outputsTotal: number;
        inputsRemaining: number;
        outputsRemaining: number;
        needReturn: number;
        needCollect: number;
    };
    clone(): TxBuilder;
    toPsbt(): bitcoin.Psbt;
}

declare class DataCache {
    private utxos;
    constructor();
    setUtxos(key: string, utxos: Utxo[]): void;
    getUtxos(key: string): Utxo[] | undefined;
    cleanUtxos(key: string): void;
    optionalCacheUtxos(props: {
        key?: string;
        getter: () => Promise<Utxo[]> | Utxo[];
    }): Promise<Utxo[]>;
}

declare class DataSource {
    cache: DataCache;
    service: BtcAssetsApi;
    networkType: NetworkType;
    constructor(service: BtcAssetsApi, networkType: NetworkType);
    getUtxo(hash: string, index: number, requireConfirmed?: boolean): Promise<Utxo | undefined>;
    getOutput(hash: string, index: number, requireConfirmed?: boolean): Promise<Output | Utxo | undefined>;
    isTransactionConfirmed(hash: string): Promise<boolean>;
    getUtxos(address: string, params?: BtcApiUtxoParams): Promise<Utxo[]>;
    collectSatoshi(props: {
        address: string;
        targetAmount: number;
        minUtxoSatoshi?: number;
        allowInsufficient?: boolean;
        onlyNonRgbppUtxos?: boolean;
        onlyConfirmedUtxos?: boolean;
        noAssetsApiCache?: boolean;
        internalCacheKey?: string;
        excludeUtxos?: BaseOutput[];
    }): Promise<{
        utxos: Utxo[];
        satoshi: number;
        exceedSatoshi: number;
    }>;
    getPaymasterOutput(): Promise<TxAddressOutput | undefined>;
}

declare enum AddressType {
    P2PKH = 0,
    P2WPKH = 1,
    P2TR = 2,
    P2SH_P2WPKH = 3,
    P2WSH = 4,
    P2SH = 5,
    UNKNOWN = 6
}
/**
 * Type: Record<Address, Pubkey>
 *
 * The map of address and pubkey, usually for recognizing the P2TR inputs in the transaction.
 */
type AddressToPubkeyMap = Record<string, string>;
/**
 * Check weather the address is supported as a from address.
 * Currently, only P2WPKH and P2TR addresses are supported.
 */
declare function isSupportedFromAddress(address: string): boolean;
/**
 * Convert public key to bitcoin payment object.
 */
declare function publicKeyToPayment(publicKey: string, addressType: AddressType, networkType: NetworkType): bitcoin.payments.Payment | undefined;
/**
 * Convert public key to bitcoin address.
 */
declare function publicKeyToAddress(publicKey: string, addressType: AddressType, networkType: NetworkType): string;
/**
 * Convert bitcoin address to scriptPk.
 */
declare function addressToScriptPublicKey(address: string, networkType: NetworkType): Buffer;
/**
 * Convert bitcoin address to scriptPk in hex.
 */
declare function addressToScriptPublicKeyHex(address: string, networkType: NetworkType): string;
/**
 * Check if the address is valid.
 */
declare function isValidAddress(address: string, networkType: NetworkType): boolean;
/**
 * Get AddressType of an address.
 */
declare function getAddressType(address: string): AddressType;
declare function decodeAddress(address: string): {
    networkType: NetworkType;
    addressType: AddressType;
    dust: number;
};
/**
 * Add address/pubkey pair to a Record<address, pubkey> map
 */
declare function addAddressToPubkeyMap(pubkeyMap: AddressToPubkeyMap, address: string, pubkey?: string): Record<string, string>;

interface BaseOutput {
    txid: string;
    vout: number;
}
interface Output extends BaseOutput {
    value: number;
    scriptPk: string;
}
interface Utxo extends Output {
    addressType: AddressType;
    address: string;
    pubkey?: string;
}
declare function utxoToInput(utxo: Utxo): TxInput;
/**
 * Fill pubkey for P2TR UTXO, and optionally throw an error if pubkey is missing
 */
declare function fillUtxoPubkey(utxo: Utxo, pubkeyMap: AddressToPubkeyMap, options?: {
    requirePubkey?: boolean;
}): Utxo;
/**
 * Prepare and validate UTXOs for transaction building:
 * 1. Fill pubkey for P2TR UTXOs, and optionally throw an error if pubkey is missing
 * 2. Optionally check if the UTXOs are confirmed, and throw an error if not
 */
declare function prepareUtxoInputs(props: {
    utxos: Utxo[];
    source: DataSource;
    requirePubkey?: boolean;
    requireConfirmed?: boolean;
    pubkeyMap?: AddressToPubkeyMap;
}): Promise<Utxo[]>;

interface TweakableSigner extends bitcoin.Signer {
    privateKey?: Buffer;
}
declare function toXOnly(pubKey: Buffer): Buffer;
declare function tweakSigner<T extends TweakableSigner>(signer: T, options?: {
    network?: bitcoin.Network;
    tweakHash?: Buffer;
}): bitcoin.Signer;
/**
 * Remove '0x' prefix from a hex string.
 * @example
 * remove0x('0x1234') // => '1234'
 * remove0x('1234') // => '1234'
 */
declare function remove0x(hex: string): string;
/**
 * Convert UTF-8 raw text to buffer (binary bytes).
 * @example
 * utf8ToBuffer('0x1234') // => Uint8Array(2) [ 18, 52 ]
 * utf8ToBuffer('1234') // => Uint8Array(4) [ 49, 50, 51, 52 ]
 * utf8ToBuffer('hello') // => Uint8Array(5) [ 104, 101, 108, 108, 111 ]
 */
declare function utf8ToBuffer(text: string): Uint8Array;
/**
 * Convert a bitcoin.Transaction to hex string.
 * Note if using for RGBPP proof, shouldn't set the "withWitness" param to "true".
 */
declare function transactionToHex(tx: bitcoin.Transaction, withWitness?: boolean): string;
/**
 * Encode a UTXO's txid and vout to a string ID of "{txid}:{vout}".
 */
declare function encodeUtxoId(txid: string, vout: number): string;
/**
 * Decode a string ID of "{txid}:{vout}" format to a BaseOutput object.
 */
declare function decodeUtxoId(utxoId: string): BaseOutput;
/**
 * Limits the batch size of promises when querying with Promise.all().
 * @example
 * await Promise.all([
 *   limitPromiseBatchSize(() => asyncDoSomething()),
 *   limitPromiseBatchSize(() => asyncDoSomething()),
 *   limitPromiseBatchSize(() => asyncDoSomething()),
 *   ...
 * ]);
 */
declare const limitPromiseBatchSize: limitPromiseConcurrency.Limit;

declare enum ErrorCodes {
    UNKNOWN = 0,
    MISSING_PUBKEY = 20,
    CANNOT_FIND_UTXO = 21,
    UNCONFIRMED_UTXO = 22,
    INSUFFICIENT_UTXO = 23,
    REFERENCED_UNPROVABLE_UTXO = 24,
    UNSPENDABLE_OUTPUT = 25,
    DUPLICATED_UTXO = 26,
    DUST_OUTPUT = 27,
    UNSUPPORTED_OUTPUT = 28,
    INVALID_CHANGE_OUTPUT = 29,
    UNSUPPORTED_NETWORK_TYPE = 30,
    UNSUPPORTED_ADDRESS_TYPE = 31,
    UNSUPPORTED_OP_RETURN_SCRIPT = 32,
    INVALID_FEE_RATE = 33,
    PAYMASTER_MISMATCH = 34,
    INVALID_UTXO_ID = 35,
    CKB_CANNOT_FIND_OUTPOINT = 40,
    CKB_INVALID_CELL_LOCK = 41,
    CKB_INVALID_INPUTS = 42,
    CKB_INVALID_OUTPUTS = 43,
    CKB_UNMATCHED_COMMITMENT = 44,
    MEMPOOL_API_RESPONSE_ERROR = 60
}
declare const ErrorMessages: {
    0: string;
    20: string;
    21: string;
    22: string;
    23: string;
    24: string;
    26: string;
    25: string;
    27: string;
    28: string;
    29: string;
    30: string;
    31: string;
    32: string;
    33: string;
    34: string;
    35: string;
    40: string;
    41: string;
    42: string;
    43: string;
    44: string;
    60: string;
};
interface TxBuildErrorContext {
    tx?: TxBuilder;
}
declare class TxBuildError extends Error {
    code: ErrorCodes;
    context?: TxBuildErrorContext;
    constructor(code: ErrorCodes, message?: string, context?: TxBuildErrorContext);
    static withComment(code: ErrorCodes, comment?: string, context?: TxBuildErrorContext): TxBuildError;
    setContext(context: TxBuildErrorContext): void;
}

declare function isP2wpkhScript(script: Buffer | string): boolean;
declare function isP2trScript(script: Buffer | string): boolean;

/**
 * Convert data to OP_RETURN script pubkey.
 * The data size should be ranged in 1 to 80 bytes.
 *
 * @example
 * const data = Buffer.from('01020304', 'hex');
 * const scriptPk = dataToOpReturnScriptPubkey(data); // <Buffer 6a 04 01 02 03 04>
 * const scriptPkHex = scriptPk.toString('hex'); // 6a0401020304
 */
declare function dataToOpReturnScriptPubkey(data: Buffer | string): Buffer;
/**
 * Get data from a OP_RETURN script pubkey.
 *
 * @example
 * const scriptPk = Buffer.from('6a0401020304', 'hex');
 * const data = opReturnScriptPubKeyToData(scriptPk); // <Buffer 01 02 03 04>
 * const hex = data.toString('hex'); // 01020304
 */
declare function opReturnScriptPubKeyToData(script: Buffer): Buffer;
/**
 * Check if a script pubkey is an OP_RETURN script.
 *
 * A valid OP_RETURN script should have the following structure:
 * - <OP_RETURN code> <size: n> <data of n bytes>
 * - <OP_RETURN code> <OP_PUSHDATA1> <size: n> <data of n bytes>
 *
 * @example
 * // <OP_RETURN> <size: 0x04> <data: 01020304>
 * isOpReturnScriptPubkey(Buffer.from('6a0401020304', 'hex')); // true
 * // <OP_RETURN> <OP_PUSHDATA1> <size: 0x0f> <data: 746573742d636f6d6d69746d656e74>
 * isOpReturnScriptPubkey(Buffer.from('6a4c0f746573742d636f6d6d69746d656e74', 'hex')); // true
 * // <OP_RETURN> <OP_PUSHDATA1>
 * isOpReturnScriptPubkey(Buffer.from('6a4c', 'hex')); // false
 * // <OP_RETURN> <size: 0x01>
 * isOpReturnScriptPubkey(Buffer.from('6a01', 'hex')); // false
 * // <OP_DUP> ... (not an OP_RETURN script)
 * isOpReturnScriptPubkey(Buffer.from('76a914a802fc56c704ce87c42d7c92eb75e7896bdc41e788ac', 'hex')); // false
 */
declare function isOpReturnScriptPubkey(script: Buffer): boolean;

interface FeeEstimateAccount {
    payment: bitcoin.Payment;
    addressType: AddressType;
    address: string;
    scriptPubkey: string;
    tapInternalKey?: Buffer;
}
declare class FeeEstimator {
    networkType: NetworkType;
    network: bitcoin.Network;
    private readonly keyPair;
    readonly pubkey: string;
    accounts: {
        p2wpkh: FeeEstimateAccount;
        p2tr: FeeEstimateAccount;
    };
    constructor(wif: string, networkType: NetworkType);
    static fromRandom(networkType: NetworkType): FeeEstimator;
    replaceUtxo(utxo: Utxo): Utxo;
    signPsbt(psbt: bitcoin.Psbt): Promise<bitcoin.Psbt>;
}

interface SendBtcProps {
    from: string;
    tos: InitOutput[];
    source: DataSource;
    feeRate?: number;
    fromPubkey?: string;
    changeAddress?: string;
    minUtxoSatoshi?: number;
    onlyConfirmedUtxos?: boolean;
}
declare function createSendBtcBuilder(props: SendBtcProps): Promise<{
    builder: TxBuilder;
    fee: number;
    feeRate: number;
    changeIndex: number;
}>;
declare function sendBtc(props: SendBtcProps): Promise<bitcoin.Psbt>;

interface SendRbfProps {
    from: string;
    txHex: string;
    source: DataSource;
    feeRate?: number;
    fromPubkey?: string;
    changeIndex?: number;
    changeAddress?: string;
    minUtxoSatoshi?: number;
    onlyConfirmedUtxos?: boolean;
    requireValidOutputsValue?: boolean;
    requireGreaterFeeAndRate?: boolean;
    pubkeyMap?: AddressToPubkeyMap;
}
declare function createSendRbfBuilder(props: SendRbfProps): Promise<{
    builder: TxBuilder;
    fee: number;
    feeRate: number;
    changeIndex: number;
}>;
declare function sendRbf(props: SendRbfProps): Promise<bitcoin.Psbt>;

interface SendUtxosProps {
    inputs: Utxo[];
    outputs: InitOutput[];
    source: DataSource;
    from: string;
    feeRate?: number;
    fromPubkey?: string;
    changeAddress?: string;
    minUtxoSatoshi?: number;
    onlyConfirmedUtxos?: boolean;
    excludeUtxos?: BaseOutput[];
    skipInputsValidation?: boolean;
    pubkeyMap?: AddressToPubkeyMap;
}
declare function createSendUtxosBuilder(props: SendUtxosProps): Promise<{
    builder: TxBuilder;
    fee: number;
    feeRate: number;
    changeIndex: number;
}>;
declare function sendUtxos(props: SendUtxosProps): Promise<bitcoin.Psbt>;

interface SendRgbppUtxosProps {
    ckbVirtualTx: CKBComponents.RawTransaction;
    commitment: string;
    tos?: string[];
    paymaster?: TxAddressOutput;
    needPaymaster?: boolean;
    ckbCollector: Collector;
    rgbppMinUtxoSatoshi?: number;
    source: DataSource;
    from: string;
    feeRate?: number;
    fromPubkey?: string;
    changeAddress?: string;
    minUtxoSatoshi?: number;
    onlyConfirmedUtxos?: boolean;
    excludeUtxos?: BaseOutput[];
    pubkeyMap?: AddressToPubkeyMap;
}
/**
 * @deprecated Use createSendRgbppUtxosBuilder() API instead.
 */
declare const sendRgbppUtxosBuilder: typeof createSendRgbppUtxosBuilder;
declare function createSendRgbppUtxosBuilder(props: SendRgbppUtxosProps): Promise<{
    builder: TxBuilder;
    fee: number;
    feeRate: number;
    changeIndex: number;
}>;
declare function sendRgbppUtxos(props: SendRgbppUtxosProps): Promise<bitcoin.Psbt>;

export { type AddressToPubkeyMap, AddressType, type BaseOutput, DataSource, ECPair, ErrorCodes, ErrorMessages, FeeEstimator, type InitOutput, NetworkType, type Output, type RgbppBtcConfig, type SendBtcProps, type SendRbfProps, type SendRgbppUtxosProps, type SendUtxosProps, type TxAddressOutput, type TxBaseOutput, TxBuildError, type TxBuildErrorContext, TxBuilder, type TxDataOutput, type TxInput, type TxOutput, type TxScriptOutput, type Utxo, addAddressToPubkeyMap, addressToScriptPublicKey, addressToScriptPublicKeyHex, createSendBtcBuilder, createSendRbfBuilder, createSendRgbppUtxosBuilder, createSendUtxosBuilder, dataToOpReturnScriptPubkey, decodeAddress, decodeUtxoId, encodeUtxoId, fillUtxoPubkey, getAddressType, isOpReturnScriptPubkey, isP2trScript, isP2wpkhScript, isSupportedFromAddress, isValidAddress, limitPromiseBatchSize, networkToConfig, networkToNetworkType, networkTypeToConfig, networkTypeToNetwork, opReturnScriptPubKeyToData, prepareUtxoInputs, publicKeyToAddress, publicKeyToPayment, remove0x, sendBtc, sendRbf, sendRgbppUtxos, sendRgbppUtxosBuilder, sendUtxos, toXOnly, transactionToHex, tweakSigner, utf8ToBuffer, utxoToInput };
