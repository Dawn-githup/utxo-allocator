{"version":3,"sources":["../src/index.ts","../src/preset/types.ts","../src/preset/config.ts","../src/bitcoin.ts","../src/error.ts","../src/preset/network.ts","../src/utils.ts","../src/address.ts","../src/script.ts","../src/query/source.ts","../src/transaction/embed.ts","../src/query/cache.ts","../src/transaction/build.ts","../src/transaction/utxo.ts","../src/transaction/fee.ts","../src/api/sendUtxos.ts","../src/api/sendBtc.ts","../src/api/sendRbf.ts","../src/api/sendRgbppUtxos.ts"],"sourcesContent":["export * from './preset/types';\nexport * from './preset/config';\nexport * from './preset/network';\n\nexport * from './utils';\nexport * from './error';\nexport * from './bitcoin';\nexport * from './address';\nexport * from './script';\n\nexport * from './query/source';\n\nexport * from './transaction/build';\nexport * from './transaction/embed';\nexport * from './transaction/utxo';\nexport * from './transaction/fee';\n\nexport * from './api/sendBtc';\nexport * from './api/sendRbf';\nexport * from './api/sendUtxos';\nexport * from './api/sendRgbppUtxos';\n","import { bitcoin } from '../bitcoin';\n\nexport enum NetworkType {\n  MAINNET,\n  TESTNET,\n  REGTEST, // deprecated\n}\n\nexport interface RgbppBtcConfig {\n  /**\n   * The minimum fee rate that can be declared in a BTC transaction, in satoshi per byte.\n   * Note this value can be different in different networks.\n   */\n  feeRate: number;\n  /**\n   * The minimum satoshi amount that can be declared in a BTC_UTXO.\n   * BTC_UTXOs with satoshi below this constant are considered dust and will not be collected/created.\n   * Officially, this constant should be 1,0000, but currently we are using 1,000 for testing purposes.\n   */\n  btcUtxoDustLimit: number;\n  /**\n   * The minimum satoshi amount that can be declared in a RGBPP_UTXO.\n   * RGBPP_UTXOs with satoshi below this constant are considered dust and will not be created.\n   */\n  rgbppUtxoDustLimit: number;\n  /**\n   * The bitcoin-js lib predefined network object.\n   * It contains crucial data to define what network we're working on.\n   */\n  network: bitcoin.Network;\n  /**\n   * The network type on RgbppBtc.\n   * Note the \"REGTEST\" network is a deprecated network type, so you shouldn't use it.\n   */\n  networkType: NetworkType;\n}\n","import cloneDeep from 'lodash/cloneDeep.js';\nimport { bitcoin } from '../bitcoin';\nimport { ErrorCodes, TxBuildError } from '../error';\nimport { NetworkType, RgbppBtcConfig } from './types';\n\nconst defaultConfigs: Record<'testnet' | 'mainnet', RgbppBtcConfig> = {\n  testnet: {\n    feeRate: 1,\n    btcUtxoDustLimit: 1000,\n    rgbppUtxoDustLimit: 546,\n    network: bitcoin.networks.testnet,\n    networkType: NetworkType.TESTNET,\n  },\n  mainnet: {\n    feeRate: 20,\n    btcUtxoDustLimit: 10000,\n    rgbppUtxoDustLimit: 546,\n    network: bitcoin.networks.bitcoin,\n    networkType: NetworkType.MAINNET,\n  },\n};\n\n/**\n * Get RgbppBtcConfig by a network type.\n * If the network type is \"REGTEST\", it throws an unsupported network error.\n */\nexport function networkTypeToConfig(networkType: NetworkType): RgbppBtcConfig {\n  if (networkType === NetworkType.TESTNET) {\n    return cloneDeep(defaultConfigs.testnet);\n  }\n  if (networkType === NetworkType.MAINNET) {\n    return cloneDeep(defaultConfigs.mainnet);\n  }\n\n  throw new TxBuildError(ErrorCodes.UNSUPPORTED_NETWORK_TYPE);\n}\n\n/**\n * Get RgbppBtcConfig by a bitcoinjs-lib network object.\n * If the network is not recognized, it throws an unsupported network error.\n */\nexport function networkToConfig(network: bitcoin.Network): RgbppBtcConfig {\n  if (network.bech32 == bitcoin.networks.bitcoin.bech32) {\n    return cloneDeep(defaultConfigs.mainnet);\n  }\n  if (network.bech32 == bitcoin.networks.testnet.bech32) {\n    return cloneDeep(defaultConfigs.testnet);\n  }\n\n  throw new TxBuildError(ErrorCodes.UNSUPPORTED_NETWORK_TYPE);\n}\n","import ecc from '@bitcoinerlab/secp256k1';\nimport * as bitcoin from 'bitcoinjs-lib';\nimport { ECPairFactory, ECPairInterface } from 'ecpair';\nimport { isTaprootInput } from 'bitcoinjs-lib/src/psbt/bip371.js';\nimport { isP2TR, isP2WPKH, isP2PKH } from 'bitcoinjs-lib/src/psbt/psbtutils.js';\n\nbitcoin.initEccLib(ecc);\n\nconst ECPair = ECPairFactory(ecc);\n\nexport type { ECPairInterface };\nexport { ecc, ECPair, bitcoin, isP2TR, isP2PKH, isP2WPKH, isTaprootInput };\n","import { TxBuilder } from './transaction/build';\n\nexport enum ErrorCodes {\n  UNKNOWN,\n\n  MISSING_PUBKEY = 20,\n  CANNOT_FIND_UTXO,\n  UNCONFIRMED_UTXO,\n  INSUFFICIENT_UTXO,\n  REFERENCED_UNPROVABLE_UTXO,\n  UNSPENDABLE_OUTPUT,\n  DUPLICATED_UTXO,\n  DUST_OUTPUT,\n  UNSUPPORTED_OUTPUT,\n  INVALID_CHANGE_OUTPUT,\n  UNSUPPORTED_NETWORK_TYPE,\n  UNSUPPORTED_ADDRESS_TYPE,\n  UNSUPPORTED_OP_RETURN_SCRIPT,\n  INVALID_FEE_RATE,\n  PAYMASTER_MISMATCH,\n  INVALID_UTXO_ID,\n\n  CKB_CANNOT_FIND_OUTPOINT = 40,\n  CKB_INVALID_CELL_LOCK,\n  CKB_INVALID_INPUTS,\n  CKB_INVALID_OUTPUTS,\n  CKB_UNMATCHED_COMMITMENT,\n\n  MEMPOOL_API_RESPONSE_ERROR = 60,\n}\n\nexport const ErrorMessages = {\n  [ErrorCodes.UNKNOWN]: 'Unknown error',\n\n  [ErrorCodes.MISSING_PUBKEY]:\n    'Missing a pubkey that pairs with the address, it is required for the P2TR UTXO included in the transaction',\n  [ErrorCodes.CANNOT_FIND_UTXO]: 'Cannot find the UTXO, it may not exist or is not live',\n  [ErrorCodes.UNCONFIRMED_UTXO]: 'Unconfirmed UTXO',\n  [ErrorCodes.INSUFFICIENT_UTXO]: 'Insufficient UTXO to construct the transaction',\n  [ErrorCodes.REFERENCED_UNPROVABLE_UTXO]: 'Cannot reference a UTXO that does not belongs to \"from\"',\n  [ErrorCodes.DUPLICATED_UTXO]: 'Cannot reference the same UTXO twice',\n  [ErrorCodes.UNSPENDABLE_OUTPUT]: 'Target output is not an UTXO',\n  [ErrorCodes.DUST_OUTPUT]: 'Output defined value is below the dust limit',\n  [ErrorCodes.UNSUPPORTED_OUTPUT]: 'Unsupported output format',\n  [ErrorCodes.INVALID_CHANGE_OUTPUT]: 'Invalid change output',\n  [ErrorCodes.UNSUPPORTED_NETWORK_TYPE]: 'Unsupported network type',\n  [ErrorCodes.UNSUPPORTED_ADDRESS_TYPE]: 'Unsupported address type',\n  [ErrorCodes.UNSUPPORTED_OP_RETURN_SCRIPT]: 'Unsupported OP_RETURN script format',\n  [ErrorCodes.INVALID_FEE_RATE]: 'Invalid fee rate provided or recommended',\n  [ErrorCodes.PAYMASTER_MISMATCH]: 'Paymaster mismatched',\n  [ErrorCodes.INVALID_UTXO_ID]: 'Invalid UtxoId',\n\n  [ErrorCodes.CKB_CANNOT_FIND_OUTPOINT]: 'Cannot find CKB cell by OutPoint, it may not exist or is not live',\n  [ErrorCodes.CKB_INVALID_CELL_LOCK]: 'Invalid CKB cell lock, it should be RgbppLock, RgbppTimeLock or null',\n  [ErrorCodes.CKB_INVALID_INPUTS]: 'Invalid input(s) found in the CKB VirtualTx',\n  [ErrorCodes.CKB_INVALID_OUTPUTS]: 'Invalid output(s) found in the CKB VirtualTx',\n  [ErrorCodes.CKB_UNMATCHED_COMMITMENT]: 'Invalid commitment found in the CKB VirtualTx',\n\n  [ErrorCodes.MEMPOOL_API_RESPONSE_ERROR]: 'Mempool.space API returned an error',\n};\n\nexport interface TxBuildErrorContext {\n  tx?: TxBuilder;\n}\n\nexport class TxBuildError extends Error {\n  public code = ErrorCodes.UNKNOWN;\n  public context?: TxBuildErrorContext;\n\n  constructor(code: ErrorCodes, message = ErrorMessages[code] || 'Unknown error', context?: TxBuildErrorContext) {\n    super(message);\n    this.code = code;\n    this.context = context;\n    Object.setPrototypeOf(this, TxBuildError.prototype);\n  }\n\n  static withComment(code: ErrorCodes, comment?: string, context?: TxBuildErrorContext): TxBuildError {\n    const message: string | undefined = ErrorMessages[code];\n    return new TxBuildError(code, comment ? `${message}: ${comment}` : message, context);\n  }\n\n  setContext(context: TxBuildErrorContext) {\n    this.context = context;\n  }\n}\n","import { bitcoin } from '../bitcoin';\nimport { NetworkType } from './types';\nimport { networkToConfig, networkTypeToConfig } from './config';\n\n/**\n * Convert network type to bitcoinjs-lib network.\n */\nexport function networkTypeToNetwork(networkType: NetworkType): bitcoin.Network {\n  const config = networkTypeToConfig(networkType);\n  return config.network;\n}\n\n/**\n * Convert bitcoinjs-lib network to network type.\n */\nexport function networkToNetworkType(network: bitcoin.Network): NetworkType {\n  const config = networkToConfig(network);\n  return config.networkType;\n}\n","import limitPromiseConcurrency from 'p-limit';\nimport { bitcoin, ecc, ECPair } from './bitcoin';\nimport { bytes } from '@ckb-lumos/codec';\nimport { BaseOutput } from './transaction/utxo';\nimport { ErrorCodes, TxBuildError } from './error';\n\ninterface TweakableSigner extends bitcoin.Signer {\n  privateKey?: Buffer;\n}\n\nconst textEncoder = new TextEncoder();\n\nexport function toXOnly(pubKey: Buffer): Buffer {\n  return pubKey.length === 32 ? pubKey : pubKey.subarray(1, 33);\n}\n\nfunction tapTweakHash(publicKey: Buffer, hash: Buffer | undefined): Buffer {\n  return bitcoin.crypto.taggedHash('TapTweak', Buffer.concat(hash ? [publicKey, hash] : [publicKey]));\n}\n\nexport function tweakSigner<T extends TweakableSigner>(\n  signer: T,\n  options?: {\n    network?: bitcoin.Network;\n    tweakHash?: Buffer;\n  },\n): bitcoin.Signer {\n  if (!signer.privateKey) {\n    throw new Error('Private key is required for tweaking signer!');\n  }\n\n  let privateKey: Uint8Array = signer.privateKey;\n  if (signer.publicKey[0] === 3) {\n    privateKey = ecc.privateNegate(privateKey);\n  }\n\n  const tweakedPrivateKey = ecc.privateAdd(privateKey, tapTweakHash(toXOnly(signer.publicKey), options?.tweakHash));\n  if (!tweakedPrivateKey) {\n    throw new Error('Invalid tweaked private key!');\n  }\n\n  return ECPair.fromPrivateKey(Buffer.from(tweakedPrivateKey), {\n    network: options?.network,\n  });\n}\n\n/**\n * Remove '0x' prefix from a hex string.\n * @example\n * remove0x('0x1234') // => '1234'\n * remove0x('1234') // => '1234'\n */\nexport function remove0x(hex: string): string {\n  return hex.startsWith('0x') ? hex.slice(2) : hex;\n}\n\n/**\n * Convert UTF-8 raw text to buffer (binary bytes).\n * @example\n * utf8ToBuffer('0x1234') // => Uint8Array(2) [ 18, 52 ]\n * utf8ToBuffer('1234') // => Uint8Array(4) [ 49, 50, 51, 52 ]\n * utf8ToBuffer('hello') // => Uint8Array(5) [ 104, 101, 108, 108, 111 ]\n */\nexport function utf8ToBuffer(text: string): Uint8Array {\n  const result = text.trim();\n  if (result.startsWith('0x')) {\n    return bytes.bytify(result);\n  }\n\n  return textEncoder.encode(result);\n}\n\n/**\n * Convert a bitcoin.Transaction to hex string.\n * Note if using for RGBPP proof, shouldn't set the \"withWitness\" param to \"true\".\n */\nexport function transactionToHex(tx: bitcoin.Transaction, withWitness?: boolean): string {\n  const buffer: Buffer = tx['__toBuffer'](undefined, undefined, withWitness ?? false);\n  return buffer.toString('hex');\n}\n\n/**\n * Encode a UTXO's txid and vout to a string ID of \"{txid}:{vout}\".\n */\nexport function encodeUtxoId(txid: string, vout: number): string {\n  if (!txid || remove0x(txid).length !== 64) {\n    throw TxBuildError.withComment(ErrorCodes.INVALID_UTXO_ID, `txid=${txid}`);\n  }\n  if (vout < 0 || vout > 0xffffffff) {\n    throw TxBuildError.withComment(ErrorCodes.INVALID_UTXO_ID, `vout=${vout}`);\n  }\n\n  return `${remove0x(txid)}:${vout}`;\n}\n\n/**\n * Decode a string ID of \"{txid}:{vout}\" format to a BaseOutput object.\n */\nexport function decodeUtxoId(utxoId: string): BaseOutput {\n  const parts = utxoId.split(':');\n  const txid = parts[0];\n  const vout = parts[1] ? parseInt(parts[1]) : undefined;\n  if (\n    !txid ||\n    txid.startsWith('0x') ||\n    txid.length !== 64 ||\n    typeof vout !== 'number' ||\n    isNaN(vout) ||\n    vout < 0 ||\n    vout > 0xffffffff\n  ) {\n    throw TxBuildError.withComment(ErrorCodes.INVALID_UTXO_ID, utxoId);\n  }\n\n  return {\n    txid,\n    vout,\n  };\n}\n\n/**\n * Limits the batch size of promises when querying with Promise.all().\n * @example\n * await Promise.all([\n *   limitPromiseBatchSize(() => asyncDoSomething()),\n *   limitPromiseBatchSize(() => asyncDoSomething()),\n *   limitPromiseBatchSize(() => asyncDoSomething()),\n *   ...\n * ]);\n */\nexport const limitPromiseBatchSize = limitPromiseConcurrency(10);\n","import { bitcoin } from './bitcoin';\nimport { NetworkType } from './preset/types';\nimport { networkTypeToNetwork } from './preset/network';\nimport { ErrorCodes, TxBuildError } from './error';\nimport { remove0x, toXOnly } from './utils';\n\nexport enum AddressType {\n  P2PKH,\n  P2WPKH,\n  P2TR,\n  P2SH_P2WPKH,\n  P2WSH,\n  P2SH,\n  UNKNOWN,\n}\n\n/**\n * Type: Record<Address, Pubkey>\n *\n * The map of address and pubkey, usually for recognizing the P2TR inputs in the transaction.\n */\nexport type AddressToPubkeyMap = Record<string, string>;\n\n/**\n * Check weather the address is supported as a from address.\n * Currently, only P2WPKH and P2TR addresses are supported.\n */\nexport function isSupportedFromAddress(address: string) {\n  const { addressType } = decodeAddress(address);\n  return addressType === AddressType.P2WPKH || addressType === AddressType.P2TR;\n}\n\n/**\n * Convert public key to bitcoin payment object.\n */\nexport function publicKeyToPayment(publicKey: string, addressType: AddressType, networkType: NetworkType) {\n  if (!publicKey) {\n    return undefined;\n  }\n\n  const network = networkTypeToNetwork(networkType);\n  const pubkey = Buffer.from(remove0x(publicKey), 'hex');\n\n  if (addressType === AddressType.P2PKH) {\n    return bitcoin.payments.p2pkh({\n      pubkey,\n      network,\n    });\n  }\n  if (addressType === AddressType.P2WPKH) {\n    return bitcoin.payments.p2wpkh({\n      pubkey,\n      network,\n    });\n  }\n  if (addressType === AddressType.P2TR) {\n    return bitcoin.payments.p2tr({\n      internalPubkey: toXOnly(pubkey),\n      network,\n    });\n  }\n  if (addressType === AddressType.P2SH_P2WPKH) {\n    const data = bitcoin.payments.p2wpkh({\n      pubkey,\n      network,\n    });\n    return bitcoin.payments.p2sh({\n      pubkey,\n      network,\n      redeem: data,\n    });\n  }\n\n  return undefined;\n}\n\n/**\n * Convert public key to bitcoin address.\n */\nexport function publicKeyToAddress(publicKey: string, addressType: AddressType, networkType: NetworkType) {\n  const payment = publicKeyToPayment(publicKey, addressType, networkType);\n  if (payment && payment.address) {\n    return payment.address;\n  } else {\n    throw new TxBuildError(ErrorCodes.UNSUPPORTED_ADDRESS_TYPE);\n  }\n}\n\n/**\n * Convert bitcoin address to scriptPk.\n */\nexport function addressToScriptPublicKey(address: string, networkType: NetworkType): Buffer {\n  const network = networkTypeToNetwork(networkType);\n  return bitcoin.address.toOutputScript(address, network);\n}\n\n/**\n * Convert bitcoin address to scriptPk in hex.\n */\nexport function addressToScriptPublicKeyHex(address: string, networkType: NetworkType): string {\n  const scriptPk = addressToScriptPublicKey(address, networkType);\n  return scriptPk.toString('hex');\n}\n\n/**\n * Check if the address is valid.\n */\nexport function isValidAddress(address: string, networkType: NetworkType) {\n  try {\n    bitcoin.address.toOutputScript(address, networkTypeToNetwork(networkType));\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get AddressType of an address.\n */\nexport function getAddressType(address: string): AddressType {\n  return decodeAddress(address).addressType;\n}\n\nexport function decodeAddress(address: string): {\n  networkType: NetworkType;\n  addressType: AddressType;\n  dust: number;\n} {\n  const mainnet = bitcoin.networks.bitcoin;\n  const testnet = bitcoin.networks.testnet;\n  const regtest = bitcoin.networks.regtest;\n  let decodeBase58: bitcoin.address.Base58CheckResult;\n  let decodeBech32: bitcoin.address.Bech32Result;\n  let networkType: NetworkType | undefined;\n  let addressType: AddressType | undefined;\n  if (address.startsWith('bc1') || address.startsWith('tb1') || address.startsWith('bcrt1')) {\n    try {\n      decodeBech32 = bitcoin.address.fromBech32(address);\n      if (decodeBech32.prefix === mainnet.bech32) {\n        networkType = NetworkType.MAINNET;\n      } else if (decodeBech32.prefix === testnet.bech32) {\n        networkType = NetworkType.TESTNET;\n      } else if (decodeBech32.prefix === regtest.bech32) {\n        networkType = NetworkType.REGTEST;\n      }\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20) {\n          addressType = AddressType.P2WPKH;\n        } else if (decodeBech32.data.length === 32) {\n          addressType = AddressType.P2WSH;\n        }\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32) {\n          addressType = AddressType.P2TR;\n        }\n      }\n      if (networkType !== undefined && addressType !== undefined) {\n        return {\n          networkType,\n          addressType,\n          dust: getAddressTypeDust(addressType),\n        };\n      }\n    } catch (e) {\n      // Do nothing (no need to throw here)\n    }\n  } else {\n    try {\n      decodeBase58 = bitcoin.address.fromBase58Check(address);\n      if (decodeBase58.version === mainnet.pubKeyHash) {\n        networkType = NetworkType.MAINNET;\n        addressType = AddressType.P2PKH;\n      } else if (decodeBase58.version === testnet.pubKeyHash) {\n        networkType = NetworkType.TESTNET;\n        addressType = AddressType.P2PKH;\n      } else if (decodeBase58.version === regtest.pubKeyHash) {\n        // do not work\n        networkType = NetworkType.REGTEST;\n        addressType = AddressType.P2PKH;\n      } else if (decodeBase58.version === mainnet.scriptHash) {\n        networkType = NetworkType.MAINNET;\n        addressType = AddressType.P2SH_P2WPKH;\n      } else if (decodeBase58.version === testnet.scriptHash) {\n        networkType = NetworkType.TESTNET;\n        addressType = AddressType.P2SH_P2WPKH;\n      } else if (decodeBase58.version === regtest.scriptHash) {\n        // do not work\n        networkType = NetworkType.REGTEST;\n        addressType = AddressType.P2SH_P2WPKH;\n      }\n\n      if (networkType !== undefined && addressType !== undefined) {\n        return {\n          networkType,\n          addressType,\n          dust: getAddressTypeDust(addressType),\n        };\n      }\n    } catch (e) {\n      // Do nothing (no need to throw here)\n    }\n  }\n\n  return {\n    addressType: AddressType.UNKNOWN,\n    networkType: NetworkType.MAINNET,\n    dust: 546,\n  };\n}\n\nfunction getAddressTypeDust(addressType: AddressType) {\n  if (addressType === AddressType.P2WPKH) {\n    return 294;\n  } else if (addressType === AddressType.P2TR) {\n    return 330;\n  } else {\n    return 546;\n  }\n}\n\n/**\n * Add address/pubkey pair to a Record<address, pubkey> map\n */\nexport function addAddressToPubkeyMap(\n  pubkeyMap: AddressToPubkeyMap,\n  address: string,\n  pubkey?: string,\n): Record<string, string> {\n  const newMap = { ...pubkeyMap };\n  if (pubkey) {\n    newMap[address] = pubkey;\n  }\n  return newMap;\n}\n","import { isP2TR, isP2WPKH } from './bitcoin';\n\nexport function isP2wpkhScript(script: Buffer | string): boolean {\n  const buffer = typeof script === 'string' ? Buffer.from(script, 'hex') : script;\n  return isP2WPKH(buffer);\n}\n\nexport function isP2trScript(script: Buffer | string): boolean {\n  const buffer = typeof script === 'string' ? Buffer.from(script, 'hex') : script;\n  return isP2TR(buffer);\n}\n","import { BtcApiUtxoParams, BtcAssetsApi, BtcAssetsApiError, ErrorCodes as ServiceErrorCodes } from '@rgbpp-sdk/service';\nimport { BaseOutput, Output, Utxo } from '../transaction/utxo';\nimport { NetworkType } from '../preset/types';\nimport { ErrorCodes, TxBuildError } from '../error';\nimport { TxAddressOutput } from '../transaction/build';\nimport { isOpReturnScriptPubkey } from '../transaction/embed';\nimport { addressToScriptPublicKeyHex, getAddressType } from '../address';\nimport { remove0x } from '../utils';\nimport { DataCache } from './cache';\n\nexport class DataSource {\n  public cache: DataCache;\n  public service: BtcAssetsApi;\n  public networkType: NetworkType;\n\n  constructor(service: BtcAssetsApi, networkType: NetworkType) {\n    this.service = service;\n    this.networkType = networkType;\n    this.cache = new DataCache();\n  }\n\n  // Query a UTXO from the service.\n  // Will throw error if the target output is unspendable.\n  // When set \"confirmed = true\", will throw error if the output is unconfirmed.\n  async getUtxo(hash: string, index: number, requireConfirmed?: boolean): Promise<Utxo | undefined> {\n    const output = await this.getOutput(hash, index, requireConfirmed);\n    if (output && !('address' in output)) {\n      throw TxBuildError.withComment(ErrorCodes.UNSPENDABLE_OUTPUT, `hash: ${hash}, index: ${index}`);\n    }\n\n    return output;\n  }\n\n  // Query an output from the service.\n  // Both unspent or unspendable output can be queried from the API.\n  // When set \"confirmed = true\", will throw error if the output is unconfirmed.\n  async getOutput(hash: string, index: number, requireConfirmed?: boolean): Promise<Output | Utxo | undefined> {\n    const txId = remove0x(hash);\n    const tx = await this.service.getBtcTransaction(txId);\n    if (!tx) {\n      return undefined;\n    }\n    if (requireConfirmed && !tx.status.confirmed) {\n      throw TxBuildError.withComment(ErrorCodes.UNCONFIRMED_UTXO, `hash: ${hash}, index: ${index}`);\n    }\n    const vout = tx.vout[index];\n    if (!vout) {\n      return undefined;\n    }\n\n    const scriptBuffer = Buffer.from(vout.scriptpubkey, 'hex');\n    if (isOpReturnScriptPubkey(scriptBuffer)) {\n      return {\n        txid: txId,\n        vout: index,\n        value: vout.value,\n        scriptPk: vout.scriptpubkey,\n      } as Output;\n    }\n\n    return {\n      txid: txId,\n      vout: index,\n      value: vout.value,\n      scriptPk: vout.scriptpubkey,\n      address: vout.scriptpubkey_address,\n      addressType: getAddressType(vout.scriptpubkey_address),\n    } as Utxo;\n  }\n\n  async isTransactionConfirmed(hash: string): Promise<boolean> {\n    const tx = await this.service.getBtcTransaction(remove0x(hash));\n    return tx.status.confirmed;\n  }\n\n  async getUtxos(address: string, params?: BtcApiUtxoParams): Promise<Utxo[]> {\n    const utxos = await this.service.getBtcUtxos(address, params);\n\n    const scriptPk = addressToScriptPublicKeyHex(address, this.networkType);\n    return utxos\n      .sort((a, b) => {\n        const aBlockHeight = a.status.block_height;\n        const bBlockHeight = b.status.block_height;\n        if (aBlockHeight !== bBlockHeight) {\n          return aBlockHeight - bBlockHeight;\n        }\n        return a.vout - b.vout;\n      })\n      .map((row): Utxo => {\n        return {\n          address,\n          scriptPk,\n          txid: row.txid,\n          vout: row.vout,\n          value: row.value,\n          addressType: getAddressType(address),\n        };\n      });\n  }\n\n  async collectSatoshi(props: {\n    address: string;\n    targetAmount: number;\n    minUtxoSatoshi?: number;\n    allowInsufficient?: boolean;\n    onlyNonRgbppUtxos?: boolean;\n    onlyConfirmedUtxos?: boolean;\n    noAssetsApiCache?: boolean;\n    internalCacheKey?: string;\n    excludeUtxos?: BaseOutput[];\n  }): Promise<{\n    utxos: Utxo[];\n    satoshi: number;\n    exceedSatoshi: number;\n  }> {\n    const allowInsufficient = props.allowInsufficient ?? false;\n    const excludeUtxos = props.excludeUtxos ?? [];\n\n    const utxos = await this.cache.optionalCacheUtxos({\n      key: props.internalCacheKey,\n      getter: () =>\n        this.getUtxos(props.address, {\n          only_non_rgbpp_utxos: props.onlyNonRgbppUtxos,\n          only_confirmed: props.onlyConfirmedUtxos,\n          min_satoshi: props.minUtxoSatoshi,\n          no_cache: props.noAssetsApiCache,\n        }),\n    });\n\n    const collected = [];\n    let collectedAmount = 0;\n    for (const utxo of utxos) {\n      if (collectedAmount >= props.targetAmount) {\n        break;\n      }\n      if (excludeUtxos.length > 0) {\n        const excluded = excludeUtxos.find((exclude) => {\n          return exclude.txid === utxo.txid && exclude.vout === utxo.vout;\n        });\n        if (excluded) {\n          continue;\n        }\n      }\n      collected.push(utxo);\n      collectedAmount += utxo.value;\n    }\n\n    if (!allowInsufficient && collectedAmount < props.targetAmount) {\n      throw TxBuildError.withComment(\n        ErrorCodes.INSUFFICIENT_UTXO,\n        `expected: ${props.targetAmount}, actual: ${collectedAmount}`,\n      );\n    }\n\n    return {\n      utxos: collected,\n      satoshi: collectedAmount,\n      exceedSatoshi: collectedAmount - props.targetAmount,\n    };\n  }\n\n  async getPaymasterOutput(): Promise<TxAddressOutput | undefined> {\n    try {\n      const paymasterInfo = await this.service.getRgbppPaymasterInfo();\n      return {\n        address: paymasterInfo.btc_address,\n        value: paymasterInfo.fee,\n      };\n    } catch (err) {\n      if (err instanceof BtcAssetsApiError && err.code === ServiceErrorCodes.ASSETS_API_RESOURCE_NOT_FOUND) {\n        return undefined;\n      }\n      throw err;\n    }\n  }\n}\n","import { remove0x } from '../utils';\nimport { bitcoin } from '../bitcoin';\nimport { ErrorCodes, TxBuildError } from '../error';\n\n/**\n * Convert data to OP_RETURN script pubkey.\n * The data size should be ranged in 1 to 80 bytes.\n *\n * @example\n * const data = Buffer.from('01020304', 'hex');\n * const scriptPk = dataToOpReturnScriptPubkey(data); // <Buffer 6a 04 01 02 03 04>\n * const scriptPkHex = scriptPk.toString('hex'); // 6a0401020304\n */\nexport function dataToOpReturnScriptPubkey(data: Buffer | string): Buffer {\n  if (typeof data === 'string') {\n    data = Buffer.from(remove0x(data), 'hex');\n  }\n\n  const payment = bitcoin.payments.embed({ data: [data] });\n  return payment.output!;\n}\n\n/**\n * Get data from a OP_RETURN script pubkey.\n *\n * @example\n * const scriptPk = Buffer.from('6a0401020304', 'hex');\n * const data = opReturnScriptPubKeyToData(scriptPk); // <Buffer 01 02 03 04>\n * const hex = data.toString('hex'); // 01020304\n */\nexport function opReturnScriptPubKeyToData(script: Buffer): Buffer {\n  if (!isOpReturnScriptPubkey(script)) {\n    throw TxBuildError.withComment(ErrorCodes.UNSUPPORTED_OP_RETURN_SCRIPT, script.toString('hex'));\n  }\n\n  const res = bitcoin.script.decompile(script)!;\n  return res[1] as Buffer;\n}\n\n/**\n * Check if a script pubkey is an OP_RETURN script.\n *\n * A valid OP_RETURN script should have the following structure:\n * - <OP_RETURN code> <size: n> <data of n bytes>\n * - <OP_RETURN code> <OP_PUSHDATA1> <size: n> <data of n bytes>\n *\n * @example\n * // <OP_RETURN> <size: 0x04> <data: 01020304>\n * isOpReturnScriptPubkey(Buffer.from('6a0401020304', 'hex')); // true\n * // <OP_RETURN> <OP_PUSHDATA1> <size: 0x0f> <data: 746573742d636f6d6d69746d656e74>\n * isOpReturnScriptPubkey(Buffer.from('6a4c0f746573742d636f6d6d69746d656e74', 'hex')); // true\n * // <OP_RETURN> <OP_PUSHDATA1>\n * isOpReturnScriptPubkey(Buffer.from('6a4c', 'hex')); // false\n * // <OP_RETURN> <size: 0x01>\n * isOpReturnScriptPubkey(Buffer.from('6a01', 'hex')); // false\n * // <OP_DUP> ... (not an OP_RETURN script)\n * isOpReturnScriptPubkey(Buffer.from('76a914a802fc56c704ce87c42d7c92eb75e7896bdc41e788ac', 'hex')); // false\n */\nexport function isOpReturnScriptPubkey(script: Buffer): boolean {\n  const scripts = bitcoin.script.decompile(script);\n  if (!scripts || scripts.length !== 2) {\n    return false;\n  }\n\n  const [op, data] = scripts!;\n  // OP_RETURN opcode is 0x6a in hex or 106 in integer\n  if (op !== bitcoin.opcodes.OP_RETURN) {\n    return false;\n  }\n  // Standard OP_RETURN data size is up to 80 bytes\n  if (!(data instanceof Buffer) || data.byteLength < 1 || data.byteLength > 80) {\n    return false;\n  }\n\n  // No false condition matched, it's an OP_RETURN script\n  return true;\n}\n","import { Utxo } from '../transaction/utxo';\n\nexport class DataCache {\n  private utxos: Map<string, Utxo[]>; // Map<Key, Utxo[]>\n\n  constructor() {\n    this.utxos = new Map();\n  }\n\n  setUtxos(key: string, utxos: Utxo[]) {\n    this.utxos.set(key, utxos);\n  }\n  getUtxos(key: string): Utxo[] | undefined {\n    return this.utxos.get(key);\n  }\n  cleanUtxos(key: string) {\n    if (this.utxos.has(key)) {\n      this.utxos.delete(key);\n    }\n  }\n  async optionalCacheUtxos(props: { key?: string; getter: () => Promise<Utxo[]> | Utxo[] }): Promise<Utxo[]> {\n    if (props.key && this.utxos.has(props.key)) {\n      return this.getUtxos(props.key) as Utxo[];\n    }\n\n    const utxos = await props.getter();\n    if (props.key) {\n      this.setUtxos(props.key, utxos);\n    }\n\n    return utxos;\n  }\n}\n","import cloneDeep from 'lodash/cloneDeep.js';\nimport { bitcoin } from '../bitcoin';\nimport { DataSource } from '../query/source';\nimport { ErrorCodes, TxBuildError } from '../error';\nimport { NetworkType, RgbppBtcConfig } from '../preset/types';\nimport { isSupportedFromAddress } from '../address';\nimport { dataToOpReturnScriptPubkey, isOpReturnScriptPubkey } from './embed';\nimport { networkTypeToConfig } from '../preset/config';\nimport { BaseOutput, Utxo, utxoToInput } from './utxo';\nimport { limitPromiseBatchSize } from '../utils';\nimport { FeeEstimator } from './fee';\n\nexport interface TxInput {\n  data: {\n    hash: string;\n    index: number;\n    witnessUtxo: { value: number; script: Buffer };\n    tapInternalKey?: Buffer;\n  };\n  utxo: Utxo;\n}\n\nexport type TxOutput = TxAddressOutput | TxScriptOutput;\nexport interface TxBaseOutput {\n  value: number;\n  fixed?: boolean;\n  protected?: boolean;\n  minUtxoSatoshi?: number;\n}\nexport interface TxAddressOutput extends TxBaseOutput {\n  address: string;\n}\nexport interface TxScriptOutput extends TxBaseOutput {\n  script: Buffer;\n}\n\nexport type InitOutput = TxAddressOutput | TxDataOutput | TxScriptOutput;\nexport interface TxDataOutput extends TxBaseOutput {\n  data: Buffer | string;\n}\n\nexport class TxBuilder {\n  inputs: TxInput[] = [];\n  outputs: TxOutput[] = [];\n\n  source: DataSource;\n  config: RgbppBtcConfig;\n  networkType: NetworkType;\n  onlyNonRgbppUtxos: boolean;\n  onlyConfirmedUtxos: boolean;\n  minUtxoSatoshi: number;\n  feeRate?: number;\n\n  constructor(props: {\n    source: DataSource;\n    onlyNonRgbppUtxos?: boolean;\n    onlyConfirmedUtxos?: boolean;\n    minUtxoSatoshi?: number;\n    feeRate?: number;\n  }) {\n    this.source = props.source;\n    this.networkType = this.source.networkType;\n    this.config = networkTypeToConfig(this.networkType);\n    this.onlyNonRgbppUtxos = props.onlyNonRgbppUtxos ?? true;\n    this.onlyConfirmedUtxos = props.onlyConfirmedUtxos ?? false;\n    this.minUtxoSatoshi = props.minUtxoSatoshi ?? this.config.btcUtxoDustLimit;\n    this.feeRate = props.feeRate;\n  }\n\n  hasInput(hash: string, index: number): boolean {\n    return this.inputs.some((input) => input.data.hash === hash && input.data.index === index);\n  }\n\n  addInput(utxo: Utxo) {\n    if (this.hasInput(utxo.txid, utxo.vout)) {\n      throw TxBuildError.withComment(ErrorCodes.DUPLICATED_UTXO, `hash: ${utxo.txid}, index: ${utxo.vout}`);\n    }\n\n    utxo = cloneDeep(utxo);\n    this.inputs.push(utxoToInput(utxo));\n  }\n\n  addInputs(utxos: Utxo[]) {\n    utxos.forEach((utxo) => {\n      this.addInput(utxo);\n    });\n  }\n\n  async validateInputs() {\n    await Promise.all(\n      this.inputs.map(async (input) => {\n        return limitPromiseBatchSize(async () => {\n          const transactionConfirmed = await this.source.isTransactionConfirmed(input.data.hash);\n          if (!transactionConfirmed) {\n            throw TxBuildError.withComment(\n              ErrorCodes.UNCONFIRMED_UTXO,\n              `hash: ${input.data.hash}, index: ${input.data.index}`,\n            );\n          }\n        });\n      }),\n    );\n  }\n\n  addOutput(output: InitOutput) {\n    let result: TxOutput | undefined;\n\n    if ('data' in output) {\n      result = {\n        script: dataToOpReturnScriptPubkey(output.data),\n        value: output.value,\n        fixed: output.fixed,\n        protected: output.protected,\n        minUtxoSatoshi: output.minUtxoSatoshi,\n      };\n    }\n    if ('address' in output || 'script' in output) {\n      result = cloneDeep(output);\n    }\n    if (!result) {\n      throw new TxBuildError(ErrorCodes.UNSUPPORTED_OUTPUT);\n    }\n\n    const minUtxoSatoshi = result.minUtxoSatoshi ?? this.minUtxoSatoshi;\n    const isOpReturnOutput = 'script' in result && isOpReturnScriptPubkey(result.script);\n    if (!isOpReturnOutput && result.value < minUtxoSatoshi) {\n      throw TxBuildError.withComment(ErrorCodes.DUST_OUTPUT, `expected ${minUtxoSatoshi}, but defined ${result.value}`);\n    }\n\n    this.outputs.push(result);\n  }\n\n  addOutputs(outputs: InitOutput[]) {\n    outputs.forEach((output) => {\n      this.addOutput(output);\n    });\n  }\n\n  async payFee(props: {\n    address: string;\n    publicKey?: string;\n    changeAddress?: string;\n    deductFromOutputs?: boolean;\n    excludeUtxos?: BaseOutput[];\n    feeRate?: number;\n  }): Promise<{\n    fee: number;\n    feeRate: number;\n    changeIndex: number;\n  }> {\n    const { address, publicKey, feeRate, changeAddress, deductFromOutputs, excludeUtxos } = props;\n    const originalInputs = cloneDeep(this.inputs);\n    const originalOutputs = cloneDeep(this.outputs);\n\n    // Create a cache key to enable the internal caching, prevent querying the Utxo[] too often\n    // TODO: consider provide an option to disable the cache\n    const internalCacheKey = `${Date.now()}`;\n\n    // Fill a default recommended fee rate if props.feeRate is not provided\n    let defaultFeeRate: number | undefined;\n    if (!feeRate && !this.feeRate) {\n      const feeRates = await this.source.service.getBtcRecommendedFeeRates();\n      defaultFeeRate = feeRates.fastestFee;\n    }\n\n    // Use props.feeRate if it's specified\n    const currentFeeRate = feeRate ?? this.feeRate ?? defaultFeeRate!;\n\n    let currentFee = 0;\n    let previousFee = 0;\n    let isLoopedOnce = false;\n    let isFeeExpected = false;\n    let currentChangeIndex = -1;\n    while (!isFeeExpected) {\n      if (isLoopedOnce) {\n        previousFee = currentFee;\n        this.inputs = cloneDeep(originalInputs);\n        this.outputs = cloneDeep(originalOutputs);\n      }\n\n      const { needCollect, needReturn, inputsTotal } = this.summary();\n      const safeToProcess = inputsTotal > 0 || previousFee > 0;\n      const returnAmount = needReturn - previousFee;\n      if (safeToProcess && returnAmount > 0) {\n        // If sum(inputs) - sum(outputs) > fee, return (change - fee) to a non-fixed output or to a new output.\n        // Note when returning change to a new output, another satoshi collection may be needed.\n        const { changeIndex } = await this.injectChange({\n          address: changeAddress ?? address,\n          amount: returnAmount,\n          fromAddress: address,\n          fromPublicKey: publicKey,\n          internalCacheKey,\n          excludeUtxos,\n        });\n\n        currentChangeIndex = changeIndex;\n      } else {\n        // If the inputs have insufficient satoshi, a satoshi collection is required.\n        // For protection, at least collect 1 satoshi if the inputs are empty or the fee hasn't been calculated.\n        const protectionAmount = safeToProcess ? 0 : 1;\n        const targetAmount = needCollect - needReturn + previousFee + protectionAmount;\n        const { changeIndex } = await this.injectSatoshi({\n          address,\n          publicKey,\n          targetAmount,\n          changeAddress,\n          deductFromOutputs,\n          internalCacheKey,\n          excludeUtxos,\n        });\n\n        currentChangeIndex = changeIndex;\n      }\n\n      // Calculate network fee\n      currentFee = await this.calculateFee(currentFeeRate);\n\n      // If (fee = previousFee ±1), the fee is considered acceptable/expected.\n      isFeeExpected = [-1, 0, 1].includes(currentFee - previousFee);\n      if (!isLoopedOnce) {\n        isLoopedOnce = true;\n      }\n    }\n\n    // Clear cache for the Utxo[] list\n    this.source.cache.cleanUtxos(internalCacheKey);\n\n    return {\n      fee: currentFee,\n      feeRate: currentFeeRate,\n      changeIndex: currentChangeIndex,\n    };\n  }\n\n  async injectSatoshi(props: {\n    address: string;\n    publicKey?: string;\n    targetAmount: number;\n    changeAddress?: string;\n    injectCollected?: boolean;\n    deductFromOutputs?: boolean;\n    internalCacheKey?: string;\n    excludeUtxos?: BaseOutput[];\n  }): Promise<{\n    collected: number;\n    changeIndex: number;\n    changeAmount: number;\n  }> {\n    if (!isSupportedFromAddress(props.address)) {\n      throw TxBuildError.withComment(ErrorCodes.UNSUPPORTED_ADDRESS_TYPE, props.address);\n    }\n\n    const targetAmount = props.targetAmount;\n    const excludeUtxos = props.excludeUtxos ?? [];\n    const injectCollected = props.injectCollected ?? false;\n    const deductFromOutputs = props.deductFromOutputs ?? true;\n\n    let collected = 0;\n    let changeAmount = 0;\n\n    /**\n     * Collect from the \"from\" address via DataSource.\n     * Will update the value of inputs/collected/changeAmount.\n     *\n     * The API has two layers of data caching:\n     * - noAssetsApiCache: BtcAssetsApi cache, can be disabled if the set to true\n     * - internalCacheKey: Internal cache, enabled if the key is provided\n     */\n    const _collect = async (_targetAmount: number) => {\n      const { utxos, satoshi } = await this.source.collectSatoshi({\n        address: props.address,\n        targetAmount: _targetAmount,\n        allowInsufficient: true,\n        noAssetsApiCache: true,\n        internalCacheKey: props.internalCacheKey,\n        minUtxoSatoshi: this.minUtxoSatoshi,\n        onlyNonRgbppUtxos: this.onlyNonRgbppUtxos,\n        onlyConfirmedUtxos: this.onlyConfirmedUtxos,\n        excludeUtxos: [...this.inputs.map((v) => v.utxo), ...excludeUtxos],\n      });\n      utxos.forEach((utxo) => {\n        this.addInput({\n          ...utxo,\n          pubkey: props.publicKey,\n        });\n      });\n\n      collected += satoshi;\n      _updateChangeAmount();\n    };\n    /**\n     * Update changeAmount depends on injectedCollected:\n     * - true: If targetAmount=1000, collected=2000, changeAmount=2000+1000=3000\n     * - false: If targetAmount=1000, collected=2000, changeAmount=2000-1000=1000\n     */\n    const _updateChangeAmount = () => {\n      if (injectCollected) {\n        changeAmount = collected + targetAmount;\n      } else {\n        changeAmount = collected - targetAmount;\n      }\n    };\n\n    // 1. Collect from the non-fixed outputs\n    if (deductFromOutputs) {\n      for (let i = 0; i < this.outputs.length; i++) {\n        const output = this.outputs[i];\n        if (output.fixed) {\n          continue;\n        }\n        if (collected >= targetAmount) {\n          break;\n        }\n\n        const minUtxoSatoshi = output.minUtxoSatoshi ?? this.minUtxoSatoshi;\n        const freeAmount = output.value - minUtxoSatoshi;\n        const remain = targetAmount - collected;\n        if (output.protected) {\n          // If output.protected=true:\n          // - Only deduct free satoshi from the output\n          // - Won't destroy the output, at least keep (output.value = minUtxoSatoshi)\n          const collectAmount = Math.min(freeAmount, remain);\n          output.value -= collectAmount;\n          collected += collectAmount;\n        } else {\n          // If output.protected=false:\n          // - If (target collect amount > output.value), deduct all output.value\n          // - Destroy the output if all value is deducted\n          const collectAmount = output.value > remain ? Math.min(freeAmount, remain) : output.value;\n          output.value -= collectAmount;\n          collected += collectAmount;\n\n          if (output.value === 0) {\n            this.outputs.splice(i, 1);\n            i--;\n          }\n        }\n      }\n    }\n\n    // 2. Collect from the \"from\" address\n    if (collected < targetAmount) {\n      await _collect(targetAmount - collected);\n    }\n\n    // 3. Collect from \"from\" one more time if:\n    // - Need to create an output to return change (changeAmount > 0)\n    // - The change is insufficient for a non-dust output (changeAmount < minUtxoSatoshi)\n    const changeAddress = props.changeAddress ?? props.address;\n    const changeToOutputs = !this.canInjectChangeToOutputs(changeAddress);\n    const needChangeOutput = !changeToOutputs && changeAmount > 0 && changeAmount < this.minUtxoSatoshi;\n    const changeOutputNeedAmount = needChangeOutput ? this.minUtxoSatoshi - changeAmount : 0;\n    if (changeOutputNeedAmount > 0) {\n      await _collect(changeOutputNeedAmount);\n    }\n\n    // 4. If not collected enough satoshi, throw an error\n    const insufficientBalance = collected < targetAmount;\n    if (insufficientBalance) {\n      const recommendedDeposit = targetAmount - collected + this.minUtxoSatoshi;\n      throw TxBuildError.withComment(\n        ErrorCodes.INSUFFICIENT_UTXO,\n        `expected: ${targetAmount}, actual: ${collected}. You may wanna deposit more satoshi to prevent the error, for example: ${recommendedDeposit}`,\n      );\n    }\n    const insufficientForChange = !changeToOutputs && changeAmount > 0 && changeAmount < this.minUtxoSatoshi;\n    if (insufficientForChange) {\n      const shiftedExpectAmount = collected + changeOutputNeedAmount;\n      throw TxBuildError.withComment(\n        ErrorCodes.INSUFFICIENT_UTXO,\n        `expected: ${shiftedExpectAmount}, actual: ${collected}`,\n      );\n    }\n\n    // 5. Return change:\n    // - If changeAmount=0, no need to create a change output, and the changeIndex=-1\n    // - If changeAmount>0, return change to an output or create a change output\n    let changeIndex: number = -1;\n    if (changeAmount > 0) {\n      const injectedChanged = await this.injectChange({\n        amount: changeAmount,\n        address: changeAddress,\n        fromAddress: props.address,\n        fromPublicKey: props.publicKey,\n      });\n\n      changeIndex = injectedChanged.changeIndex;\n    }\n\n    return {\n      collected,\n      changeIndex,\n      changeAmount,\n    };\n  }\n\n  async injectChange(props: {\n    amount: number;\n    address: string;\n    fromAddress: string;\n    fromPublicKey?: string;\n    internalCacheKey?: string;\n    excludeUtxos?: BaseOutput[];\n  }): Promise<{\n    changeIndex: number;\n  }> {\n    const { address, fromAddress, fromPublicKey, amount, excludeUtxos, internalCacheKey } = props;\n\n    // If any (output.fixed != true) is found in the outputs (search in ASC order),\n    // return the change value to the first matched output.\n    for (let i = 0; i < this.outputs.length; i++) {\n      const output = this.outputs[i];\n      if (output.fixed) {\n        continue;\n      }\n      if (!('address' in output) || output.address !== address) {\n        continue;\n      }\n\n      output.value += amount;\n      return {\n        changeIndex: i,\n      };\n    }\n\n    let changeIndex: number = -1;\n    if (amount < this.minUtxoSatoshi) {\n      // If the change is not enough to create a non-dust output, try collect more.\n      // - injectCollected=true, expect to put all (collected + amount) of satoshi as change\n      // - deductFromOutputs=false, do not collect satoshi from the outputs\n      // An example:\n      // 1. Expected to return change of 500 satoshi, amount=500\n      // 2. Collected 2000 satoshi from the \"fromAddress\", collected=2000\n      // 3. Create a change output and return (collected + amount), output.value=2000+500=2500\n      const injected = await this.injectSatoshi({\n        address: fromAddress,\n        publicKey: fromPublicKey,\n        targetAmount: amount,\n        changeAddress: address,\n        injectCollected: true,\n        deductFromOutputs: false,\n        internalCacheKey,\n        excludeUtxos,\n      });\n      if (injected.collected < amount) {\n        throw TxBuildError.withComment(\n          ErrorCodes.INSUFFICIENT_UTXO,\n          `expected: ${amount}, actual: ${injected.collected}`,\n        );\n      }\n\n      changeIndex = injected.changeIndex;\n    } else {\n      this.addOutput({\n        address: address,\n        value: amount,\n      });\n\n      changeIndex = this.outputs.length - 1;\n    }\n\n    return {\n      changeIndex,\n    };\n  }\n\n  canInjectChangeToOutputs(changeAddress: string): boolean {\n    return this.outputs.some((output) => {\n      return !output.fixed && (!('address' in output) || output.address === changeAddress);\n    });\n  }\n\n  async calculateFee(feeRate?: number): Promise<number> {\n    if (!feeRate && !this.feeRate) {\n      throw TxBuildError.withComment(ErrorCodes.INVALID_FEE_RATE, `${feeRate ?? this.feeRate}`);\n    }\n\n    const currentFeeRate = feeRate ?? this.feeRate!;\n\n    const psbt = await this.createEstimatedPsbt();\n    const tx = psbt.extractTransaction(true);\n\n    const inputs = tx.ins.length;\n    const weightWithWitness = tx.byteLength(true);\n    const weightWithoutWitness = tx.byteLength(false);\n\n    const weight = weightWithoutWitness * 3 + weightWithWitness + inputs;\n    const virtualSize = Math.ceil(weight / 4);\n    return Math.ceil(virtualSize * currentFeeRate);\n  }\n\n  async createEstimatedPsbt(): Promise<bitcoin.Psbt> {\n    const estimator = FeeEstimator.fromRandom(this.networkType);\n\n    const tx = this.clone();\n    tx.inputs = tx.inputs.map((input) => {\n      const replacedUtxo = estimator.replaceUtxo(input.utxo);\n      return utxoToInput(replacedUtxo);\n    });\n\n    const psbt = tx.toPsbt();\n    await estimator.signPsbt(psbt);\n    return psbt;\n  }\n\n  summary() {\n    const inputsTotal = this.inputs.reduce((acc, input) => acc + input.utxo.value, 0);\n    const outputsTotal = this.outputs.reduce((acc, output) => acc + output.value, 0);\n\n    const inputsRemaining = inputsTotal - outputsTotal;\n    const outputsRemaining = outputsTotal - inputsTotal;\n\n    return {\n      inputsTotal,\n      outputsTotal,\n      inputsRemaining,\n      outputsRemaining,\n      needReturn: inputsRemaining > 0 ? inputsRemaining : 0,\n      needCollect: outputsRemaining > 0 ? outputsRemaining : 0,\n    };\n  }\n\n  clone(): TxBuilder {\n    const tx = new TxBuilder({\n      source: this.source,\n      feeRate: this.feeRate,\n      minUtxoSatoshi: this.minUtxoSatoshi,\n    });\n\n    tx.inputs = cloneDeep(this.inputs);\n    tx.outputs = cloneDeep(this.outputs);\n\n    return tx;\n  }\n\n  toPsbt(): bitcoin.Psbt {\n    const network = this.config.network;\n    const psbt = new bitcoin.Psbt({ network });\n    this.inputs.forEach((input) => {\n      psbt.data.addInput(input.data);\n    });\n    this.outputs.forEach((output) => {\n      psbt.addOutput(output);\n    });\n    return psbt;\n  }\n}\n","import cloneDeep from 'lodash/cloneDeep.js';\nimport { ErrorCodes, TxBuildError } from '../error';\nimport { DataSource } from '../query/source';\nimport { AddressType, AddressToPubkeyMap } from '../address';\nimport { TxInput } from './build';\nimport { limitPromiseBatchSize, remove0x, toXOnly } from '../utils';\nimport { isP2trScript } from '../script';\n\nexport interface BaseOutput {\n  txid: string;\n  vout: number;\n}\n\nexport interface Output extends BaseOutput {\n  value: number;\n  scriptPk: string;\n}\n\nexport interface Utxo extends Output {\n  addressType: AddressType;\n  address: string;\n  pubkey?: string;\n}\n\nexport function utxoToInput(utxo: Utxo): TxInput {\n  if (utxo.addressType === AddressType.P2WPKH) {\n    const data = {\n      hash: utxo.txid,\n      index: utxo.vout,\n      witnessUtxo: {\n        value: utxo.value,\n        script: Buffer.from(remove0x(utxo.scriptPk), 'hex'),\n      },\n    };\n\n    return {\n      data,\n      utxo,\n    };\n  }\n  if (utxo.addressType === AddressType.P2TR) {\n    if (!utxo.pubkey) {\n      throw TxBuildError.withComment(ErrorCodes.MISSING_PUBKEY, utxo.address);\n    }\n    const data = {\n      hash: utxo.txid,\n      index: utxo.vout,\n      witnessUtxo: {\n        value: utxo.value,\n        script: Buffer.from(remove0x(utxo.scriptPk), 'hex'),\n      },\n      tapInternalKey: toXOnly(Buffer.from(remove0x(utxo.pubkey), 'hex')),\n    };\n    return {\n      data,\n      utxo,\n    };\n  }\n\n  throw new TxBuildError(ErrorCodes.UNSUPPORTED_ADDRESS_TYPE);\n}\n\n/**\n * Fill pubkey for P2TR UTXO, and optionally throw an error if pubkey is missing\n */\nexport function fillUtxoPubkey(\n  utxo: Utxo,\n  pubkeyMap: AddressToPubkeyMap,\n  options?: {\n    requirePubkey?: boolean;\n  },\n): Utxo {\n  const newUtxo = cloneDeep(utxo);\n  if (isP2trScript(newUtxo.scriptPk) && !newUtxo.pubkey) {\n    const pubkey = pubkeyMap[newUtxo.address];\n    if (options?.requirePubkey && !pubkey) {\n      throw TxBuildError.withComment(ErrorCodes.MISSING_PUBKEY, newUtxo.address);\n    }\n    if (pubkey) {\n      newUtxo.pubkey = pubkey;\n    }\n  }\n\n  return newUtxo;\n}\n\n/**\n * Prepare and validate UTXOs for transaction building:\n * 1. Fill pubkey for P2TR UTXOs, and optionally throw an error if pubkey is missing\n * 2. Optionally check if the UTXOs are confirmed, and throw an error if not\n */\nexport async function prepareUtxoInputs(props: {\n  utxos: Utxo[];\n  source: DataSource;\n  requirePubkey?: boolean;\n  requireConfirmed?: boolean;\n  pubkeyMap?: AddressToPubkeyMap;\n}): Promise<Utxo[]> {\n  const pubkeyMap = props.pubkeyMap ?? {};\n  const utxos = props.utxos.map((utxo) => {\n    return fillUtxoPubkey(utxo, pubkeyMap, {\n      requirePubkey: props.requirePubkey,\n    });\n  });\n\n  if (props.requireConfirmed) {\n    await Promise.all(\n      utxos.map(async (utxo) => {\n        return limitPromiseBatchSize(async () => {\n          const transactionConfirmed = await props.source.isTransactionConfirmed(utxo.txid);\n          if (!transactionConfirmed) {\n            throw TxBuildError.withComment(ErrorCodes.UNCONFIRMED_UTXO, `hash: ${utxo.txid}, index: ${utxo.vout}`);\n          }\n        });\n      }),\n    );\n  }\n\n  return utxos;\n}\n","import { AddressType } from '../address';\nimport { NetworkType } from '../preset/types';\nimport { toXOnly, tweakSigner } from '../utils';\nimport { networkTypeToNetwork } from '../preset/network';\nimport { isP2trScript, isP2wpkhScript } from '../script';\nimport { ECPairInterface, bitcoin, ECPair, isTaprootInput } from '../bitcoin';\nimport { Utxo } from './utxo';\n\ninterface FeeEstimateAccount {\n  payment: bitcoin.Payment;\n  addressType: AddressType;\n  address: string;\n  scriptPubkey: string;\n  tapInternalKey?: Buffer;\n}\n\nexport class FeeEstimator {\n  public networkType: NetworkType;\n  public network: bitcoin.Network;\n\n  private readonly keyPair: ECPairInterface;\n  public readonly pubkey: string;\n  public accounts: {\n    p2wpkh: FeeEstimateAccount;\n    p2tr: FeeEstimateAccount;\n  };\n\n  constructor(wif: string, networkType: NetworkType) {\n    const network = networkTypeToNetwork(networkType);\n    this.networkType = networkType;\n    this.network = network;\n\n    const keyPair = ECPair.fromWIF(wif, network);\n    this.pubkey = keyPair.publicKey.toString('hex');\n    this.keyPair = keyPair;\n\n    const p2wpkh = bitcoin.payments.p2wpkh({\n      pubkey: keyPair.publicKey,\n      network,\n    });\n    const p2tr = bitcoin.payments.p2tr({\n      internalPubkey: toXOnly(keyPair.publicKey),\n      network,\n    });\n    this.accounts = {\n      p2wpkh: {\n        payment: p2wpkh,\n        address: p2wpkh.address!,\n        addressType: AddressType.P2WPKH,\n        scriptPubkey: p2wpkh.output!.toString('hex'),\n      },\n      p2tr: {\n        payment: p2tr,\n        address: p2tr.address!,\n        addressType: AddressType.P2TR,\n        tapInternalKey: toXOnly(keyPair.publicKey),\n        scriptPubkey: p2tr.output!.toString('hex'),\n      },\n    };\n  }\n\n  static fromRandom(networkType: NetworkType) {\n    const network = networkTypeToNetwork(networkType);\n    const keyPair = ECPair.makeRandom({ network });\n    return new FeeEstimator(keyPair.toWIF(), networkType);\n  }\n\n  replaceUtxo(utxo: Utxo): Utxo {\n    if (utxo.addressType === AddressType.P2WPKH || isP2wpkhScript(utxo.scriptPk)) {\n      utxo.scriptPk = this.accounts.p2wpkh.scriptPubkey;\n      utxo.pubkey = this.pubkey;\n    }\n    if (utxo.addressType === AddressType.P2TR || isP2trScript(utxo.scriptPk)) {\n      utxo.scriptPk = this.accounts.p2tr.scriptPubkey;\n      utxo.pubkey = this.pubkey;\n    }\n\n    return utxo;\n  }\n\n  async signPsbt(psbt: bitcoin.Psbt): Promise<bitcoin.Psbt> {\n    // Tweak signer for P2TR inputs\n    const tweakedSigner = tweakSigner(this.keyPair, {\n      network: this.network,\n    });\n\n    psbt.data.inputs.forEach((input, index) => {\n      // Fill tapInternalKey for P2TR inputs if missing\n      if (input.witnessUtxo) {\n        const isNotSigned = !(input.finalScriptSig || input.finalScriptWitness);\n        const isP2trInput = isP2trScript(input.witnessUtxo.script);\n        const lostInternalPubkey = !input.tapInternalKey;\n        if (isNotSigned && isP2trInput && lostInternalPubkey) {\n          if (input.witnessUtxo.script.toString('hex') === this.accounts.p2tr.scriptPubkey) {\n            input.tapInternalKey = this.accounts.p2tr.tapInternalKey!;\n          }\n        }\n      }\n\n      // Sign P2WPKH/P2TR inputs\n      if (isTaprootInput(input)) {\n        psbt.signInput(index, tweakedSigner);\n      } else {\n        psbt.signInput(index, this.keyPair);\n      }\n    });\n\n    psbt.finalizeAllInputs();\n    return psbt;\n  }\n}\n","import { bitcoin } from '../bitcoin';\nimport { DataSource } from '../query/source';\nimport { TxBuilder, InitOutput } from '../transaction/build';\nimport { BaseOutput, Utxo, prepareUtxoInputs } from '../transaction/utxo';\nimport { AddressToPubkeyMap, addAddressToPubkeyMap } from '../address';\nimport { TxBuildError } from '../error';\n\nexport interface SendUtxosProps {\n  inputs: Utxo[];\n  outputs: InitOutput[];\n  source: DataSource;\n  from: string;\n  feeRate?: number;\n  fromPubkey?: string;\n  changeAddress?: string;\n  minUtxoSatoshi?: number;\n  onlyConfirmedUtxos?: boolean;\n  excludeUtxos?: BaseOutput[];\n\n  // EXPERIMENTAL: the below props are unstable and can be altered at any time\n  skipInputsValidation?: boolean;\n  pubkeyMap?: AddressToPubkeyMap;\n}\n\nexport async function createSendUtxosBuilder(props: SendUtxosProps): Promise<{\n  builder: TxBuilder;\n  fee: number;\n  feeRate: number;\n  changeIndex: number;\n}> {\n  const tx = new TxBuilder({\n    source: props.source,\n    feeRate: props.feeRate,\n    minUtxoSatoshi: props.minUtxoSatoshi,\n    onlyConfirmedUtxos: props.onlyConfirmedUtxos,\n  });\n\n  try {\n    // Prepare the UTXO inputs:\n    // 1. Fill pubkey for each P2TR UTXO, and throw if the corresponding pubkey is not found\n    // 2. Throw if unconfirmed UTXOs are found (if onlyConfirmedUtxos == true && skipInputsValidation == false)\n    const pubkeyMap = addAddressToPubkeyMap(props.pubkeyMap ?? {}, props.from, props.fromPubkey);\n    const inputs = await prepareUtxoInputs({\n      utxos: props.inputs,\n      source: props.source,\n      requireConfirmed: props.onlyConfirmedUtxos && !props.skipInputsValidation,\n      requirePubkey: true,\n      pubkeyMap,\n    });\n\n    tx.addInputs(inputs);\n    tx.addOutputs(props.outputs);\n\n    const paid = await tx.payFee({\n      address: props.from,\n      publicKey: pubkeyMap[props.from],\n      changeAddress: props.changeAddress,\n      excludeUtxos: props.excludeUtxos,\n    });\n\n    return {\n      builder: tx,\n      fee: paid.fee,\n      feeRate: paid.feeRate,\n      changeIndex: paid.changeIndex,\n    };\n  } catch (e) {\n    // When caught TxBuildError, add TxBuilder as the context\n    if (e instanceof TxBuildError) {\n      e.setContext({ tx });\n    }\n\n    throw e;\n  }\n}\n\nexport async function sendUtxos(props: SendUtxosProps): Promise<bitcoin.Psbt> {\n  const { builder } = await createSendUtxosBuilder(props);\n  return builder.toPsbt();\n}\n","import { bitcoin } from '../bitcoin';\nimport { DataSource } from '../query/source';\nimport { InitOutput, TxBuilder } from '../transaction/build';\nimport { createSendUtxosBuilder } from './sendUtxos';\n\nexport interface SendBtcProps {\n  from: string;\n  tos: InitOutput[];\n  source: DataSource;\n  feeRate?: number;\n  fromPubkey?: string;\n  changeAddress?: string;\n  minUtxoSatoshi?: number;\n  onlyConfirmedUtxos?: boolean;\n}\n\nexport async function createSendBtcBuilder(props: SendBtcProps): Promise<{\n  builder: TxBuilder;\n  fee: number;\n  feeRate: number;\n  changeIndex: number;\n}> {\n  // By default, all outputs in the sendBtc() API are fixed\n  const outputs = props.tos.map((to) => ({\n    fixed: true,\n    ...to,\n  }));\n\n  return await createSendUtxosBuilder({\n    inputs: [],\n    outputs: outputs,\n    from: props.from,\n    source: props.source,\n    feeRate: props.feeRate,\n    fromPubkey: props.fromPubkey,\n    changeAddress: props.changeAddress,\n    minUtxoSatoshi: props.minUtxoSatoshi,\n    onlyConfirmedUtxos: props.onlyConfirmedUtxos,\n  });\n}\n\nexport async function sendBtc(props: SendBtcProps): Promise<bitcoin.Psbt> {\n  const { builder } = await createSendBtcBuilder(props);\n  return builder.toPsbt();\n}\n","import { BaseOutput, Utxo } from '../transaction/utxo';\nimport { DataSource } from '../query/source';\nimport { AddressToPubkeyMap } from '../address';\nimport { ErrorCodes, TxBuildError } from '../error';\nimport { InitOutput, TxBuilder } from '../transaction/build';\nimport { isOpReturnScriptPubkey } from '../transaction/embed';\nimport { networkTypeToNetwork } from '../preset/network';\nimport { networkTypeToConfig } from '../preset/config';\nimport { createSendUtxosBuilder } from './sendUtxos';\nimport { bitcoin } from '../bitcoin';\n\nexport interface SendRbfProps {\n  from: string;\n  txHex: string;\n  source: DataSource;\n  feeRate?: number;\n  fromPubkey?: string;\n  changeIndex?: number;\n  changeAddress?: string;\n  minUtxoSatoshi?: number;\n  onlyConfirmedUtxos?: boolean;\n  requireValidOutputsValue?: boolean;\n  requireGreaterFeeAndRate?: boolean;\n\n  // EXPERIMENTAL: the below props are unstable and can be altered at any time\n  pubkeyMap?: AddressToPubkeyMap;\n}\n\nexport async function createSendRbfBuilder(props: SendRbfProps): Promise<{\n  builder: TxBuilder;\n  fee: number;\n  feeRate: number;\n  changeIndex: number;\n}> {\n  const previousTx = bitcoin.Transaction.fromHex(props.txHex);\n  const network = networkTypeToNetwork(props.source.networkType);\n\n  // Rebuild inputs\n  const inputs: Utxo[] = [];\n  for (const input of previousTx.ins) {\n    const hash = Buffer.from(input.hash).reverse().toString('hex');\n    const utxo = await props.source.getUtxo(hash, input.index);\n    if (!utxo) {\n      throw TxBuildError.withComment(ErrorCodes.CANNOT_FIND_UTXO, `hash: ${hash}, index: ${input.index}`);\n    }\n    inputs.push(utxo);\n  }\n\n  // Rebuild outputs\n  const requireValidOutputsValue = props.requireValidOutputsValue ?? false;\n  const outputs: InitOutput[] = previousTx.outs.map((output) => {\n    if (isOpReturnScriptPubkey(output.script)) {\n      return {\n        script: output.script,\n        value: output.value,\n        fixed: true,\n      };\n    } else {\n      return {\n        minUtxoSatoshi: requireValidOutputsValue ? undefined : output.value,\n        address: bitcoin.address.fromOutputScript(output.script, network),\n        value: output.value,\n        fixed: true,\n      };\n    }\n  });\n\n  // Set change output if specified\n  let changeAddress: string | undefined = props.changeAddress;\n  if (props.changeIndex !== undefined) {\n    const changeOutput = outputs[props.changeIndex];\n    if (!changeOutput) {\n      throw TxBuildError.withComment(ErrorCodes.INVALID_CHANGE_OUTPUT, `outputs[${props.changeIndex}] is not found`);\n    }\n    const isReturnableOutput = changeOutput && 'address' in changeOutput;\n    if (!isReturnableOutput) {\n      throw TxBuildError.withComment(\n        ErrorCodes.INVALID_CHANGE_OUTPUT,\n        `outputs[${props.changeIndex}] is not a returnable output for change`,\n      );\n    }\n    const changeOutputAddress = changeOutput.address;\n    if (changeOutputAddress && changeAddress && changeAddress !== changeOutputAddress) {\n      throw TxBuildError.withComment(\n        ErrorCodes.INVALID_CHANGE_OUTPUT,\n        `The address of outputs[${props.changeIndex}] does not match the specified changeAddress, expected: ${changeAddress}, actual: ${changeOutputAddress}`,\n      );\n    }\n    if (changeOutputAddress && !changeAddress) {\n      changeAddress = changeOutputAddress;\n    }\n    const isLastOutput = outputs.length === props.changeIndex + 1;\n    if (isLastOutput) {\n      outputs.pop();\n    } else {\n      const config = networkTypeToConfig(props.source.networkType);\n      const minUtxoSatoshi = props.minUtxoSatoshi ?? config.btcUtxoDustLimit;\n      changeOutput.minUtxoSatoshi = minUtxoSatoshi;\n      changeOutput.value = minUtxoSatoshi;\n      changeOutput.protected = true;\n      changeOutput.fixed = false;\n    }\n  }\n\n  // Fee rate\n  const requireGreaterFeeAndRate = props.requireGreaterFeeAndRate ?? true;\n  let feeRate: number | undefined = props.feeRate;\n  if (requireGreaterFeeAndRate && !feeRate) {\n    const feeRates = await props.source.service.getBtcRecommendedFeeRates();\n    feeRate = feeRates.fastestFee;\n  }\n\n  // The RBF transaction should offer a higher fee rate\n  const previousInsValue = inputs.reduce((sum, input) => sum + input.value, 0);\n  const previousOutsValue = previousTx.outs.reduce((sum, output) => sum + output.value, 0);\n  const previousFee = previousInsValue - previousOutsValue;\n  const previousFeeRate = Math.floor(previousFee / previousTx.virtualSize());\n  if (requireGreaterFeeAndRate && feeRate !== undefined && feeRate <= previousFeeRate) {\n    throw TxBuildError.withComment(\n      ErrorCodes.INVALID_FEE_RATE,\n      `RBF should offer a higher fee rate, previous: ${previousFeeRate}, current: ${feeRate}`,\n    );\n  }\n\n  // Exclude all outputs of the previous transaction during the collection\n  // TODO: also exclude all outputs of the previous transaction's children transactions\n  const previousTxId = previousTx.getId();\n  const excludeUtxos: BaseOutput[] = previousTx.outs.map((_, index) => ({\n    txid: previousTxId,\n    vout: index,\n  }));\n\n  // Build RBF transaction\n  const res = await createSendUtxosBuilder({\n    inputs,\n    outputs,\n    excludeUtxos,\n    changeAddress,\n    from: props.from,\n    source: props.source,\n    feeRate: props.feeRate,\n    pubkeyMap: props.pubkeyMap,\n    fromPubkey: props.fromPubkey,\n    minUtxoSatoshi: props.minUtxoSatoshi,\n    onlyConfirmedUtxos: props.onlyConfirmedUtxos ?? true,\n    skipInputsValidation: true,\n  });\n\n  // The RBF transaction should offer a higher fee amount\n  if (requireGreaterFeeAndRate && res.fee <= previousFee) {\n    throw TxBuildError.withComment(\n      ErrorCodes.INVALID_FEE_RATE,\n      `RBF should offer a higher fee amount, previous: ${previousFee}, current: ${res.fee}`,\n    );\n  }\n\n  return res;\n}\n\nexport async function sendRbf(props: SendRbfProps): Promise<bitcoin.Psbt> {\n  const { builder } = await createSendRbfBuilder(props);\n  return builder.toPsbt();\n}\n","import {\n  Collector,\n  isRgbppLockCell,\n  isBtcTimeLockCell,\n  calculateCommitment,\n  unpackRgbppLockArgs,\n  checkCkbTxInputsCapacitySufficient,\n} from '@rgbpp-sdk/ckb';\nimport { bitcoin } from '../bitcoin';\nimport { BaseOutput, Utxo } from '../transaction/utxo';\nimport { AddressToPubkeyMap } from '../address';\nimport { DataSource } from '../query/source';\nimport { NetworkType } from '../preset/types';\nimport { ErrorCodes, TxBuildError } from '../error';\nimport { InitOutput, TxAddressOutput, TxBuilder } from '../transaction/build';\nimport { networkTypeToConfig } from '../preset/config';\nimport { createSendUtxosBuilder } from './sendUtxos';\nimport { limitPromiseBatchSize } from '../utils';\n\nexport interface SendRgbppUtxosProps {\n  ckbVirtualTx: CKBComponents.RawTransaction;\n  commitment: string;\n  tos?: string[];\n  paymaster?: TxAddressOutput;\n  needPaymaster?: boolean;\n\n  ckbCollector: Collector;\n  rgbppMinUtxoSatoshi?: number;\n\n  source: DataSource;\n  from: string;\n  feeRate?: number;\n  fromPubkey?: string;\n  changeAddress?: string;\n  minUtxoSatoshi?: number;\n  onlyConfirmedUtxos?: boolean;\n  excludeUtxos?: BaseOutput[];\n\n  // EXPERIMENTAL: the below props are unstable and can be altered at any time\n  pubkeyMap?: AddressToPubkeyMap;\n}\n\n/**\n * @deprecated Use createSendRgbppUtxosBuilder() API instead.\n */\nexport const sendRgbppUtxosBuilder = createSendRgbppUtxosBuilder;\n\nexport async function createSendRgbppUtxosBuilder(props: SendRgbppUtxosProps): Promise<{\n  builder: TxBuilder;\n  fee: number;\n  feeRate: number;\n  changeIndex: number;\n}> {\n  const btcInputs: Utxo[] = [];\n  const btcOutputs: InitOutput[] = [];\n  let lastCkbTypeOutputIndex = -1;\n\n  const ckbVirtualTx = props.ckbVirtualTx;\n  const config = networkTypeToConfig(props.source.networkType);\n  const isCkbMainnet = props.source.networkType === NetworkType.MAINNET;\n\n  const rgbppLockArgsList = (\n    await props.ckbCollector.getLiveCells(ckbVirtualTx.inputs.map((input) => input.previousOutput!))\n  ).map((cell) =>\n    isRgbppLockCell(cell.output, isCkbMainnet) ? unpackRgbppLockArgs(cell.output.lock.args) : undefined,\n  );\n\n  // Batch querying UTXO from BtcAssetsApi\n  const btcUtxos = await Promise.all(\n    rgbppLockArgsList.map((rgbppLockArgs) => {\n      if (rgbppLockArgs) {\n        return limitPromiseBatchSize(() =>\n          props.source.getUtxo(rgbppLockArgs.btcTxId, rgbppLockArgs.outIndex, props.onlyConfirmedUtxos),\n        );\n      }\n      return undefined;\n    }),\n  );\n\n  // Handle and check inputs\n  for (let i = 0; i < ckbVirtualTx.inputs.length; i++) {\n    const rgbppLockArgs = rgbppLockArgsList[i];\n\n    // Add to inputs if all the following conditions are met:\n    // 1. input.lock.args can be unpacked to RgbppLockArgs\n    // 2. utxo can be found via the DataSource.getUtxo() API\n    // 3. utxo is not duplicated in the inputs\n    if (rgbppLockArgs) {\n      const utxo = btcUtxos[i];\n      if (!utxo) {\n        throw TxBuildError.withComment(\n          ErrorCodes.CANNOT_FIND_UTXO,\n          `hash: ${rgbppLockArgs.btcTxId}, index: ${rgbppLockArgs.outIndex}`,\n        );\n      }\n\n      const foundInInputs = btcInputs.some((v) => v.txid === utxo.txid && v.vout === utxo.vout);\n      if (!foundInInputs) {\n        btcInputs.push(utxo);\n      }\n    }\n  }\n\n  // The inputs.length should be >= 1\n  if (btcInputs.length < 1) {\n    throw new TxBuildError(ErrorCodes.CKB_INVALID_INPUTS);\n  }\n\n  // Handle and check outputs\n  for (let i = 0; i < ckbVirtualTx.outputs.length; i++) {\n    const ckbOutput = ckbVirtualTx.outputs[i];\n    const isRgbppLock = isRgbppLockCell(ckbOutput, isCkbMainnet);\n    const isBtcTimeLock = isBtcTimeLockCell(ckbOutput, isCkbMainnet);\n\n    // If output.type !== null, then the output.lock must be RgbppLock or RgbppTimeLock\n    if (ckbOutput.type) {\n      if (!isRgbppLock && !isBtcTimeLock) {\n        throw new TxBuildError(ErrorCodes.CKB_INVALID_CELL_LOCK);\n      }\n\n      // If output.type !== null，update lastTypeInput\n      lastCkbTypeOutputIndex = i;\n    }\n\n    // If output.lock == RgbppLock, generate a corresponding output in outputs\n    if (isRgbppLock) {\n      const toBtcAddress = props.tos?.[i];\n      const minUtxoSatoshi = props.rgbppMinUtxoSatoshi ?? config.rgbppUtxoDustLimit;\n      btcOutputs.push({\n        fixed: true,\n        address: toBtcAddress ?? props.from,\n        value: minUtxoSatoshi,\n        minUtxoSatoshi,\n      });\n    }\n  }\n\n  // By rules, the length of type outputs should be >= 1\n  // The \"lastTypeOutputIndex\" is -1 by default so if (index < 0) it's invalid\n  if (lastCkbTypeOutputIndex < 0) {\n    throw new TxBuildError(ErrorCodes.CKB_INVALID_OUTPUTS);\n  }\n\n  // Verify the provided commitment\n  const calculatedCommitment = calculateCommitment({\n    inputs: ckbVirtualTx.inputs,\n    outputs: ckbVirtualTx.outputs.slice(0, lastCkbTypeOutputIndex + 1),\n    outputsData: ckbVirtualTx.outputsData.slice(0, lastCkbTypeOutputIndex + 1),\n  });\n  if (props.commitment !== calculatedCommitment) {\n    throw new TxBuildError(ErrorCodes.CKB_UNMATCHED_COMMITMENT);\n  }\n\n  const mergedBtcOutputs = await getMergedBtcOutputs(btcOutputs, props);\n\n  return await createSendUtxosBuilder({\n    inputs: btcInputs,\n    outputs: mergedBtcOutputs,\n    from: props.from,\n    source: props.source,\n    feeRate: props.feeRate,\n    fromPubkey: props.fromPubkey,\n    changeAddress: props.changeAddress,\n    minUtxoSatoshi: props.minUtxoSatoshi,\n    onlyConfirmedUtxos: props.onlyConfirmedUtxos,\n    excludeUtxos: props.excludeUtxos,\n    pubkeyMap: props.pubkeyMap,\n  });\n}\n\nasync function getMergedBtcOutputs(btcOutputs: InitOutput[], props: SendRgbppUtxosProps): Promise<InitOutput[]> {\n  const merged: InitOutput[] = [];\n\n  // Add commitment to the beginning of outputs\n  merged.push({\n    data: props.commitment,\n    fixed: true,\n    value: 0,\n  });\n\n  // Add outputs\n  merged.push(...btcOutputs);\n\n  // Check paymaster info\n  const defaultPaymaster = await props.source.getPaymasterOutput();\n  const isPaymasterUnmatched =\n    defaultPaymaster?.address !== props.paymaster?.address || defaultPaymaster?.value !== props.paymaster?.value;\n  if (defaultPaymaster && props.paymaster && isPaymasterUnmatched) {\n    throw TxBuildError.withComment(\n      ErrorCodes.PAYMASTER_MISMATCH,\n      `expected: ${defaultPaymaster}, actual: ${props.paymaster}`,\n    );\n  }\n\n  // Add paymaster output, only if paymaster address exists and needed\n  const paymaster = defaultPaymaster ?? props.paymaster;\n  const isNeedPaymasterOutput = await (async () => {\n    if (props.needPaymaster !== undefined) {\n      return props.needPaymaster;\n    }\n    const isInputsSufficient = await checkCkbTxInputsCapacitySufficient(props.ckbVirtualTx, props.ckbCollector);\n    return !isInputsSufficient;\n  })();\n  if (paymaster && isNeedPaymasterOutput) {\n    merged.push({\n      ...paymaster,\n      fixed: true,\n    });\n  }\n\n  return merged;\n}\n\nexport async function sendRgbppUtxos(props: SendRgbppUtxosProps): Promise<bitcoin.Psbt> {\n  const { builder } = await createSendRgbppUtxosBuilder(props);\n  return builder.toPsbt();\n}\n"],"mappings":"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","names":["ecc","NetworkType","ecc","ErrorCodes","cloneDeep","ecc","limitPromiseConcurrency","AddressType","ServiceErrorCodes","import_cloneDeep","import_cloneDeep","cloneDeep","cloneDeep"]}